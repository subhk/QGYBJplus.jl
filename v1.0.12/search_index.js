var documenterSearchIndex = {"docs":
[{"location":"physics/overview/#physics-overview","page":"Model Overview","title":"Model Overview","text":"QGYBJ+.jl simulates the interaction between mesoscale eddies and near-inertial waves.","category":"section"},{"location":"physics/overview/#The-Two-Components","page":"Model Overview","title":"The Two Components","text":"Component Variable Scale Dynamics\nEddies ψ (streamfunction) 50-200 km, weeks Advection of PV\nWaves B (wave envelope) 10-50 km, hours Advection + refraction\n\nInteractions: Eddies refract waves (focusing in anticyclones); waves feed energy back to eddies.","category":"section"},{"location":"physics/overview/#Governing-Equations","page":"Model Overview","title":"Governing Equations","text":"","category":"section"},{"location":"physics/overview/#QG-Potential-Vorticity","page":"Model Overview","title":"QG Potential Vorticity","text":"fracpartial qpartial t + J(psi q) + J(psi q^w) = textdissipation\n\nwhere q = nabla^2psi + fracf_0^2N^2fracpartial^2psipartial z^2","category":"section"},{"location":"physics/overview/#YBJ-Wave-Envelope","page":"Model Overview","title":"YBJ+ Wave Envelope","text":"fracpartial Bpartial t + J(psi B) = ifrack_h^22 cdot Bu cdot Ro A + frac12zeta B + textdissipation\n\nwhere B = L^+ A and A is recovered via elliptic inversion.","category":"section"},{"location":"physics/overview/#Physical-Processes","page":"Model Overview","title":"Physical Processes","text":"Process Term Effect\nAdvection J(psi B) Waves carried by flow\nRefraction frac12zeta B Waves focus in anticyclones\nDispersion i k_h^2 A Horizontal spreading\n\ntip: Wave Trapping\nEffective frequency f_texteff = f_0 + zeta2. In anticyclones (ζ < 0), waves slow and accumulate.","category":"section"},{"location":"physics/overview/#Variables","page":"Model Overview","title":"Variables","text":"Type Variables\nPrognostic q (potential vorticity), B (wave envelope)\nDiagnostic ψ (from q), A (from B), u, v (from ψ)","category":"section"},{"location":"physics/overview/#Boundary-Conditions","page":"Model Overview","title":"Boundary Conditions","text":"Horizontal: Doubly periodic\nVertical: Rigid lid (w=0 at z=0, z=-Lz), no-flux (∂ψ/∂z=0)\n\nwarning: Coordinate Convention\nz = 0 at surface, z = -Lz at bottom.","category":"section"},{"location":"physics/overview/#See-Also","page":"Model Overview","title":"See Also","text":"QG Equations\nYBJ+ Wave Model\nWave-Mean Interaction\nNumerical Methods","category":"section"},{"location":"guide/io/#io-output","page":"I/O and Output","title":"I/O and Output","text":"This page explains how to save and load simulation data in QGYBJ+.jl.","category":"section"},{"location":"guide/io/#Output-Formats","page":"I/O and Output","title":"Output Formats","text":"QGYBJ+.jl supports multiple output formats:\n\nFormat Extension Use Case Parallel Support\nNetCDF .nc Analysis, visualization Yes\nJLD2 .jld2 Restart files, full state Yes\nHDF5 .h5 Large datasets Yes","category":"section"},{"location":"guide/io/#NetCDF-Output","page":"I/O and Output","title":"NetCDF Output","text":"","category":"section"},{"location":"guide/io/#Basic-Setup","page":"I/O and Output","title":"Basic Setup","text":"using NCDatasets\n\n# Configure output\noutput_config = OutputConfig(\n    dir = \"output\",\n    prefix = \"qgybj\",\n    interval = 100,           # Steps between outputs\n    variables = [:psi, :B, :q],\n    format = :netcdf\n)\n\n# Initialize output file\ninit_output!(output_config, grid, params)","category":"section"},{"location":"guide/io/#Writing-Data","page":"I/O and Output","title":"Writing Data","text":"# In time loop\nfor step = 1:nsteps\n    timestep!(state, ...)\n\n    # Write at specified intervals\n    if step % output_config.interval == 0\n        write_output!(output_config, state, grid, step, time)\n    end\nend\n\n# Close file\nclose_output!(output_config)","category":"section"},{"location":"guide/io/#Output-Variables","page":"I/O and Output","title":"Output Variables","text":"Variable Description Dimensions\npsi Streamfunction (physical) (x, y, z, t)\nLAr, LAi Wave envelope B = L⁺A real/imag parts (physical) (x, y, z, t)\nAr, Ai Wave amplitude A real/imag parts (physical) (x, y, z, t)\nq Potential vorticity (spectral) (kx, ky, z, t)\nu, v Velocities (physical) (x, y, z, t)\nenergy Domain-integrated energy (t)\n\nnote: Wave field naming\nLAr, LAi: Real and imaginary parts of the wave envelope B = L^+ A\nAr, Ai: Real and imaginary parts of the wave amplitude A\nBoth are needed to compute wave kinetic energy per equation (4.7): textWKE = frac12LA^2 where LA = B + (k_h^24)A","category":"section"},{"location":"guide/io/#Custom-Variables","page":"I/O and Output","title":"Custom Variables","text":"# Add custom diagnostic\nfunction my_diagnostic(state, grid)\n    return sum(abs2.(state.psi)) * grid.dx * grid.dy * grid.dz\nend\n\n# Register custom output\nadd_output_variable!(output_config, \"my_diag\", my_diagnostic;\n    dims = (\"time\",),\n    units = \"m^4/s^2\"\n)","category":"section"},{"location":"guide/io/#Reading-NetCDF-Data","page":"I/O and Output","title":"Reading NetCDF Data","text":"","category":"section"},{"location":"guide/io/#Basic-Reading","page":"I/O and Output","title":"Basic Reading","text":"using NCDatasets\n\nds = NCDataset(\"output/qgybj_0001.nc\")\n\n# Read variables\npsi = ds[\"psi\"][:]      # Full 4D array (kx, ky, z, time)\ntime = ds[\"time\"][:]    # Time coordinate\n\n# Read single snapshot\npsi_t10 = ds[\"psi\"][:, :, :, 10]\n\nclose(ds)","category":"section"},{"location":"guide/io/#Lazy-Reading","page":"I/O and Output","title":"Lazy Reading","text":"For large files, read lazily:\n\nds = NCDataset(\"output/qgybj_0001.nc\")\n\n# This doesn't load data yet\npsi_var = ds[\"psi\"]\n\n# Load only what you need\nfor t in 1:10\n    snapshot = psi_var[:, :, :, t]\n    # Process snapshot\nend\n\nclose(ds)","category":"section"},{"location":"guide/io/#Using-do-Block","page":"I/O and Output","title":"Using do Block","text":"NCDataset(\"output/qgybj_0001.nc\") do ds\n    psi = ds[\"psi\"][:]\n    # Process data\nend  # File automatically closed","category":"section"},{"location":"guide/io/#JLD2-for-Restart-Files","page":"I/O and Output","title":"JLD2 for Restart Files","text":"","category":"section"},{"location":"guide/io/#Saving-State","page":"I/O and Output","title":"Saving State","text":"using JLD2\n\n# Save full state for restart\n@save \"restart.jld2\" state grid params step time\n\n# Or more selectively\njldsave(\"restart.jld2\";\n    psi = state.psi,\n    B = state.B,\n    q = state.q,\n    step = step,\n    time = time\n)","category":"section"},{"location":"guide/io/#Loading-State","page":"I/O and Output","title":"Loading State","text":"# Load everything\n@load \"restart.jld2\" state grid params step time\n\n# Or selectively\ndata = load(\"restart.jld2\")\npsi = data[\"psi\"]\nstep = data[\"step\"]","category":"section"},{"location":"guide/io/#Restarting-Simulation","page":"I/O and Output","title":"Restarting Simulation","text":"# Load restart file\n@load \"restart.jld2\" state grid params step_start time_start\n\n# Continue simulation\nfor step = step_start+1:nsteps\n    timestep!(state, ...)\nend","category":"section"},{"location":"guide/io/#Checkpointing","page":"I/O and Output","title":"Checkpointing","text":"","category":"section"},{"location":"guide/io/#Automatic-Checkpoints","page":"I/O and Output","title":"Automatic Checkpoints","text":"config = create_simple_config(\n    # ...\n    checkpoint_interval = 1000,  # Steps between checkpoints\n    checkpoint_dir = \"checkpoints\"\n)","category":"section"},{"location":"guide/io/#Manual-Checkpointing","page":"I/O and Output","title":"Manual Checkpointing","text":"function save_checkpoint(state, grid, params, step, time)\n    filename = \"checkpoints/checkpoint_$(lpad(step, 8, '0')).jld2\"\n    @save filename state grid params step time\n    return filename\nend\n\n# In time loop\nif step % checkpoint_interval == 0\n    save_checkpoint(state, grid, params, step, time)\nend","category":"section"},{"location":"guide/io/#Checkpoint-Rotation","page":"I/O and Output","title":"Checkpoint Rotation","text":"Keep only recent checkpoints to save disk space:\n\nfunction rotate_checkpoints(dir, keep_n=3)\n    files = sort(glob(\"checkpoint_*.jld2\", dir))\n    while length(files) > keep_n\n        rm(popfirst!(files))\n    end\nend","category":"section"},{"location":"guide/io/#Diagnostics-Output","page":"I/O and Output","title":"Diagnostics Output","text":"","category":"section"},{"location":"guide/io/#Time-Series","page":"I/O and Output","title":"Time Series","text":"# Collect diagnostics during run\ndiagnostics = DiagnosticsTimeSeries()\n\nfor step = 1:nsteps\n    timestep!(state, ...)\n\n    # Compute and store diagnostics\n    record!(diagnostics, step, time,\n        KE = flow_kinetic_energy(state.u, state.v),\n        PE = flow_potential_energy(state.psi, grid),\n        WE = wave_energy(state.B, state.A)\n    )\nend\n\n# Save to file\nsave_diagnostics(\"diagnostics.csv\", diagnostics)","category":"section"},{"location":"guide/io/#Format","page":"I/O and Output","title":"Format","text":"step,time,KE,PE,WE\n0,0.0,0.0123,0.0045,0.0089\n100,0.1,0.0121,0.0044,0.0087\n...","category":"section"},{"location":"guide/io/#MPI-Parallel-I/O-with-2D-Decomposition","page":"I/O and Output","title":"MPI Parallel I/O with 2D Decomposition","text":"QGYBJ+.jl provides seamless I/O support for 2D pencil decomposition. The I/O functions automatically handle distributed arrays.","category":"section"},{"location":"guide/io/#Writing-State-Files","page":"I/O and Output","title":"Writing State Files","text":"using MPI, PencilArrays, PencilFFTs, QGYBJplus\n\nMPI.Init()\nmpi_config = QGYBJplus.setup_mpi_environment()\n\n# Setup distributed grid and state\ngrid = QGYBJplus.init_mpi_grid(params, mpi_config)\nplans = QGYBJplus.plan_mpi_transforms(grid, mpi_config)\nstate = QGYBJplus.init_mpi_state(grid, plans, mpi_config)\n\n# Create output manager with parallel config\noutput_config = OutputConfig(\n    output_dir = \"output\",\n    state_file_pattern = \"state%04d.nc\",\n    psi_interval = 0.1,\n    wave_interval = 0.1\n)\nmanager = OutputManager(output_config, params, mpi_config)\n\n# Write state - automatically handles 2D decomposition\nwrite_state_file(manager, state, grid, plans, time, mpi_config)","category":"section"},{"location":"guide/io/#Reading-Initial-Conditions","page":"I/O and Output","title":"Reading Initial Conditions","text":"# Read psi - works in both serial and parallel mode\npsi = read_initial_psi(\"initial_psi.nc\", grid, plans; parallel_config=mpi_config)\n# In parallel: rank 0 reads, then scatters to all processes\n\n# Read wave field\nB = read_initial_waves(\"initial_waves.nc\", grid, plans; parallel_config=mpi_config)\n\n# Or use legacy wrappers with parallel support\nncread_psi!(state, grid, plans; path=\"psi.nc\", parallel_config=mpi_config)\nncread_la!(state, grid, plans; path=\"la.nc\", parallel_config=mpi_config)","category":"section"},{"location":"guide/io/#I/O-Strategy-for-2D-Decomposition","page":"I/O and Output","title":"I/O Strategy for 2D Decomposition","text":"QGYBJ+.jl uses a gather-to-root strategy for parallel I/O:\n\n┌─────────────────────────────────────────────────────────────┐\n│                    Parallel I/O Strategy                    │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  WRITING:                                                   │\n│  ┌─────────┐   gather_to_root   ┌─────────┐   write   ┌───┐ │\n│  │ Rank 0  │ ←───────────────── │ Rank 0  │ ────────→ │.nc│ │\n│  │ Rank 1  │                    │ (full   │           └───┘ │\n│  │ Rank 2  │                    │  array) │                 │\n│  │   ...   │                    └─────────┘                 │\n│  └─────────┘                                                │\n│                                                             │\n│  READING:                                                   │\n│  ┌───┐   read    ┌─────────┐  scatter_from_root  ┌────────┐ │\n│  │.nc│ ────────→ │ Rank 0  │ ──────────────────→ │ Rank 0 │ │\n│  └───┘           │ (full   │                     │ Rank 1 │ │\n│                  │  array) │                     │ Rank 2 │ │\n│                  └─────────┘                     │   ...  │ │\n│                                                  └────────┘ │\n└─────────────────────────────────────────────────────────────┘\n\nThis approach is:\n\nSimple: No parallel NetCDF library required\nReliable: Standard serial NetCDF always works\nPortable: Works on any system","category":"section"},{"location":"guide/io/#Local-Index-Ranges-for-Manual-I/O","page":"I/O and Output","title":"Local Index Ranges for Manual I/O","text":"# Get local ranges for this process (xy-pencil)\nif grid.decomp !== nothing\n    local_range = grid.decomp.local_range_xy\n    # local_range = (1:nx_local, y_start:y_end, z_start:z_end)\nelse\n    local_range = (1:grid.nx, 1:grid.ny, 1:grid.nz)\nend\n\n# Use with NCDatasets for manual parallel writes\nNCDatasets.Dataset(\"output.nc\", \"c\"; comm=mpi_config.comm) do ds\n    ds.dim[\"x\"] = grid.nx\n    ds.dim[\"y\"] = grid.ny\n    ds.dim[\"z\"] = grid.nz\n\n    psi_var = NCDatasets.defVar(ds, \"psi\", Float64, (\"x\", \"y\", \"z\"))\n\n    # Each rank writes its portion\n    psi_var[local_range[1], local_range[2], local_range[3]] = local_psi_data\nend","category":"section"},{"location":"guide/io/#Gather/Scatter-for-I/O","page":"I/O and Output","title":"Gather/Scatter for I/O","text":"# Gather distributed array to rank 0\nglobal_psi = QGYBJplus.gather_to_root(state.psi, grid, mpi_config)\n# Returns full array on rank 0, nothing on other ranks\n\n# Scatter from rank 0 to all processes\nlocal_psi = QGYBJplus.scatter_from_root(global_psi, grid, mpi_config)\n# Each rank receives its local portion","category":"section"},{"location":"guide/io/#Physical-Space-Output","page":"I/O and Output","title":"Physical Space Output","text":"","category":"section"},{"location":"guide/io/#Transform-Before-Writing","page":"I/O and Output","title":"Transform Before Writing","text":"# Spectral → Physical\npsi_phys = irfft(state.psi, grid.nx)\n\n# Write physical space data\nds[\"psi_phys\"][:, :, :, t] = psi_phys","category":"section"},{"location":"guide/io/#Vorticity","page":"I/O and Output","title":"Vorticity","text":"# Compute vorticity (spectral)\nzeta_k = -grid.kh2 .* state.psi\n\n# Transform to physical\nzeta = irfft(zeta_k, grid.nx)\n\nds[\"vorticity\"][:, :, :, t] = zeta","category":"section"},{"location":"guide/io/#Output-Best-Practices","page":"I/O and Output","title":"Output Best Practices","text":"","category":"section"},{"location":"guide/io/#File-Naming","page":"I/O and Output","title":"File Naming","text":"# Include simulation info in filename\nprefix = \"qgybj_nx$(nx)_nz$(nz)\"\n\n# Timestamp outputs\ntimestamp = Dates.format(now(), \"yyyymmdd_HHMMSS\")\nfilename = \"$(prefix)_$(timestamp).nc\"","category":"section"},{"location":"guide/io/#Compression","page":"I/O and Output","title":"Compression","text":"# Enable compression for NetCDF\ndefVar(ds, \"psi\", Float64, (\"x\", \"y\", \"z\", \"time\");\n    deflatelevel = 5,  # 0-9, higher = more compression\n    chunksizes = (nx, ny, nz, 1)  # Chunk by time slice\n)","category":"section"},{"location":"guide/io/#Metadata","page":"I/O and Output","title":"Metadata","text":"# Add attributes\nds.attrib[\"title\"] = \"QGYBJ+.jl simulation output\"\nds.attrib[\"history\"] = \"Created $(now())\"\nds.attrib[\"Conventions\"] = \"CF-1.8\"\n\n# Variable attributes\nds[\"psi\"].attrib[\"long_name\"] = \"Streamfunction\"\nds[\"psi\"].attrib[\"units\"] = \"m^2/s\"","category":"section"},{"location":"guide/io/#Visualization-Integration","page":"I/O and Output","title":"Visualization Integration","text":"","category":"section"},{"location":"guide/io/#Quick-Plotting","page":"I/O and Output","title":"Quick Plotting","text":"using Plots, NCDatasets\n\nNCDataset(\"output.nc\") do ds\n    psi = ds[\"psi\"][:, :, end, end]  # Surface, last time\n    heatmap(real(irfft(psi, nx)), title=\"Surface ψ\")\nend","category":"section"},{"location":"guide/io/#Animation","page":"I/O and Output","title":"Animation","text":"using Plots\n\nNCDataset(\"output.nc\") do ds\n    anim = @animate for t in 1:size(ds[\"psi\"], 4)\n        psi = ds[\"psi\"][:, :, end, t]\n        heatmap(real(irfft(psi, nx)),\n            title = \"t = $(ds[\"time\"][t])\",\n            clim = (-1, 1)\n        )\n    end\n    gif(anim, \"animation.gif\", fps=10)\nend","category":"section"},{"location":"guide/io/#API-Reference","page":"I/O and Output","title":"API Reference","text":"For I/O operations, use the following approaches:\n\nNetCDF reading: Use NCDatasets.jl directly as shown above\nInitial conditions: ncread_psi!, ncread_la! for loading spectral fields\nParallel I/O: gather_to_root, scatter_from_root for 2D decomposition\n\nSee the Grid & State API for field initialization functions.","category":"section"},{"location":"guide/diagnostics/#diagnostics","page":"Diagnostics","title":"Diagnostics","text":"This page describes diagnostic quantities and analysis tools in QGYBJ+.jl.","category":"section"},{"location":"guide/diagnostics/#Energy-Diagnostics","page":"Diagnostics","title":"Energy Diagnostics","text":"","category":"section"},{"location":"guide/diagnostics/#Flow-Kinetic-Energy","page":"Diagnostics","title":"Flow Kinetic Energy","text":"The kinetic energy of the balanced flow:\n\nKE = frac12int (u^2 + v^2)  dV\n\nKE = flow_kinetic_energy(state.u, state.v)","category":"section"},{"location":"guide/diagnostics/#Flow-Potential-Energy-(Spectral)","page":"Diagnostics","title":"Flow Potential Energy (Spectral)","text":"Available potential energy computed in spectral space with proper dealiasing:\n\nPE = frac12int fracf_0^2N^2left(fracpartialpsipartial zright)^2 dV\n\n# Compute buoyancy field first (b = ∂ψ/∂z)\nbk = similar(state.psi)\n# ... compute vertical derivative ...\nPE = flow_potential_energy_spectral(bk, grid, params)","category":"section"},{"location":"guide/diagnostics/#Wave-Energy","page":"Diagnostics","title":"Wave Energy","text":"The wave kinetic energy is computed per YBJ+ equation (4.7):\n\ntextWKE = frac12int LA^2  dV\n\nwhere LA is computed directly using the L operator from equation (1.3):\n\nL = partial_z left( fracf^2N^2 partial_z right)\n\nSo LA = partial_z(a(z) times C) where a(z) = f^2N^2 and C = partial Apartial z.\n\n# Detailed wave energy components\nWKE, WPE, WCE = compute_detailed_wave_energy(state, grid, params)\n\n# Simple wave kinetic energy\nWE = compute_wave_energy(state, grid, plans; params=params)\n\n# Basic wave energy from B and A fields\nWE_B, WE_A = wave_energy(state.B, state.A)\n\nnote: Physical interpretation\nWKE uses LA^2 where LA is computed by applying the vertical operator L directly to the wave amplitude A. This matches the YBJ+ paper's definition.","category":"section"},{"location":"guide/diagnostics/#Energy-Diagnostics-Output-Files","page":"Diagnostics","title":"Energy Diagnostics Output Files","text":"QGYBJ+.jl automatically saves energy diagnostics to separate files in a dedicated diagnostic/ folder, following the structure used in the Fortran QG_YBJp code.","category":"section"},{"location":"guide/diagnostics/#Output-Folder-Structure","page":"Diagnostics","title":"Output Folder Structure","text":"output_dir/\n├── state0001.nc              # Field snapshots\n├── state0002.nc\n├── diagnostics_0001.nc       # Legacy combined diagnostics\n└── diagnostic/               # Separate energy files\n    ├── wave_KE.nc            # Wave kinetic energy time series\n    ├── wave_PE.nc            # Wave potential energy time series\n    ├── wave_CE.nc            # Wave correction energy (YBJ+)\n    ├── mean_flow_KE.nc       # Mean flow kinetic energy\n    ├── mean_flow_PE.nc       # Mean flow potential energy\n    └── total_energy.nc       # Summary file with all energies","category":"section"},{"location":"guide/diagnostics/#Wave-Kinetic-Energy-(WKE)","page":"Diagnostics","title":"Wave Kinetic Energy (WKE)","text":"The wave kinetic energy is computed per YBJ+ equation (4.7):\n\ntextWKE = frac12 sum_k_x k_y z LA^2 - text(dealiasing correction)\n\nwhere LA = B + (k_h^24)A in spectral space. This relationship comes from:\n\nB = L^+ A = LA + frac14Delta A\nIn spectral space: Delta rightarrow -k_h^2, so B = LA - (k_h^24)A\nTherefore: LA = B + (k_h^24)A\n\nPhysical interpretation: WKE represents the kinetic energy contained in the near-inertial wave field, computed from the wave variable LA (not the evolved envelope B = L^+A). This ensures consistency with the energy budget in the YBJ+ formulation.","category":"section"},{"location":"guide/diagnostics/#Wave-Potential-Energy-(WPE)","page":"Diagnostics","title":"Wave Potential Energy (WPE)","text":"The wave potential energy captures vertical wave structure through C = partial Apartial z:\n\ntextWPE = frac12 sum_k_x k_y z frack_h^22 a_ell left( C_R^2 + C_I^2 right)\n\nwhere:\n\na_ell = f_0^2  N^2 is the elliptic coefficient\nC = partial A  partial z is the vertical derivative of wave amplitude\nk_h^2 = k_x^2 + k_y^2 is the horizontal wavenumber squared\n\nPhysical interpretation: WPE represents the potential energy from wave-induced isopycnal displacements. It scales with N^2 eta^2 where eta is the vertical displacement.","category":"section"},{"location":"guide/diagnostics/#Wave-Correction-Energy-(WCE)","page":"Diagnostics","title":"Wave Correction Energy (WCE)","text":"The YBJ+ formulation includes a higher-order correction term:\n\ntextWCE = frac12 sum_k_x k_y z frack_h^48 a_ell^2 left( A_R^2 + A_I^2 right)\n\nPhysical interpretation: WCE is a higher-order correction from the YBJ+ equation that accounts for horizontal wave dispersion. It becomes important for short horizontal wavelengths.","category":"section"},{"location":"guide/diagnostics/#Mean-Flow-Kinetic-Energy","page":"Diagnostics","title":"Mean Flow Kinetic Energy","text":"The balanced flow kinetic energy is computed from the geostrophic velocities:\n\ntextKE_flow = frac12 sum_k_x k_y z left( u_k^2 + v_k^2 right) - frac12 u(k_h=0)^2\n\nwhere the velocities are derived from the streamfunction:\n\nu = -fracpartial psipartial y = -ik_y hatpsi quad v = fracpartial psipartial x = ik_x hatpsi\n\nThis gives:\n\nu^2 + v^2 = k_h^2 hatpsi^2\n\nPhysical interpretation: textKE_flow represents the kinetic energy of the large-scale quasi-geostrophic eddies and jets.","category":"section"},{"location":"guide/diagnostics/#Mean-Flow-Potential-Energy","page":"Diagnostics","title":"Mean Flow Potential Energy","text":"The available potential energy from buoyancy:\n\ntextPE_flow = frac12 sum_k_x k_y z fracf_0^2N^2 b_k^2\n\nwhere buoyancy b is related to the streamfunction via thermal wind balance:\n\nb = fracpartial psipartial z\n\nPhysical interpretation: textPE_flow represents the energy stored in tilted isopycnals (density surfaces). It can be released through baroclinic instability.","category":"section"},{"location":"guide/diagnostics/#Total-Energy-Conservation","page":"Diagnostics","title":"Total Energy Conservation","text":"In the inviscid limit, the total energy is conserved:\n\nE_total = underbracetextKE_flow + textPE_flow_textMean flow + underbracetextWKE + textWPE + textWCE_textWaves = textconst\n\nEnergy exchange between waves and mean flow occurs via:\n\nRefraction: Waves gain/lose energy from vorticity gradients\nWave feedback q^w: Waves modify the effective PV","category":"section"},{"location":"guide/diagnostics/#Using-the-EnergyDiagnosticsManager","page":"Diagnostics","title":"Using the EnergyDiagnosticsManager","text":"The energy diagnostics manager is automatically created during simulation setup:\n\n# Energy diagnostics are computed and saved automatically during simulation\nsim = setup_simulation(config)\nrun_simulation!(sim)\n\n# After simulation, files are in:\n# output_dir/diagnostic/wave_KE.nc\n# output_dir/diagnostic/wave_PE.nc\n# etc.\n\nFor manual control:\n\nusing QGYBJplus\n\n# Create manager manually\nenergy_manager = EnergyDiagnosticsManager(\n    \"output_dir\";\n    output_interval=1.0  # Time between outputs\n)\n\n# Record energies at each diagnostic time\nrecord_energies!(\n    energy_manager,\n    current_time,\n    wave_KE, wave_PE, wave_CE,\n    mean_flow_KE, mean_flow_PE\n)\n\n# Write all files at end\nwrite_all_energy_files!(energy_manager)","category":"section"},{"location":"guide/diagnostics/#Reading-Energy-Output-Files","page":"Diagnostics","title":"Reading Energy Output Files","text":"using NCDatasets\n\n# Read wave KE time series\nds = NCDataset(\"output_dir/diagnostic/wave_KE.nc\", \"r\")\ntime = ds[\"time\"][:]\nwave_KE = ds[\"wave_KE\"][:]\nclose(ds)\n\n# Read total energy summary\nds = NCDataset(\"output_dir/diagnostic/total_energy.nc\", \"r\")\ntime = ds[\"time\"][:]\ntotal_wave = ds[\"total_wave_energy\"][:]\ntotal_flow = ds[\"total_flow_energy\"][:]\ntotal = ds[\"total_energy\"][:]\nclose(ds)\n\n# Plot energy evolution\nusing Plots\nplot(time, total, label=\"Total\", linewidth=2)\nplot!(time, total_flow, label=\"Mean flow\", linestyle=:dash)\nplot!(time, total_wave, label=\"Waves\", linestyle=:dot)\nxlabel!(\"Time\")\nylabel!(\"Energy\")","category":"section"},{"location":"guide/diagnostics/#Energy-Budget-Verification","page":"Diagnostics","title":"Energy Budget Verification","text":"Check energy conservation:\n\n# After simulation\nds = NCDataset(\"output_dir/diagnostic/total_energy.nc\", \"r\")\nE = ds[\"total_energy\"][:]\nclose(ds)\n\n# Relative change\ndE_rel = (E[end] - E[1]) / E[1]\nprintln(\"Relative energy change: $(dE_rel)\")\n\nif abs(dE_rel) < 1e-6\n    println(\"Energy well conserved\")\nelse\n    println(\"Check time step or dissipation settings\")\nend","category":"section"},{"location":"guide/diagnostics/#MPI-Aware-Energy-Functions","page":"Diagnostics","title":"MPI-Aware Energy Functions","text":"For parallel simulations, use the global reduction versions:\n\n# Physical-space energy with MPI reduction\nKE = flow_kinetic_energy_global(state.u, state.v, mpi_config)\nWE_B, WE_A = wave_energy_global(state.B, state.A, mpi_config)\n\n# Spectral energy with MPI reduction\nKE_spectral = flow_kinetic_energy_spectral_global(uk, vk, grid, params; mpi_config=mpi_config)\nPE_spectral = flow_potential_energy_spectral_global(bk, grid, params; mpi_config=mpi_config)\nWKE, WPE, WCE = wave_energy_spectral_global(BR, BI, AR, AI, CR, CI, grid, params; mpi_config=mpi_config)","category":"section"},{"location":"guide/diagnostics/#Wave-Diagnostics","page":"Diagnostics","title":"Wave Diagnostics","text":"","category":"section"},{"location":"guide/diagnostics/#Wave-Amplitude","page":"Diagnostics","title":"Wave Amplitude","text":"# |A|² field\nA2 = abs2.(state.A)\n\n# Maximum amplitude\nA_max = maximum(sqrt.(A2))\n\n# Volume-averaged amplitude\nusing Statistics\nA_rms = sqrt(mean(A2))","category":"section"},{"location":"guide/diagnostics/#Wave-Velocities","page":"Diagnostics","title":"Wave Velocities","text":"Compute wave-induced velocities (in-place):\n\n# Updates state.u, state.v with wave velocities\ncompute_wave_velocities!(state, grid; plans=plans, params=params, compute_w=true)","category":"section"},{"location":"guide/diagnostics/#Omega-Equation","page":"Diagnostics","title":"Omega Equation","text":"The omega equation computes ageostrophic vertical velocity:\n\nnabla^2 w + fracf_0^2N^2fracpartial^2 wpartial z^2 = frac2f_0N^2Jleft(fracpartialpsipartial z nabla^2psiright)\n\nUse omega_eqn_rhs! to compute the right-hand side:\n\n# Compute omega equation RHS\nomega_eqn_rhs!(rhs, state.psi, grid, params, plans)","category":"section"},{"location":"guide/diagnostics/#Time-Series-Analysis","page":"Diagnostics","title":"Time Series Analysis","text":"","category":"section"},{"location":"guide/diagnostics/#Recording-Diagnostics-Manually","page":"Diagnostics","title":"Recording Diagnostics Manually","text":"# Initialize storage arrays\ntime_series = Float64[]\nKE_series = Float64[]\nWKE_series = Float64[]\n\nfor step = 1:nsteps\n    # ... time stepping code ...\n\n    # Record diagnostics\n    push!(time_series, step * dt)\n    push!(KE_series, flow_kinetic_energy(state.u, state.v))\n    WKE, WPE, WCE = compute_detailed_wave_energy(state, grid, params)\n    push!(WKE_series, WKE)\nend","category":"section"},{"location":"guide/diagnostics/#Energy-Conservation-Check","page":"Diagnostics","title":"Energy Conservation Check","text":"# Total energy should be conserved (inviscid)\nE_total = KE_series .+ WKE_series\n\n# Check conservation\ndE = (E_total[end] - E_total[1]) / E_total[1]\nprintln(\"Relative energy change: $dE\")\n\nif abs(dE) > 1e-6\n    @warn \"Energy not well conserved!\"\nend","category":"section"},{"location":"guide/diagnostics/#Diagnostic-Output-Example","page":"Diagnostics","title":"Diagnostic Output Example","text":"function compute_diagnostics(state, grid, params)\n    diag = Dict{String, Any}()\n\n    # Energy\n    diag[\"KE\"] = flow_kinetic_energy(state.u, state.v)\n    diag[\"WKE\"], diag[\"WPE\"], diag[\"WCE\"] = compute_detailed_wave_energy(state, grid, params)\n    diag[\"WE_B\"], diag[\"WE_A\"] = wave_energy(state.B, state.A)\n\n    # Extrema\n    diag[\"A_max\"] = maximum(abs.(state.A))\n    diag[\"psi_max\"] = maximum(abs.(state.psi))\n\n    return diag\nend\n\nfunction print_diagnostics(diag, step, time)\n    println(\"=\" ^ 60)\n    println(\"Step: $step, Time: $(round(time, digits=4))\")\n    println(\"-\" ^ 60)\n    println(\"  KE = $(round(diag[\"KE\"], sigdigits=6))\")\n    println(\"  WKE = $(round(diag[\"WKE\"], sigdigits=6))\")\n    println(\"  |A|_max = $(round(diag[\"A_max\"], sigdigits=4))\")\n    println(\"=\" ^ 60)\nend","category":"section"},{"location":"guide/diagnostics/#API-Reference","page":"Diagnostics","title":"API Reference","text":"See the Physics API Reference for complete documentation of diagnostic functions:\n\nflow_kinetic_energy - Mean flow kinetic energy\nflow_kinetic_energy_spectral - Spectral kinetic energy with dealiasing\nflow_potential_energy_spectral - Spectral potential energy\nwave_energy - Basic wave energy from B and A fields\nwave_energy_spectral - Spectral wave energy components\ncompute_detailed_wave_energy - Detailed WKE, WPE, WCE computation\ncompute_wave_energy - Simple wave energy computation\nflow_kinetic_energy_global / wave_energy_global - MPI-aware global reductions\nomega_eqn_rhs! - Omega equation RHS computation\nEnergyDiagnosticsManager - Automatic energy output to separate files","category":"section"},{"location":"physics/ybj_plus/#ybj-plus","page":"YBJ+ Wave Model","title":"YBJ+ Wave Model","text":"This page describes the Young-Ben Jelloul Plus (YBJ+) formulation for near-inertial wave evolution.","category":"section"},{"location":"physics/ybj_plus/#Near-Inertial-Waves","page":"YBJ+ Wave Model","title":"Near-Inertial Waves","text":"","category":"section"},{"location":"physics/ybj_plus/#Physical-Background","page":"YBJ+ Wave Model","title":"Physical Background","text":"Near-inertial waves (NIWs) are internal gravity waves with frequencies close to the local Coriolis frequency f. They are:\n\nWind-generated: Strong winds (storms, tropical cyclones) inject NIW energy\nUbiquitous: Found throughout the world's oceans\nImportant for mixing: NIWs break and drive turbulent mixing","category":"section"},{"location":"physics/ybj_plus/#Wave-Amplitude-Representation","page":"YBJ+ Wave Model","title":"Wave Amplitude Representation","text":"The NIW velocity field is written as:\n\nmathbfu_wave = textReleft A(xyzt)  e^-if_0 t  hatmathbfz times nabla_h right + textcc\n\nwhere A is the slowly-varying complex wave amplitude.","category":"section"},{"location":"physics/ybj_plus/#The-YBJ-Equation","page":"YBJ+ Wave Model","title":"The YBJ+ Equation","text":"","category":"section"},{"location":"physics/ybj_plus/#Evolution-Equation","page":"YBJ+ Wave Model","title":"Evolution Equation","text":"The wave envelope B = L^+ A evolves according to:\n\nfracpartial Bpartial t + J(psi B) = ifrack_h^22 cdot Bu cdot Ro A + frac12B times zeta + mathcalD_B\n\nnote: Sign convention\nThe sign in the dispersion term depends on the phase convention for the carrier wave (e.g., e^-i f_0 t vs e^+i f_0 t). QGYBJ+.jl follows the e^-i f_0 t convention, yielding the +i sign shown here.\n\nwhere:\n\nB = L^+ A: Evolved wave envelope\nzeta = nabla^2psi: Relative vorticity\nJ(psi B): Advection by geostrophic flow\n(12)B times zeta: Refraction term (wave focusing by vorticity)\ni k_h^2(2 cdot Bu cdot Ro) A: Dispersion (nondimensional form of i N^2 k_h^2(2f_0) A)","category":"section"},{"location":"physics/ybj_plus/#Real/Imaginary-Decomposition","page":"YBJ+ Wave Model","title":"Real/Imaginary Decomposition","text":"Writing B = B_R + i B_I and A = A_R + i A_I, the equations become:\n\nfracpartial B_Rpartial t = -J(psi B_R) - frack_h^22 cdot Bu cdot Ro A_I + frac12 B_I times zeta - mathcalD_BR\n\nfracpartial B_Ipartial t = -J(psi B_I) + frack_h^22 cdot Bu cdot Ro A_R - frac12 B_R times zeta - mathcalD_BI","category":"section"},{"location":"physics/ybj_plus/#Physical-Terms","page":"YBJ+ Wave Model","title":"Physical Terms","text":"Term Physics Effect\nJ(psi B) Advection Waves carried by eddies\n(12)B times zeta Refraction Focusing in anticyclones\nk_h^2 A(2 cdot Bu cdot Ro) Dispersion Horizontal spreading\nmathcalD_B Dissipation Energy loss (hyperdiffusion)","category":"section"},{"location":"physics/ybj_plus/#The-L-Operator","page":"YBJ+ Wave Model","title":"The L⁺ Operator","text":"","category":"section"},{"location":"physics/ybj_plus/#Definition","page":"YBJ+ Wave Model","title":"Definition","text":"The YBJ+ operator relates B and A:\n\nB = L^+ A = fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright) - frack_h^24A","category":"section"},{"location":"physics/ybj_plus/#Inversion:-B-A","page":"YBJ+ Wave Model","title":"Inversion: B → A","text":"To recover A from B, we solve:\n\nfracpartialpartial zleft(a(z)fracpartial Apartial zright) - frack_h^24A = B\n\nwhere a(z) = f_0^2N^2(z).","category":"section"},{"location":"physics/ybj_plus/#Tridiagonal-System","page":"YBJ+ Wave Model","title":"Tridiagonal System","text":"In discretized form for each (k_x k_y):\n\na_k A_k-1 + b_k A_k + c_k A_k+1 = B_k\n\nwith:\n\na_k = a(z_k-12)Delta z^2\nc_k = a(z_k+12)Delta z^2\nb_k = -(a_k + c_k) - k_h^24","category":"section"},{"location":"physics/ybj_plus/#Boundary-Conditions","page":"YBJ+ Wave Model","title":"Boundary Conditions","text":"Neumann: fracpartial Apartial z = 0 at z = -H 0","category":"section"},{"location":"physics/ybj_plus/#Wave-Refraction","page":"YBJ+ Wave Model","title":"Wave Refraction","text":"","category":"section"},{"location":"physics/ybj_plus/#Mechanism","page":"YBJ+ Wave Model","title":"Mechanism","text":"Anticyclones (negative vorticity) trap waves:\n\nEffective frequency: f_eff = f_0 + zeta2\nIn anticyclones: zeta  0 Rightarrow f_eff  f_0\nWaves propagate toward regions of lower effective frequency","category":"section"},{"location":"physics/ybj_plus/#Mathematical-Form","page":"YBJ+ Wave Model","title":"Mathematical Form","text":"The refraction term in the YBJ+ model:\n\ntextRefraction = frac12 B times zeta = frac12 B times nabla^2psi\n\nIn terms of real/imaginary parts:\n\nr_BR = frac12 B_I times zeta contributes to partial B_Rpartial t\nr_BI = -frac12 B_R times zeta contributes to partial B_Ipartial t\n\nThis term represents focusing of wave energy by the background vorticity field.","category":"section"},{"location":"physics/ybj_plus/#Code-Implementation","page":"YBJ+ Wave Model","title":"Code Implementation","text":"# Compute refraction term: (1/2) * B × ζ where ζ = -kh²ψ (complex B form)\nrefraction_waqg_B!(rBk, Bk, psik, grid, plans; Lmask=L)","category":"section"},{"location":"physics/ybj_plus/#YBJ-vs-YBJ","page":"YBJ+ Wave Model","title":"YBJ vs YBJ+","text":"","category":"section"},{"location":"physics/ybj_plus/#Original-YBJ-(1997)","page":"YBJ+ Wave Model","title":"Original YBJ (1997)","text":"B = fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright)\n\nSimpler relation between B and A\nRecovery via vertical integration","category":"section"},{"location":"physics/ybj_plus/#YBJ-(Asselin-and-Young-2019)","page":"YBJ+ Wave Model","title":"YBJ+ (Asselin & Young 2019)","text":"B = fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright) - frack_h^24A\n\nIncludes horizontal wavenumber dependence\nMore accurate for high k_h modes\nRequires elliptic inversion (not just integration)","category":"section"},{"location":"physics/ybj_plus/#When-to-Use-Which","page":"YBJ+ Wave Model","title":"When to Use Which","text":"Scenario Recommendation\nLow-resolution Normal YBJ is adequate\nHigh-resolution YBJ+ more accurate\nLarge-scale waves Either works\nSmall-scale waves YBJ+ essential\n\nControl in code:\n\nparams = QGParams(; ybj_plus=true)  # Use YBJ+ (default)\nparams = QGParams(; ybj_plus=false) # Use normal YBJ","category":"section"},{"location":"physics/ybj_plus/#Dispersion-Relation","page":"YBJ+ Wave Model","title":"Dispersion Relation","text":"","category":"section"},{"location":"physics/ybj_plus/#In-the-YBJ-Framework","page":"YBJ+ Wave Model","title":"In the YBJ+ Framework","text":"The dispersion relation for NIWs:\n\nomega = f_0 + fracN^2 k_h^22f_0 m^2\n\nwhere m is the vertical wavenumber.","category":"section"},{"location":"physics/ybj_plus/#Physical-Implications","page":"YBJ+ Wave Model","title":"Physical Implications","text":"Frequency slightly above f_0\nHigher k_h → faster frequency\nLower m (longer vertical scale) → faster frequency","category":"section"},{"location":"physics/ybj_plus/#Wave-Energy","page":"YBJ+ Wave Model","title":"Wave Energy","text":"","category":"section"},{"location":"physics/ybj_plus/#Wave-Kinetic-Energy-(Equation-4.7)","page":"YBJ+ Wave Model","title":"Wave Kinetic Energy (Equation 4.7)","text":"The wave kinetic energy (WKE) is defined per YBJ+ equation (4.7):\n\ntextWKE = frac12 int LA^2  dV\n\nwhere L is the vertical operator from equation (1.3):\n\nL = partial_z left( fracf_0^2N^2 partial_z right)\n\nLA is computed directly by applying the L operator to A:\n\nLA = partial_z left( a(z) times C right)\n\nwhere a(z) = f_0^2N^2 and C = partial Apartial z.","category":"section"},{"location":"physics/ybj_plus/#Computation","page":"YBJ+ Wave Model","title":"Computation","text":"# Detailed wave energy components (WKE, WPE, WCE)\nWKE, WPE, WCE = compute_detailed_wave_energy(state, grid, params)\n\n# Simple wave energy (returns WKE)\nWE = compute_wave_energy(state, grid, plans; params=params)\n\nnote: Physical interpretation\nWKE represents the kinetic energy of the near-inertial wave field, computed by applying the L operator directly to the wave amplitude A. This matches the YBJ+ paper's definition in equation (4.7).","category":"section"},{"location":"physics/ybj_plus/#Implementation-Details","page":"YBJ+ Wave Model","title":"Implementation Details","text":"","category":"section"},{"location":"physics/ybj_plus/#Key-Functions","page":"YBJ+ Wave Model","title":"Key Functions","text":"The YBJ+ implementation uses these core functions:\n\ninvert_B_to_A! - Solve L⁺ operator for wave amplitude A from envelope B\nrefraction_waqg_B! - Compute wave refraction by vorticity (complex B)\nconvol_waqg_B! - Compute wave advection by geostrophic flow (complex B)\n\nSee the Physics API Reference for detailed documentation.","category":"section"},{"location":"physics/ybj_plus/#Code-Locations","page":"YBJ+ Wave Model","title":"Code Locations","text":"elliptic.jl: B → A inversion (invert_B_to_A!)\nnonlinear.jl: Refraction (refraction_waqg_B!), Advection (convol_waqg_B!)\nybj_normal.jl: Normal YBJ (non-plus) operators","category":"section"},{"location":"physics/ybj_plus/#References","page":"YBJ+ Wave Model","title":"References","text":"Young, W. R., & Ben Jelloul, M. (1997). Propagation of near-inertial oscillations through a geostrophic flow. J. Mar. Res., 55, 735-766.\nAsselin, O., & Young, W. R. (2019). Penetration of wind-generated near-inertial waves into a turbulent ocean. J. Phys. Oceanogr., 49, 1699-1717.","category":"section"},{"location":"concepts/#concepts","page":"Key Concepts","title":"Key Concepts","text":"Core concepts for understanding QGYBJ+.jl — no code, just ideas.\n\n","category":"section"},{"location":"concepts/#What-We-Simulate","page":"Key Concepts","title":"What We Simulate","text":"The ocean has two interacting components at very different scales:\n\n<div class=\"feature-grid\">\n<div class=\"feature-card\">\n    <h3>Mesoscale Eddies</h3>\n    <p><strong>Scale:</strong> ~100 km<br>\n    <strong>Timescale:</strong> Weeks to months<br>\n    <strong>Description:</strong> Slow spinning vortices that contain most of the ocean's kinetic energy</p>\n</div>\n<div class=\"feature-card\">\n    <h3>Near-Inertial Waves</h3>\n    <p><strong>Scale:</strong> ~10 km<br>\n    <strong>Timescale:</strong> ~17 hours<br>\n    <strong>Description:</strong> Fast oscillations driven by wind, crucial for ocean mixing</p>\n</div>\n</div>\n\nQGYBJ+.jl simulates both components and their interactions: eddies refract waves, and waves feed energy back to the eddies.\n\n","category":"section"},{"location":"concepts/#The-Two-Main-Variables","page":"Key Concepts","title":"The Two Main Variables","text":"","category":"section"},{"location":"concepts/#Streamfunction-(ψ)-—-Eddies","page":"Key Concepts","title":"Streamfunction (ψ) — Eddies","text":"The streamfunction describes the balanced (geostrophic) eddy flow:\n\nHigh ψ = anticyclone (clockwise in Northern Hemisphere)\nLow ψ = cyclone (counter-clockwise in Northern Hemisphere)\nVelocities derived as: u = -∂ψ/∂y, v = ∂ψ/∂x\nVorticity: ζ = ∇²ψ (positive = cyclonic, negative = anticyclonic)","category":"section"},{"location":"concepts/#Wave-Envelope-(B)-—-Waves","page":"Key Concepts","title":"Wave Envelope (B) — Waves","text":"The wave envelope captures wave energy without tracking fast oscillations:\n\nComplex-valued: B = Bᵣ + i·Bᵢ\nMagnitude |B| represents wave amplitude\nPhase arg(B) represents wave phase\nEvolves on the slow (eddy) timescale\n\n","category":"section"},{"location":"concepts/#Wave-Eddy-Interaction","page":"Key Concepts","title":"Wave-Eddy Interaction","text":"Three key processes govern how waves and eddies interact:\n\nProcess What Happens Physical Effect\nAdvection J(ψ, B) Waves are carried by the eddy velocity field\nRefraction ½ζB Waves bend toward regions of negative vorticity\nDispersion ik²A Waves spread horizontally over time\n\ntip: Wave Trapping\nThe effective wave frequency is f_eff = f₀ + ζ/2. In anticyclones where ζ < 0, waves slow down and get trapped — this is a key mechanism for wave energy concentration.\n\n","category":"section"},{"location":"concepts/#B-vs-A:-Why-Two-Wave-Variables?","page":"Key Concepts","title":"B vs A: Why Two Wave Variables?","text":"We evolve B (mathematically convenient) but diagnose A (physically meaningful):\n\nB = L^+(A) = fracpartialpartial zleftfracf_0^2N^2fracpartial Apartial zright - frack^24A\n\nVariable Role Why We Need It\nB Prognostic (evolved) Simpler time-stepping equations\nA Diagnostic (computed) Represents physical wave amplitude\n\n","category":"section"},{"location":"concepts/#Coordinate-System","page":"Key Concepts","title":"Coordinate System","text":"","category":"section"},{"location":"concepts/#Spatial-Coordinates","page":"Key Concepts","title":"Spatial Coordinates","text":"Horizontal: x (east), y (north) — doubly periodic domain\nVertical: z = 0 at surface, z = -Lz at bottom","category":"section"},{"location":"concepts/#Spectral-vs-Physical-Space","page":"Key Concepts","title":"Spectral vs Physical Space","text":"Derivatives computed in spectral space (fast, accurate)\nNonlinear products computed in physical space (avoid aliasing)\nTransform between spaces using FFT\n\n","category":"section"},{"location":"concepts/#Time-Stepping-Options","page":"Key Concepts","title":"Time Stepping Options","text":"Method Speed Best For How It Works\nLeapfrog Standard General use Explicit, simple, stable\nIMEX-CN 10× faster Wave-dominated Treats fast dispersion implicitly\n\nnote: Choosing a Method\nUse IMEX-CN when wave dispersion limits your timestep. Leapfrog is simpler and sufficient when eddies dominate.\n\n","category":"section"},{"location":"concepts/#Quick-Glossary","page":"Key Concepts","title":"Quick Glossary","text":"Symbol Name Meaning\nψ Streamfunction Describes eddy flow\nq Potential vorticity Conserved quantity for eddies\nB Wave envelope Evolved wave variable\nA Wave amplitude Physical wave amplitude\nζ Relative vorticity ∇²ψ, measures rotation\nf₀ Coriolis parameter Earth's rotation effect\nN Buoyancy frequency Stratification strength\nLx, Ly Domain size Horizontal extent\nLz Domain depth Vertical extent\n\n","category":"section"},{"location":"concepts/#Next-Steps","page":"Key Concepts","title":"Next Steps","text":"<div class=\"learning-path\">\n<div class=\"path-step\">\n    <div class=\"step-number\">→</div>\n    <div class=\"step-content\">\n        <strong><a href=\"../quickstart/\">Quick Start</a></strong> — Run your first simulation\n    </div>\n</div>\n<div class=\"path-step\">\n    <div class=\"step-number\">→</div>\n    <div class=\"step-content\">\n        <strong><a href=\"../physics/overview/\">Physics Overview</a></strong> — See the full equations\n    </div>\n</div>\n</div>","category":"section"},{"location":"advanced/parallel_particles/#parallel-particles","page":"Parallel Particle Algorithm","title":"Parallel Particle Algorithm","text":"This page provides detailed technical documentation of the parallel particle advection algorithm in QGYBJ+.jl.","category":"section"},{"location":"advanced/parallel_particles/#Overview","page":"Parallel Particle Algorithm","title":"Overview","text":"The parallel particle algorithm enables efficient Lagrangian particle tracking on distributed-memory systems using MPI. Key features:\n\n2D domain decomposition in x and y (px × py topology)\nHalo exchange in x/y (plus corners) for cross-boundary interpolation\nAutomatic particle migration between MPI ranks\nNon-blocking MPI communication for efficiency\nLoad balancing as particles redistribute","category":"section"},{"location":"advanced/parallel_particles/#Domain-Decomposition","page":"Parallel Particle Algorithm","title":"Domain Decomposition","text":"","category":"section"},{"location":"advanced/parallel_particles/#2D-Tile-Decomposition","page":"Parallel Particle Algorithm","title":"2D Tile Decomposition","text":"The physical domain [0, Lx] × [0, Ly] × [-Lz, 0] is partitioned into tiles across x and y according to the MPI process grid (px × py). Each rank owns a contiguous tile in x/y and the full z-range.\n\nExample for a 2×2 topology:\n\n┌─────────────────────────┬─────────────────────────┐\n│ Rank (0,1)               │ Rank (1,1)              │\n│ x∈[0, Lx/2), y∈[Ly/2, Ly) │ x∈[Lx/2, Lx), y∈[Ly/2, Ly) │\n├─────────────────────────┼─────────────────────────┤\n│ Rank (0,0)               │ Rank (1,0)              │\n│ x∈[0, Lx/2), y∈[0, Ly/2)  │ x∈[Lx/2, Lx), y∈[0, Ly/2)  │\n└─────────────────────────┴─────────────────────────┘\n\nEach rank owns contiguous x and y ranges\nFull z dimension on each rank\nParticles belong to the rank containing their (x, y) position","category":"section"},{"location":"advanced/parallel_particles/#Local-Domain-Calculation","page":"Parallel Particle Algorithm","title":"Local Domain Calculation","text":"function compute_local_domain(grid::Grid, rank::Int, nprocs::Int; topology=nothing)\n    # Determine process grid (px × py)\n    px, py = if topology !== nothing\n        topology\n    elseif grid.decomp !== nothing && hasfield(typeof(grid.decomp), :topology)\n        grid.decomp.topology\n    else\n        (nprocs, 1)\n    end\n\n    rank_x = rank % px\n    rank_y = rank ÷ px\n\n    nx_local = compute_local_size(grid.nx, px, rank_x)\n    ny_local = compute_local_size(grid.ny, py, rank_y)\n\n    x_start = compute_start_index(grid.nx, px, rank_x)\n    y_start = compute_start_index(grid.ny, py, rank_y)\n\n    dx = grid.Lx / grid.nx\n    dy = grid.Ly / grid.ny\n\n    x_start_phys = x_start * dx\n    x_end_phys = (x_start + nx_local) * dx\n    y_start_phys = y_start * dy\n    y_end_phys = (y_start + ny_local) * dy\n\n    return (\n        x_start = x_start_phys,\n        x_end = x_end_phys,\n        y_start = y_start_phys,\n        y_end = y_end_phys,\n        z_start = -grid.Lz,\n        z_end = 0.0,\n        nx_local = nx_local,\n        ny_local = ny_local,\n        px = px,\n        py = py,\n        rank_x = rank_x,\n        rank_y = rank_y\n    )\nend\n\nExample: 256×256 grid points, topology (2,2) → local 128×128 tiles per rank.","category":"section"},{"location":"advanced/parallel_particles/#Halo-Exchange","page":"Parallel Particle Algorithm","title":"Halo Exchange","text":"","category":"section"},{"location":"advanced/parallel_particles/#Purpose","page":"Parallel Particle Algorithm","title":"Purpose","text":"When a particle is near a domain boundary, velocity interpolation requires data from the neighboring rank. Halo regions (ghost cells) store copies of neighbor data.","category":"section"},{"location":"advanced/parallel_particles/#Halo-Width-Requirements","page":"Parallel Particle Algorithm","title":"Halo Width Requirements","text":"The halo width is automatically determined by the interpolation method:\n\nInterpolation Stencil Halo Width Accuracy\nTRILINEAR 2×2×2 1 cell O(h²)\nTRICUBIC 4×4×4 2 cells O(h⁴)\nQUINTIC 6×6×6 3 cells O(h⁶)\nADAPTIVE varies 3 cells varies\n\nThe required_halo_width() function computes this automatically:\n\nusing QGYBJplus: required_halo_width, TRILINEAR, TRICUBIC, QUINTIC\n\nrequired_halo_width(TRILINEAR)  # → 1\nrequired_halo_width(TRICUBIC)   # → 2\nrequired_halo_width(QUINTIC)    # → 3","category":"section"},{"location":"advanced/parallel_particles/#Extended-Array-Structure","page":"Parallel Particle Algorithm","title":"Extended Array Structure","text":"┌─────────────────────────────────────────────────────────────┐\n│            EXTENDED ARRAY LAYOUT (local + halos)            │\n│                                                             │\n│   y (north)                                                  │\n│      ▲                                                      │\n│      │   ┌───────────────────────────────┐                  │\n│      │   │           top halo           │                  │\n│      │   ├───────────┬───────────┬───────┤                  │\n│      │   │ left halo │   local   │ right │                  │\n│      │   │           │   data    │ halo  │                  │\n│      │   ├───────────┴───────────┴───────┤                  │\n│      │   │         bottom halo           │                  │\n│      │   └───────────────────────────────┘                  │\n│                                                             │\n│   hw = halo_width (depends on interpolation method)         │\n│   Extended size: (nz_local, nx_local + 2*hw, ny_local + 2*hw)│\n└─────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Communication-Pattern-(Periodic-Boundaries)","page":"Parallel Particle Algorithm","title":"Communication Pattern (Periodic Boundaries)","text":"For periodic domains, neighbor relationships wrap in x and y. In 2D, each rank has up to 8 neighbors:\n\n    NW(7) --- N(4) --- NE(8)\n      |        |        |\n    W(1) --- local --- E(2)\n      |        |        |\n    SW(5) --- S(3) --- SE(6)\n\nWith periodic_x/periodic_y enabled, edge neighbors wrap around (e.g., west of rankx=0 is rankx=px-1). For py==1, only W/E neighbors are used.","category":"section"},{"location":"advanced/parallel_particles/#Implementation","page":"Parallel Particle Algorithm","title":"Implementation","text":"function exchange_velocity_halos!(halo_info, u_field, v_field, w_field)\n    # 1. Copy local data to center of extended arrays\n    copy_local_to_extended!(halo_info, u_field, v_field, w_field)\n\n    # 2. Pack boundary data into send buffers (W/E/S/N and corners)\n    #    For py==1, only W/E buffers are used.\n\n    # 3. Post non-blocking receives from all neighbors (up to 8)\n\n    # 4. Send to neighbors (non-blocking)\n\n    # 5. Wait for receives and unpack into halo regions\n    MPI.Waitall(recv_reqs)\n\n    # 6. Wait for sends to complete\n    MPI.Waitall(send_reqs)\nend","category":"section"},{"location":"advanced/parallel_particles/#Buffer-Layout","page":"Parallel Particle Algorithm","title":"Buffer Layout","text":"Each buffer contains packed velocity components:\n\nBuffer layout: [u₁, v₁, w₁, u₂, v₂, w₂, ..., uₙ, vₙ, wₙ]\n\nwhere n depends on the buffer type:\n- X-direction buffers: halo_width × ny_local × nz_local\n- Y-direction buffers: nx_local × halo_width × nz_local\n- Corner buffers: halo_width × halo_width × nz_local","category":"section"},{"location":"advanced/parallel_particles/#Particle-Migration","page":"Parallel Particle Algorithm","title":"Particle Migration","text":"","category":"section"},{"location":"advanced/parallel_particles/#When-Migration-Occurs","page":"Parallel Particle Algorithm","title":"When Migration Occurs","text":"After advection, particles may have moved outside their owning rank's domain:\n\n┌────────────────────────────────────────────────────────────────────────┐\n│                     PARTICLE CROSSING BOUNDARY                         │\n│                                                                        │\n│   Before advection:                                                    │\n│   ┌───────────────────────┬───────────────────────┐                    │\n│   │       RANK 0          │       RANK 1          │                    │\n│   │                    •  │                       │                    │\n│   │                   ↗   │                       │                    │\n│   │     Particle moving   │                       │                    │\n│   │     toward boundary   │                       │                    │\n│   └───────────────────────┴───────────────────────┘                    │\n│                                                                        │\n│   After advection:                                                     │\n│   ┌───────────────────────┬───────────────────────┐                    │\n│   │       RANK 0          │       RANK 1          │                    │\n│   │                       │  •                    │                    │\n│   │                       │  ↑ Particle now in    │                    │\n│   │                       │    Rank 1's domain    │                    │\n│   └───────────────────────┴───────────────────────┘                    │\n│                                                                        │\n│   → Particle must be migrated from Rank 0 to Rank 1                    │\n└────────────────────────────────────────────────────────────────────────┘\n\nThe same logic applies across y-boundaries when py > 1.","category":"section"},{"location":"advanced/parallel_particles/#Migration-Algorithm","page":"Parallel Particle Algorithm","title":"Migration Algorithm","text":"function migrate_particles!(tracker)\n    particles = tracker.particles\n    local_domain = tracker.local_domain\n\n    # 1. Clear send buffers\n    for buf in tracker.send_buffers\n        empty!(buf)\n    end\n\n    # 2. Identify particles to keep vs migrate\n    keep_indices = Int[]\n\n    for i in 1:particles.np\n        x = particles.x[i]\n        y = particles.y[i]\n        target_rank = find_target_rank(x, y, tracker)\n\n        if target_rank == tracker.rank\n            # Particle stays local\n            push!(keep_indices, i)\n        else\n            # Package particle for migration: [x, y, z, u, v, w]\n            particle_data = [\n                particles.x[i], particles.y[i], particles.z[i],\n                particles.u[i], particles.v[i], particles.w[i]\n            ]\n            append!(tracker.send_buffers[target_rank + 1], particle_data)\n        end\n    end\n\n    # 3. Remove migrated particles from local arrays\n    particles.x = particles.x[keep_indices]\n    particles.y = particles.y[keep_indices]\n    # ... same for z, u, v, w\n    particles.np = length(keep_indices)\n\n    # 4. Exchange particle data via MPI\n    exchange_particles!(tracker)\n\n    # 5. Add received particles to local collection\n    add_received_particles!(tracker)\nend\n\nfunction find_target_rank(x, y, tracker)\n    # Handle periodic boundaries\n    x_periodic = tracker.config.periodic_x ? mod(x, tracker.Lx) : x\n    y_periodic = tracker.config.periodic_y ? mod(y, tracker.Ly) : y\n\n    # Convert to grid indices (0-based)\n    ix = floor(Int, x_periodic / tracker.dx)\n    iy = floor(Int, y_periodic / tracker.dy)\n    ix = min(ix, tracker.nx - 1)\n    iy = min(iy, tracker.ny - 1)\n\n    # Determine process grid (px × py)\n    px, py = tracker.local_domain === nothing ?\n             compute_process_grid(tracker.nprocs) :\n             (tracker.local_domain.px, tracker.local_domain.py)\n\n    # Map indices to rank coordinates (handles uneven division)\n    rank_x = _rank_for_index(ix, tracker.nx, px)\n    rank_y = _rank_for_index(iy, tracker.ny, py)\n\n    return rank_y * px + rank_x\nend","category":"section"},{"location":"advanced/parallel_particles/#All-to-All-Communication","page":"Parallel Particle Algorithm","title":"All-to-All Communication","text":"function exchange_particles!(tracker)\n    comm = tracker.comm\n    nprocs = tracker.nprocs\n\n    # 1. Exchange particle counts (how many to send to each rank)\n    send_counts = [length(tracker.send_buffers[i]) ÷ 6 for i in 1:nprocs]\n    recv_counts = MPI.Alltoall(send_counts, comm)\n\n    # 2. Point-to-point sends/receives for particle data\n    for other_rank in 0:nprocs-1\n        if other_rank == tracker.rank\n            continue\n        end\n\n        # Send to other_rank\n        if !isempty(tracker.send_buffers[other_rank + 1])\n            MPI.Send(tracker.send_buffers[other_rank + 1], other_rank, tag=0, comm)\n        end\n\n        # Receive from other_rank\n        if recv_counts[other_rank + 1] > 0\n            n_values = recv_counts[other_rank + 1] * 6\n            recv_data = Vector{T}(undef, n_values)\n            MPI.Recv!(recv_data, other_rank, tag=0, comm)\n            tracker.recv_buffers[other_rank + 1] = recv_data\n        end\n    end\nend","category":"section"},{"location":"advanced/parallel_particles/#Complete-Parallel-Timestep","page":"Parallel Particle Algorithm","title":"Complete Parallel Timestep","text":"┌──────────────────────────────────────────────────────────────────────────────┐\n│              PARALLEL PARTICLE ADVECTION TIMESTEP                            │\n│                                                                              │\n│  ┌────────────────────────────────────────────────────────────────────────┐  │\n│  │ STEP 1: UPDATE VELOCITY FIELDS                                         │  │\n│  │                                                                        │  │\n│  │   • Compute geostrophic velocities (distributed FFT):                  │  │\n│  │       û = -i·kᵧ·ψ̂,  v̂ = i·kₓ·ψ̂                                         │  │\n│  │                                                                        │  │\n│  │   • Solve omega equation for w (tridiagonal in z):                     │  │\n│  │       ∇²w + (f²/N²)∂²w/∂z² = (2f/N²)·J(ψ_z, ∇²ψ)                       │  │\n│  │                                                                        │  │\n│  │   • Add wave velocity + Stokes drift (full Jacobian):                  │  │\n│  │       u += Re(LA) + Im(J₀)/f₀,  v += Im(LA) - Re(J₀)/f₀               │  │\n│  │       w += -2·Im(K₀)/f₀  (Wagner & Young 2016, eq. 3.16a-3.20)        │  │\n│  │                                                                        │  │\n│  │   • Exchange velocity halos (MPI non-blocking)                         │  │\n│  └────────────────────────────────────────────────────────────────────────┘  │ \n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 2: ADVECT PARTICLES (each rank independently)              │         │\n│  │                                                                 │         │\n│  │   For each local particle:                                      │         │\n│  │     1. Interpolate velocity at (x, y, z)                        │         │\n│  │        • Use extended arrays (halos) if near boundary           │         │\n│  │        • Trilinear/Tricubic/Quintic interpolation               │         │\n│  │                                                                 │         │\n│  │     2. Time integration:                                        │         │\n│  │        • Euler:  x_{n+1} = x_n + dt·u                           │         │\n│  │        • RK2:    Midpoint method                                │         │\n│  │        • RK4:    Classical 4th order                            │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 3: MIGRATE PARTICLES                                       │         │\n│  │                                                                 │         │\n│  │   1. Identify particles outside local domain                    │         │\n│  │   2. Pack outgoing particles into send buffers                  │         │\n│  │   3. MPI.Alltoall - exchange particle counts                    │         │\n│  │   4. MPI.Send/Recv - transfer particle data                     │         │\n│  │   5. Unpack incoming particles into local arrays                │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 4: APPLY BOUNDARY CONDITIONS                               │         │\n│  │                                                                 │         │\n│  │   Horizontal (periodic):  x = mod(x, Lx),  y = mod(y, Ly)       │         │\n│  │                                                                 │         │\n│  │   Vertical (reflective):                                        │         │\n│  │     if z > 0:    z = -z,         w = -w                          │         │\n│  │     if z < -Lz:  z = -2·Lz - z, w = -w                           │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 5: SAVE TRAJECTORIES (if save_interval reached)            │         │\n│  │                                                                 │         │\n│  │   Option A: Each rank saves local particles independently       │         │\n│  │   Option B: Gather all particles to rank 0, unified output      │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n└──────────────────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Velocity-Data-Flow:-QG-Wave","page":"Parallel Particle Algorithm","title":"Velocity Data Flow: QG + Wave","text":"This section explains how particles obtain the combined QG flow and wave Stokes drift velocities in parallel mode.","category":"section"},{"location":"advanced/parallel_particles/#Overview-2","page":"Parallel Particle Algorithm","title":"Overview","text":"Particles are advected by the total velocity field:\n\nu_total = u_QG + u_wave + u_Stokes\nv_total = v_QG + v_wave + v_Stokes\nw_total = w_QG + w_Stokes\n\nwhere:\n\nQG velocities: Geostrophic flow from streamfunction ψ, vertical from omega equation\nWave velocity: Backrotated wave orbital velocity Re(LA), Im(LA) from YBJ+ equation\nStokes drift: Wave-induced drift from full Jacobian (Wagner & Young 2016)","category":"section"},{"location":"advanced/parallel_particles/#Data-Flow-Diagram","page":"Parallel Particle Algorithm","title":"Data Flow Diagram","text":"┌──────────────────────────────────────────────────────────────────────────────────┐\n│                    VELOCITY DATA FLOW FOR PARTICLE ADVECTION                      │\n│                                                                                  │\n│  ┌─────────────────────────────────────────────────────────────────────────────┐ │\n│  │ STEP 1: advect_particles!(tracker, state, grid, dt)                         │ │\n│  │                            ↓                                                │ │\n│  │         calls update_velocity_fields!(tracker, state, grid)                 │ │\n│  └─────────────────────────────────────────────────────────────────────────────┘ │\n│                                ↓                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────────┐ │\n│  │ STEP 2: compute_total_velocities!(state, grid; plans=tracker.plans, ...)    │ │\n│  │                                                                             │ │\n│  │   ┌───────────────────────────────────────────────────────────────────────┐ │ │\n│  │   │ compute_velocities!(S, G) → QG velocities                              │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   HORIZONTAL (geostrophic):                                           │ │ │\n│  │   │     û = -i·kᵧ·ψ̂   →  u_QG = -∂ψ/∂y                                    │ │ │\n│  │   │     v̂ =  i·kₓ·ψ̂   →  v_QG = +∂ψ/∂x                                    │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   VERTICAL (omega equation):                                          │ │ │\n│  │   │     ∇²w + (f²/N²)∂²w/∂z² = (2f/N²)·J(ψ_z, ∇²ψ)                        │ │ │\n│  │   │     → Tridiagonal solve per (kₓ,kᵧ) → w_QG                            │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   State.u = u_QG, State.v = v_QG, State.w = w_QG                      │ │ │\n│  │   └───────────────────────────────────────────────────────────────────────┘ │ │\n│  │                               ↓                                             │ │\n│  │   ┌───────────────────────────────────────────────────────────────────────┐ │ │\n│  │   │ compute_wave_velocities!(S, G) → Wave velocity + Stokes drift         │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   WAVE VELOCITY (Asselin & Young 2019, eq 1.2):                       │ │ │\n│  │   │     LA = B + (k_h²/4)·A  in spectral space (YBJ+ relation)           │ │ │\n│  │   │     u_wave = Re(LA), v_wave = Im(LA)                                  │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   HORIZONTAL STOKES DRIFT (Wagner & Young 2016, eq 3.16a, 3.18):     │ │ │\n│  │   │     J₀ = (LA)*·∂_{s*}(LA) - (f₀²/N²)·(∂_{s*}A_z*)·∂_z(LA)           │ │ │\n│  │   │     u_S = Im(J₀)/f₀,  v_S = -Re(J₀)/f₀                               │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   VERTICAL STOKES DRIFT (Wagner & Young 2016, eq 3.19-3.20):         │ │ │\n│  │   │     w_S = -2·Im(K₀)/f₀  where K₀ = M*_z·M_{ss*} - M*_{s*}·M_{sz}    │ │ │\n│  │   │                                                                       │ │ │\n│  │   │   State.u += u_wave + u_S  →  u_QG + u_wave + u_S (TOTAL)            │ │ │\n│  │   │   State.v += v_wave + v_S  →  v_QG + v_wave + v_S (TOTAL)            │ │ │\n│  │   │   State.w += w_S           →  w_QG + w_S (TOTAL)                      │ │ │\n│  │   └───────────────────────────────────────────────────────────────────────┘ │ │\n│  └─────────────────────────────────────────────────────────────────────────────┘ │\n│                                ↓                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────────┐ │\n│  │ STEP 3: Copy to tracker (LOCAL data only in parallel)                       │ │\n│  │                                                                             │ │\n│  │   u_data = parent(state.u)   # LOCAL portion of distributed array          │ │\n│  │   v_data = parent(state.v)                                                  │ │\n│  │   w_data = parent(state.w)                                                  │ │\n│  │                                                                             │ │\n│  │   tracker.u_field .= u_data  # Copy TOTAL velocities to tracker            │ │\n│  │   tracker.v_field .= v_data                                                 │ │\n│  │   tracker.w_field .= w_data                                                 │ │\n│  └─────────────────────────────────────────────────────────────────────────────┘ │\n│                                ↓                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────────┐ │\n│  │ STEP 4: Halo Exchange (PARALLEL MODE ONLY)                                  │ │\n│  │                                                                             │ │\n│  │   exchange_velocity_halos!(halo_info, u_field, v_field, w_field)            │ │\n│  │                                                                             │ │\n│  │   Rank 0           Rank 1           Rank 2                                  │ │\n│  │   [u,v,w]    →     [u,v,w]    →     [u,v,w]                                │ │\n│  │      ↓                ↓                ↓                                    │ │\n│  │   [H|local|H]     [H|local|H]     [H|local|H]                              │ │\n│  │      └──send──→──recv──┘──send──→──recv──┘                                 │ │\n│  │                                                                             │ │\n│  │   Extended arrays now contain:                                              │ │\n│  │   • Left halo: neighbor's RIGHT edge velocities                             │ │\n│  │   • Local: own velocity data (QG + wave)                                   │ │\n│  │   • Right halo: neighbor's LEFT edge velocities                             │ │\n│  └─────────────────────────────────────────────────────────────────────────────┘ │\n│                                ↓                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────────┐ │\n│  │ STEP 5: Particle Interpolation                                              │ │\n│  │                                                                             │ │\n│  │   For each particle at (x, y, z):                                           │ │\n│  │     (u, v, w) = interpolate_velocity_at_position(x, y, z, tracker)          │ │\n│  │                                                                             │ │\n│  │   • Uses extended arrays (local + halos)                                    │ │\n│  │   • TRILINEAR / TRICUBIC / QUINTIC interpolation                           │ │\n│  │   • Returns TOTAL velocity (QG + wave) at particle position                │ │\n│  └─────────────────────────────────────────────────────────────────────────────┘ │\n└──────────────────────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Key-Implementation-Details","page":"Parallel Particle Algorithm","title":"Key Implementation Details","text":"","category":"section"},{"location":"advanced/parallel_particles/#1.-State-Contains-TOTAL-Velocities","page":"Parallel Particle Algorithm","title":"1. State Contains TOTAL Velocities","text":"After compute_total_velocities!, the State arrays contain the sum of QG and wave contributions:\n\n# In compute_total_velocities!:\ncompute_velocities!(S, G; ...)      # Sets S.u, S.v, S.w to QG values\ncompute_wave_velocities!(S, G; ...) # ADDS Stokes drift to S.u, S.v, S.w","category":"section"},{"location":"advanced/parallel_particles/#2.-Parallel-Data-Distribution-(PencilArrays)","page":"Parallel Particle Algorithm","title":"2. Parallel Data Distribution (PencilArrays)","text":"In MPI parallel mode:\n\nstate.u, state.v, state.w are distributed arrays (PencilArrays)\nEach rank owns a tile: [x_start, x_end] × [y_start, y_end] × [-Lz, 0]\nparent(state.u) extracts only the local portion\n\n# In update_velocity_fields!:\nu_data = parent(state.u)  # Shape: (nz, nx_local, ny_local) - LOCAL data only\ntracker.u_field .= u_data # Copy to tracker's workspace","category":"section"},{"location":"advanced/parallel_particles/#3.-Wave-Data-Source","page":"Parallel Particle Algorithm","title":"3. Wave Data Source","text":"The wave amplitude A and its derivatives come from the simulation state:\n\nField Location Description\nState.A Spectral Wave amplitude Â(kₓ, kᵧ, z)\nState.C Spectral Az = ∂A/∂z (set by `invertBtoA!`)\n\nThe wave velocity and Stokes drift computation (Wagner & Young 2016, eq. 3.16a-3.20):\n\nComputes LA = B + (k_h²/4)A in spectral space (wave velocity)\nComputes ∂{s*}(LA), ∂{s}(A_z), ∂_z(LA) in spectral space\nFor vertical Stokes: computes A{zz}, ΔH(Az), A{zs}, A_{zzs}\nTransforms all fields to physical space\nComputes wave velocity: uwave = Re(LA), vwave = Im(LA)\nComputes horizontal Stokes via full Jacobian J₀: uS = Im(J₀)/f₀, vS = -Re(J₀)/f₀\nComputes vertical Stokes via K₀: w_S = -2·Im(K₀)/f₀\nAdds all contributions to existing QG velocities","category":"section"},{"location":"advanced/parallel_particles/#4.-Halo-Exchange-Enables-Cross-Boundary-Interpolation","page":"Parallel Particle Algorithm","title":"4. Halo Exchange Enables Cross-Boundary Interpolation","text":"After halo exchange, each rank's extended arrays contain:\n\nExtended Array: halos in x and y around the local tile\n                (left/right + bottom/top + corners)\n\nThis allows particles near domain boundaries to interpolate velocities using neighbor data without additional MPI communication during advection.","category":"section"},{"location":"advanced/parallel_particles/#Code-Path-Summary","page":"Parallel Particle Algorithm","title":"Code Path Summary","text":"advect_particles!(tracker, state, grid, dt)\n  └─→ update_velocity_fields!(tracker, state, grid)\n        ├─→ compute_total_velocities!(state, grid)\n        │     ├─→ compute_velocities!()      # QG: u,v from ψ; w from omega eqn\n        │     └─→ compute_wave_velocities!() # Wave velocity + Stokes drift (J₀, K₀)\n        ├─→ tracker.u_field .= parent(state.u)  # Copy LOCAL total velocity\n        └─→ exchange_velocity_halos!()          # Fill halos from neighbors\n  └─→ advect_euler!/advect_rk2!/advect_rk4!()\n        └─→ interpolate_velocity_at_position()  # Uses extended arrays","category":"section"},{"location":"advanced/parallel_particles/#CFL-Stability-for-Particle-Advection","page":"Parallel Particle Algorithm","title":"CFL Stability for Particle Advection","text":"","category":"section"},{"location":"advanced/parallel_particles/#Halo-Constraint","page":"Parallel Particle Algorithm","title":"Halo Constraint","text":"For multi-stage integration methods (RK2, RK4), intermediate particle positions are evaluated during a single timestep. If a particle moves beyond the halo region, velocity interpolation becomes inaccurate (values are clamped to boundary).\n\nStability requirement:\n\nmax_velocity × dt < halo_width × dx\n\nwhere:\n\nmax_velocity: Maximum expected flow velocity\ndt: Timestep\nhalo_width: Ghost cell count (1, 2, or 3 depending on interpolation)\ndx: Grid spacing","category":"section"},{"location":"advanced/parallel_particles/#Validation-Function","page":"Parallel Particle Algorithm","title":"Validation Function","text":"Use validate_particle_cfl to check if your timestep is appropriate:\n\nusing QGYBJplus: validate_particle_cfl\n\n# Estimate maximum velocity in your simulation\nmax_velocity = 0.1  # m/s\n\n# Check if timestep is safe\nif !validate_particle_cfl(tracker, max_velocity, dt)\n    @warn \"Timestep may exceed halo region; consider reducing dt\"\nend","category":"section"},{"location":"advanced/parallel_particles/#Recommendations","page":"Parallel Particle Algorithm","title":"Recommendations","text":"Use higher-order interpolation: TRICUBIC (hw=2) or QUINTIC (hw=3) provide larger halo regions\nReduce timestep: If dt is too large for the flow velocities\nUse Euler integration: Only evaluates velocity at current position (no intermediate stages)\n\nExample CFL calculation:\n\n# Grid: 256 points, Lx = 2π, using TRICUBIC (hw=2)\ndx = 2π / 256  ≈ 0.0245\nhalo_width = 2\nsafe_displacement = halo_width * dx ≈ 0.049\n\n# If max velocity = 0.1 m/s, max safe dt:\ndt_max = safe_displacement / max_velocity ≈ 0.49","category":"section"},{"location":"advanced/parallel_particles/#Scalability-Analysis","page":"Parallel Particle Algorithm","title":"Scalability Analysis","text":"","category":"section"},{"location":"advanced/parallel_particles/#Communication-Costs","page":"Parallel Particle Algorithm","title":"Communication Costs","text":"Operation Data Volume Frequency\nHalo exchange O((nxlocal + nylocal) × nz × halo_width × 3) Every timestep\nMigration Alltoall O(nprocs) integers Every timestep\nMigration Send/Recv O(Np_crossing × 6) floats Every timestep","category":"section"},{"location":"advanced/parallel_particles/#Scaling-Characteristics","page":"Parallel Particle Algorithm","title":"Scaling Characteristics","text":"Strong Scaling (fixed problem size, varying ranks):\n\nVelocity computation: ~O(N/P) per rank\nParticle advection: ~O(Np/P) per rank\nCommunication: O(boundary_size) - increases relative importance\n\nWeak Scaling (fixed load per rank):\n\nIdeal scaling if particles are uniformly distributed\nLoad imbalance if particles cluster in few ranks","category":"section"},{"location":"advanced/parallel_particles/#Load-Balancing-Considerations","page":"Parallel Particle Algorithm","title":"Load Balancing Considerations","text":"Particle load can become imbalanced if:\n\nFlow concentrates particles (e.g., in eddies)\nInitial distribution is non-uniform\nSome ranks have many boundary crossings\n\nMitigation strategies:\n\nUse sufficiently many particles for statistical averaging\nInitialize particles uniformly\nMonitor particle count per rank","category":"section"},{"location":"advanced/parallel_particles/#Data-Structures","page":"Parallel Particle Algorithm","title":"Data Structures","text":"","category":"section"},{"location":"advanced/parallel_particles/#HaloInfo","page":"Parallel Particle Algorithm","title":"HaloInfo","text":"mutable struct HaloInfo{T}\n    halo_width::Int\n\n    # Extended arrays with halos (x and y)\n    u_extended::Array{T,3}       # Size: (nz_local, nx_local + 2*hw, ny_local + 2*hw)\n    v_extended::Array{T,3}\n    w_extended::Array{T,3}\n\n    # Local data position in extended arrays\n    local_start::NTuple{3,Int}   # (1, hw+1, hw+1)\n    local_end::NTuple{3,Int}     # (nz_local, hw+nx_local, hw+ny_local)\n\n    # Neighbor ranks (W, E, S, N, SW, SE, NW, NE)\n    neighbors::Vector{Int}\n\n    # Communication buffers (x/y edges + corners)\n    send_west::Vector{T}\n    send_east::Vector{T}\n    recv_west::Vector{T}\n    recv_east::Vector{T}\n    send_south::Vector{T}\n    send_north::Vector{T}\n    recv_south::Vector{T}\n    recv_north::Vector{T}\n    send_sw::Vector{T}\n    send_se::Vector{T}\n    send_nw::Vector{T}\n    send_ne::Vector{T}\n    recv_sw::Vector{T}\n    recv_se::Vector{T}\n    recv_nw::Vector{T}\n    recv_ne::Vector{T}\n\n    # MPI + topology info\n    comm::Any\n    rank::Int\n    nprocs::Int\n    nx_global::Int\n    ny_global::Int\n    nz_global::Int\n    nx_local::Int\n    ny_local::Int\n    nz_local::Int\n    px::Int\n    py::Int\n    rank_x::Int\n    rank_y::Int\n    periodic_x::Bool\n    periodic_y::Bool\n    is_2d_decomposition::Bool\nend","category":"section"},{"location":"advanced/parallel_particles/#ParticleTracker-(Parallel-Fields)","page":"Parallel Particle Algorithm","title":"ParticleTracker (Parallel Fields)","text":"mutable struct ParticleTracker{T}\n    # ... common fields ...\n\n    # MPI configuration\n    comm::Any                    # MPI.COMM_WORLD\n    rank::Int                    # This process's rank\n    nprocs::Int                  # Total processes\n    is_parallel::Bool            # true if nprocs > 1\n\n    # Domain decomposition\n    local_domain::NamedTuple     # (x_start, x_end, y_start, y_end, nx_local, ny_local, px, py, rank_x, rank_y, ...)\n\n    # Halo exchange\n    halo_info::HaloInfo{T}       # Extended arrays + buffers\n\n    # Migration buffers (one per rank)\n    send_buffers::Vector{Vector{T}}  # Length: nprocs\n    recv_buffers::Vector{Vector{T}}  # Length: nprocs\n\n    # I/O configuration\n    is_io_rank::Bool             # true if rank == 0\n    gather_for_io::Bool          # Gather particles to rank 0 for output\nend","category":"section"},{"location":"advanced/parallel_particles/#Usage-Example","page":"Parallel Particle Algorithm","title":"Usage Example","text":"using MPI\nusing QGYBJplus\n\n# Initialize MPI\nMPI.Init()\n# Set up parallel configuration\nmpi_config = setup_mpi_environment()\n\n# Create distributed grid and state\npar = default_params(Lx=2π, Ly=2π, Lz=1.0, nx=64, ny=64, nz=32)\ngrid = init_mpi_grid(par, mpi_config)\nplans = plan_mpi_transforms(grid, mpi_config)\nstate = init_mpi_state(grid, plans, mpi_config)\n\n# Create particle configuration\nparticle_config = create_particle_config(\n    x_min = 0.0, x_max = 2π,\n    y_min = 0.0, y_max = 2π,\n    z_level = π,\n    nx_particles = 100,\n    ny_particles = 100,\n    integration_method = :rk4,\n    interpolation_method = TRILINEAR\n)\n\n# Create particle tracker with parallel support\ntracker = ParticleTracker(particle_config, grid, mpi_config)\ninitialize_particles!(tracker, particle_config)\n\n# Main simulation loop (advance fluid state separately)\nfor step in 1:nsteps\n    current_time = step * par.dt\n    advect_particles!(tracker, state, grid, par.dt, current_time)\nend\n\n# Save trajectories (rank 0 gathers and writes, or each rank writes independently)\nif mpi_config.is_root || !tracker.gather_for_io\n    write_particle_trajectories(\"particles_rank$(mpi_config.rank).nc\", tracker)\nend\n\nMPI.Finalize()","category":"section"},{"location":"advanced/parallel_particles/#Debugging-Tips","page":"Parallel Particle Algorithm","title":"Debugging Tips","text":"","category":"section"},{"location":"advanced/parallel_particles/#Check-Particle-Distribution","page":"Parallel Particle Algorithm","title":"Check Particle Distribution","text":"# Print particle count per rank\nprintln(\"Rank $rank has $(tracker.particles.np) particles\")\nMPI.Barrier(comm)","category":"section"},{"location":"advanced/parallel_particles/#Verify-Halo-Exchange","page":"Parallel Particle Algorithm","title":"Verify Halo Exchange","text":"# After halo exchange, check extended array values\nif rank == 0\n    println(\"Left halo (should be from neighbor): \", halo_info.u_extended[1:2, 1, 1])\n    println(\"Local data start: \", halo_info.u_extended[3:4, 1, 1])\nend","category":"section"},{"location":"advanced/parallel_particles/#Monitor-Migration","page":"Parallel Particle Algorithm","title":"Monitor Migration","text":"# Track particles crossing boundaries\nn_migrated = sum(length.(tracker.send_buffers)) ÷ 6\nprintln(\"Rank $rank migrating $n_migrated particles\")","category":"section"},{"location":"advanced/parallel_particles/#See-Also","page":"Parallel Particle Algorithm","title":"See Also","text":"Particle Advection - General particle documentation\nMPI Parallelization - Overall parallel architecture\nAPI Reference - Function documentation","category":"section"},{"location":"api/#api-index","page":"Full Index","title":"API Reference","text":"Complete API reference for QGYBJ+.jl.","category":"section"},{"location":"api/#Quick-Links","page":"Full Index","title":"Quick Links","text":"Core Types: QGParams, Grid, State\nGrid & State: Initialization and utilities\nPhysics Functions: Inversions, operators, diagnostics\nTime Stepping: Leapfrog and IMEX-CNAB integration\nParticles: Lagrangian particle tracking","category":"section"},{"location":"api/#Module-Structure","page":"Full Index","title":"Module Structure","text":"The codebase is organized into logical groups. Files are included in dependency order in the main module.\n\nQGYBJplus.jl/\n├── src/\n│   ├── QGYBJplus.jl          # Main module: exports, includes\n│   │\n│   ├── ─── Core Data Structures ───\n│   ├── parameters.jl         # QGParams: all model parameters\n│   ├── grid.jl               # Grid: coordinates, wavenumbers, decomposition\n│   ├── config.jl             # DomainConfig, PhysicsConfig, OutputConfig\n│   │\n│   ├── ─── Transforms ───\n│   ├── transforms.jl         # FFTW planning, fft_forward!, fft_backward!\n│   ├── parallel_mpi.jl       # MPI 2D pencil decomposition, transposes\n│   │\n│   ├── ─── Physics & Operators ───\n│   ├── physics.jl            # Stratification N², a_ell coefficients\n│   ├── elliptic.jl           # Tridiagonal solvers (q→ψ, B→A inversions)\n│   ├── operators.jl          # Velocity computation from streamfunction\n│   ├── nonlinear.jl          # Jacobians, refraction, wave feedback qʷ\n│   ├── ybj_normal.jl         # Normal YBJ operators (non-plus variant)\n│   │\n│   ├── ─── Time Integration ───\n│   ├── timestep.jl           # Forward Euler, Leapfrog + Robert-Asselin\n│   ├── timestep_imex.jl      # IMEX Crank-Nicolson (implicit dispersion)\n│   │\n│   ├── ─── Initialization ───\n│   ├── initconds.jl          # Random/analytic initial conditions\n│   ├── initialization.jl     # Field initialization helpers\n│   ├── stratification.jl     # Stratification profiles (constant, exponential, custom)\n│   │\n│   ├── ─── Diagnostics ───\n│   ├── diagnostics.jl        # Energy diagnostics, omega equation RHS\n│   ├── energy_diagnostics.jl # Separate energy output files\n│   │\n│   ├── ─── I/O ───\n│   ├── netcdf_io.jl          # NetCDF read/write with legacy compatibility\n│   │\n│   ├── ─── High-Level Interface ───\n│   ├── runtime.jl            # Setup helpers (setup_model, dealias_mask)\n│   ├── model_interface.jl    # QGYBJSimulation, run_simulation!\n│   ├── simulation.jl         # Simulation struct, initialize_simulation, run!\n│   │\n│   ├── ─── Particle Tracking ───\n│   ├── particles/\n│   │   ├── particle_advection.jl     # Core advection, ParticleTracker\n│   │   ├── particle_config.jl        # ParticleConfig, ParticleConfig3D\n│   │   ├── particle_io.jl            # Trajectory I/O (NetCDF)\n│   │   ├── interpolation_schemes.jl  # TRILINEAR, TRICUBIC, ADAPTIVE, QUINTIC\n│   │   └── halo_exchange.jl          # MPI halo exchange for particles\n│   │\n│   └── pretty_printing.jl    # Display formatting for structs\n│\n├── test/\n│   ├── runtests.jl           # Main test suite\n│   ├── test_mpi_extension.jl # MPI-specific tests\n│   └── test_parallel_particles_detailed.jl\n│\n├── docs/\n│   ├── make.jl               # Documenter.jl build script\n│   └── src/                  # Documentation source (Markdown)\n│\n\nMPI support is built into the main module via src/parallel_mpi.jl (there is no ext/ directory in this repository).","category":"section"},{"location":"api/#Naming-Conventions","page":"Full Index","title":"Naming Conventions","text":"Suffix Meaning Example\n! In-place modification compute_velocities!\n_spectral Operates in spectral space jacobian_spectral!\n_waqg Wave-related convol_waqg!\n_mpi MPI-enabled version init_mpi_grid","category":"section"},{"location":"api/#Main-Entry-Points","page":"Full Index","title":"Main Entry Points","text":"","category":"section"},{"location":"api/#Setup","page":"Full Index","title":"Setup","text":"# Create parameters (domain size REQUIRED)\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\n\n# Initialize everything at once\nG, S, plans, a = setup_model(par)","category":"section"},{"location":"api/#Time-Stepping","page":"Full Index","title":"Time Stepping","text":"# Leapfrog (default, explicit)\nfirst_projection_step!(S, G, par, plans; a=a, dealias_mask=L)\nleapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a, dealias_mask=L)\n\n# IMEX-CNAB (implicit dispersion, 10x larger timestep)\nimex_ws = init_imex_workspace(S, G)\nfirst_imex_step!(S, G, par, plans, imex_ws; a=a, dealias_mask=L)\nimex_cn_step!(Snp1, Sn, G, par, plans, imex_ws; a=a, dealias_mask=L)","category":"section"},{"location":"api/#MPI-Parallel-Mode","page":"Full Index","title":"MPI Parallel Mode","text":"using MPI, PencilArrays, PencilFFTs, QGYBJplus\nMPI.Init()\nmpi_config = setup_mpi_environment()\nG = init_mpi_grid(par, mpi_config)\nplans = plan_mpi_transforms(G, mpi_config)\nS = init_mpi_state(G, plans, mpi_config)\nworkspace = init_mpi_workspace(G, mpi_config)","category":"section"},{"location":"api/#Key-Functions-by-Category","page":"Full Index","title":"Key Functions by Category","text":"","category":"section"},{"location":"api/#Initialization","page":"Full Index","title":"Initialization","text":"Function Description\ndefault_params Create model parameters\ninit_grid / init_mpi_grid Initialize grid\ninit_state / init_mpi_state Initialize state arrays\nplan_transforms! / plan_mpi_transforms Create FFT plans\ninit_mpi_workspace Allocate z-pencil workspace","category":"section"},{"location":"api/#Physics","page":"Full Index","title":"Physics","text":"Function Description\ninvert_q_to_psi! Solve elliptic PV inversion\ninvert_B_to_A! Solve YBJ+ wave inversion\ncompute_velocities! Compute u, v from ψ\njacobian_spectral! Compute Jacobian J(a,b)","category":"section"},{"location":"api/#Time-Stepping-2","page":"Full Index","title":"Time Stepping","text":"Function Description\nfirst_projection_step! Forward Euler initialization (Leapfrog)\nleapfrog_step! Leapfrog with Robert-Asselin filter\ninit_imex_workspace Allocate IMEX workspace arrays\nfirst_imex_step! Forward Euler initialization (IMEX)\nimex_cn_step! IMEX-CNAB with Strang splitting","category":"section"},{"location":"api/#Parallel-Utilities","page":"Full Index","title":"Parallel Utilities","text":"Function Description\nallocate_fft_backward_dst Allocate physical array for FFT output\nget_local_range_physical Get physical array local ranges\nget_local_range_spectral Get spectral array local ranges\ntranspose_to_z_pencil! Transpose to z-local layout\ntranspose_to_xy_pencil! Transpose back to xy layout","category":"section"},{"location":"api/#Diagnostics","page":"Full Index","title":"Diagnostics","text":"Function Description\nflow_kinetic_energy Compute mean flow KE\nwave_energy Compute wave energy\nslice_horizontal Extract horizontal slice\nomega_eqn_rhs! Compute omega equation RHS\n\nSee individual pages for detailed API documentation.","category":"section"},{"location":"physics/qg_equations/#qg-equations","page":"QG Equations","title":"QG Equations","text":"This page details the quasi-geostrophic (QG) equations implemented in QGYBJ+.jl.","category":"section"},{"location":"physics/qg_equations/#Potential-Vorticity-Evolution","page":"QG Equations","title":"Potential Vorticity Evolution","text":"The core QG equation is the conservation of potential vorticity:\n\nfracpartial qpartial t + J(psi q) = mathcalD_q + mathcalF_q\n\nwhere mathcalD_q is dissipation and mathcalF_q is forcing.","category":"section"},{"location":"physics/qg_equations/#Potential-Vorticity-Definition","page":"QG Equations","title":"Potential Vorticity Definition","text":"q = underbracenabla^2psi_textrelative vorticity + underbracefracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright)_textstretching term\n\nFor uniform stratification (N^2 = textconst):\n\nq = nabla^2psi + fracf_0^2N^2fracpartial^2psipartial z^2","category":"section"},{"location":"physics/qg_equations/#Physical-Interpretation","page":"QG Equations","title":"Physical Interpretation","text":"Term Physical Meaning\nnabla^2psi Relative vorticity zeta\n(f_0^2N^2)partial_z^2psi Vortex stretching due to vertical motion\nJ(psi q) Advection of PV by geostrophic flow","category":"section"},{"location":"physics/qg_equations/#Streamfunction-Inversion","page":"QG Equations","title":"Streamfunction Inversion","text":"Given q, we solve for psi via the elliptic equation:\n\nnabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q","category":"section"},{"location":"physics/qg_equations/#Spectral-Representation","page":"QG Equations","title":"Spectral Representation","text":"In spectral space (horizontal) with vertical finite differences:\n\n-k_h^2 hatpsi + fracpartialpartial zleft(a(z)fracpartialhatpsipartial zright) = hatq\n\nwhere:\n\nk_h^2 = k_x^2 + k_y^2 (horizontal wavenumber squared)\na(z) = f_0^2N^2(z) (stretching coefficient)","category":"section"},{"location":"physics/qg_equations/#Tridiagonal-System","page":"QG Equations","title":"Tridiagonal System","text":"For each horizontal wavenumber (k_x k_y), the vertical discretization gives:\n\na_k hatpsi_k-1 + b_k hatpsi_k + c_k hatpsi_k+1 = hatq_k\n\nThis is solved efficiently with the Thomas algorithm in O(nz) operations.","category":"section"},{"location":"physics/qg_equations/#Boundary-Conditions","page":"QG Equations","title":"Boundary Conditions","text":"Top and Bottom: fracpartialpsipartial z = 0 (no buoyancy flux)\n\nIn the code:\n\n# Called for each time step\ninvert_q_to_psi!(state, grid, params, a_ell)","category":"section"},{"location":"physics/qg_equations/#Velocity-Fields","page":"QG Equations","title":"Velocity Fields","text":"","category":"section"},{"location":"physics/qg_equations/#Geostrophic-Velocities","page":"QG Equations","title":"Geostrophic Velocities","text":"From geostrophic balance:\n\nu = -fracpartialpsipartial y quad v = fracpartialpsipartial x\n\nIn spectral space:\n\nhatu = -ik_yhatpsi quad hatv = ik_xhatpsi","category":"section"},{"location":"physics/qg_equations/#Vertical-Velocity","page":"QG Equations","title":"Vertical Velocity","text":"The QG omega equation gives the ageostrophic vertical velocity:\n\nN^2 nabla^2 w + f_0^2fracpartial^2 wpartial z^2 = 2f_0 Jleft(fracpartialpsipartial z nabla^2psiright)\n\nor equivalently (dividing by N^2):\n\nnabla^2 w + fracf_0^2N^2fracpartial^2 wpartial z^2 = frac2f_0N^2Jleft(fracpartialpsipartial z nabla^2psiright)\n\nThe coefficient f_0^2N^2 ll 1 in typical oceanic conditions, reflecting that stratification strongly suppresses vertical motion relative to horizontal. The RHS represents frontogenesis/frontolysis forcing through the interaction of vertical shear (thermal wind) with relative vorticity gradients.","category":"section"},{"location":"physics/qg_equations/#Jacobian-Operator","page":"QG Equations","title":"Jacobian Operator","text":"The Jacobian J(a b) is computed pseudo-spectrally:\n\nJ(a b) = fracpartial apartial xfracpartial bpartial y - fracpartial apartial yfracpartial bpartial x","category":"section"},{"location":"physics/qg_equations/#Algorithm","page":"QG Equations","title":"Algorithm","text":"Compute partial apartial x, partial apartial y in spectral space\nTransform to physical space\nMultiply in physical space\nTransform back to spectral space\nApply dealiasing (2/3 rule)","category":"section"},{"location":"physics/qg_equations/#Conservation-Properties","page":"QG Equations","title":"Conservation Properties","text":"The Jacobian satisfies:\n\nint J(a b)  dA = 0 (integral vanishes)\nJ(a a) = 0 (anti-symmetry)\n\nThese ensure energy and enstrophy conservation in the inviscid limit.","category":"section"},{"location":"physics/qg_equations/#Dissipation","page":"QG Equations","title":"Dissipation","text":"","category":"section"},{"location":"physics/qg_equations/#Hyperdiffusion","page":"QG Equations","title":"Hyperdiffusion","text":"The model uses scale-selective hyperdiffusion:\n\nmathcalD_q = -nu_h1(-nabla^2)^p_1 q - nu_h2(-nabla^2)^p_2 q - nu_zfracpartial^2 qpartial z^2\n\nwhere:\n\nnu_h1 p_1: Large-scale dissipation (drag)\nnu_h2 p_2: Small-scale dissipation (hyperviscosity)\nnu_z: Vertical diffusion","category":"section"},{"location":"physics/qg_equations/#Integrating-Factor-Method","page":"QG Equations","title":"Integrating Factor Method","text":"To handle stiff diffusion, we use integrating factors:\n\ntildeq = q cdot e^nu k^2p Delta t\n\nThis allows larger time steps while maintaining stability.","category":"section"},{"location":"physics/qg_equations/#Wave-Feedback","page":"QG Equations","title":"Wave Feedback","text":"When waves are present, the QG equation includes a feedback term through a modified effective PV.","category":"section"},{"location":"physics/qg_equations/#The-Wave-Feedback-Mechanism","page":"QG Equations","title":"The Wave Feedback Mechanism","text":"The wave-induced PV q^w is computed from the wave envelope B:\n\nq^w = fraci2f_0 J(B^* B) + frac14f_0 nabla_h^2 B^2\n\nwhere B = B_R + i B_I is the complex wave envelope with units of velocity (m/s) and f_0 is the Coriolis parameter.\n\nnote: Dimensional Equations\nThe model solves dimensional equations where B has actual velocity amplitude. The 1f_0 factor ensures correct dimensionality of the wave feedback term.","category":"section"},{"location":"physics/qg_equations/#Effective-PV-for-Inversion","page":"QG Equations","title":"Effective PV for Inversion","text":"The streamfunction is obtained by inverting the effective PV:\n\nq^* = q - q^w\n\nnabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q^*\n\nThis means the wave feedback modifies the inversion rather than appearing as an explicit advection term.\n\nSee Wave-Mean Interaction for detailed formulas and implementation.","category":"section"},{"location":"physics/qg_equations/#Implementation","page":"QG Equations","title":"Implementation","text":"","category":"section"},{"location":"physics/qg_equations/#Key-Functions","page":"QG Equations","title":"Key Functions","text":"The QG equation implementation uses these core functions:\n\ninvert_q_to_psi! - Solve elliptic equation for streamfunction\njacobian_spectral! - Compute Jacobian pseudo-spectrally\ncompute_velocities! - Get (u, v) from streamfunction\n\nSee the Physics API Reference for detailed documentation.","category":"section"},{"location":"physics/qg_equations/#Code-Location","page":"QG Equations","title":"Code Location","text":"elliptic.jl: Streamfunction inversion (invert_q_to_psi!)\nnonlinear.jl: Jacobian computation (jacobian_spectral!)\noperators.jl: Velocity computation (compute_velocities!)","category":"section"},{"location":"physics/qg_equations/#References","page":"QG Equations","title":"References","text":"Vallis, G. K. (2017). Atmospheric and Oceanic Fluid Dynamics. Cambridge University Press.\nPedlosky, J. (1987). Geophysical Fluid Dynamics. Springer.","category":"section"},{"location":"advanced/particles/#particles","page":"Particle Advection","title":"Particle Advection","text":"This page describes Lagrangian particle tracking in QGYBJ+.jl, including the physics, numerical algorithms, and parallel implementation.","category":"section"},{"location":"advanced/particles/#Overview","page":"Particle Advection","title":"Overview","text":"Particle tracking allows you to:\n\nFollow fluid parcels as they move with the flow\nCompute Lagrangian statistics (dispersion, diffusivity)\nTrack tracer concentrations along trajectories\nStudy mixing and transport in QG-YBJ+ dynamics","category":"section"},{"location":"advanced/particles/#Physics-of-Particle-Advection","page":"Particle Advection","title":"Physics of Particle Advection","text":"In QG-YBJ+ dynamics, Lagrangian particles experience velocities from both the balanced (geostrophic) flow and near-inertial waves. Understanding the complete velocity field is essential for accurate particle tracking.","category":"section"},{"location":"advanced/particles/#Complex-Coordinate-Notation","page":"Particle Advection","title":"Complex Coordinate Notation","text":"Before diving into the physics, we introduce the complex coordinate notation used throughout:\n\nSymbol Definition Description\ns x + iy Complex horizontal coordinate\ns^* x - iy Complex conjugate coordinate\npartial_s frac12(partial_x - ipartial_y) Complex derivative\npartial_s^* frac12(partial_x + ipartial_y) Conjugate complex derivative\ntildez Stretched vertical coordinate dtildez = (Nf_0) dz\n\nThis notation simplifies the wave equations and makes the underlying structure more apparent.","category":"section"},{"location":"advanced/particles/#Total-Velocity-Field","page":"Particle Advection","title":"Total Velocity Field","text":"Particles are advected by the total velocity field:\n\nmathbfu_total = mathbfu_QG + mathbfu_wave + mathbfu_Stokes\n\nEach component has distinct physical origins:\n\nComponent Physical Origin Typical Magnitude\nmathbfu_QG Geostrophic balance O(0.1-1 m/s)\nmathbfu_wave Near-inertial wave orbital motion O(0.01-0.1 m/s)\nmathbfu_Stokes Wave-induced Lagrangian drift O(0.001-0.01 m/s)\n\n","category":"section"},{"location":"advanced/particles/#1.-Geostrophic-Flow-(QG-Velocities)","page":"Particle Advection","title":"1. Geostrophic Flow (QG Velocities)","text":"Physical interpretation: The geostrophic flow arises from the balance between pressure gradient and Coriolis forces. It represents the large-scale, slowly-evolving background flow.","category":"section"},{"location":"advanced/particles/#Horizontal-Geostrophic-Velocities","page":"Particle Advection","title":"Horizontal Geostrophic Velocities","text":"From geostrophic balance fmathbfu = -nabla p  rho_0 and the streamfunction definition:\n\nu_QG = -fracpartial psipartial y quad v_QG = fracpartial psipartial x\n\nSpectral space implementation:\n\nhatu_QG = -i k_y hatpsi quad hatv_QG = i k_x hatpsi\n\nwhere k_x k_y are the horizontal wavenumbers.","category":"section"},{"location":"advanced/particles/#Vertical-QG-Velocity-(Omega-Equation)","page":"Particle Advection","title":"Vertical QG Velocity (Omega Equation)","text":"The ageostrophic vertical velocity maintains thermal wind balance as the flow evolves. It satisfies the omega equation:\n\nN^2 nabla_H^2 w_QG + f_0^2 fracpartial^2 w_QGpartial z^2 = 2 f_0  Jleft(psi_z nabla_H^2 psiright)\n\nor equivalently (dividing by N^2):\n\nnabla_H^2 w_QG + fracf_0^2N^2 fracpartial^2 w_QGpartial z^2 = frac2 f_0N^2  Jleft(psi_z nabla_H^2 psiright)\n\nwhere J(ab) = a_x b_y - a_y b_x is the Jacobian operator.\n\nPhysical interpretation: The RHS represents vorticity advection by the thermal wind shear. Where this is non-zero, vertical motion is required to maintain balance.\n\nNumerical solution: In spectral space, this becomes a tridiagonal system at each (k_x k_y):\n\n-k_h^2 hatw + fracf_0^2N^2 fracpartial^2 hatwpartial z^2 = widehattextRHS\n\nsolved with boundary conditions w = 0 at z = 0 (surface) and z = -H (bottom).\n\n","category":"section"},{"location":"advanced/particles/#2.-Wave-Velocity-(Near-Inertial-Oscillations)","page":"Particle Advection","title":"2. Wave Velocity (Near-Inertial Oscillations)","text":"Physical interpretation: Near-inertial waves are oscillatory motions at frequencies close to the local Coriolis frequency f_0. The wave velocity represents the direct orbital motion of fluid parcels due to these waves.","category":"section"},{"location":"advanced/particles/#YBJ-Wave-Velocity-Formulation","page":"Particle Advection","title":"YBJ+ Wave Velocity Formulation","text":"Following Asselin & Young (2019), the horizontal wave velocity is:\n\nu + iv = e^-if_0 t  LA\n\nwhere LA is the backrotated wave velocity amplitude (removing the inertial oscillation).\n\nThe L operator: The vertical operator L is defined as:\n\nL = partial_z left(fracf_0^2N^2right) partial_z\n\nFor constant N^2, this simplifies to L = (f_0^2N^2) partial_zz.\n\nYBJ+ relation: The evolved variable B relates to the wave amplitude A via:\n\nB = L^+ A = left(L + frac14Delta_Hright) A\n\nwhere Delta_H = partial_xx + partial_yy is the horizontal Laplacian.\n\nComputing LA from B and A:\n\nRearranging: LA = B - frac14Delta_H A\n\nIn spectral space (where Delta_H to -k_h^2):\n\nwidehatLA = hatB + frack_h^24 hatA\n\nWave velocity components:\n\nu_wave = textRe(LA) quad v_wave = textIm(LA)\n\nPhysical interpretation: LA represents the phase-averaged (backrotated) wave velocity. The real part gives the zonal component, the imaginary part gives the meridional component.","category":"section"},{"location":"advanced/particles/#YBJ-Vertical-Velocity","page":"Particle Advection","title":"YBJ Vertical Velocity","text":"The wave-induced vertical velocity follows from Asselin & Young (2019, eq. 2.10):\n\nw_0 = -fracf_0^2N^2 A_zs  e^-i f_0 t + textcc\n\nExpanded form (separating oscillating components):\n\nw = -fracf_0^2N^2 leftcos(f_0 t) cdot w_cos + sin(f_0 t) cdot w_sinright\n\nwhere:\n\nw_cos = textRe(partial_x A_z) + textIm(partial_y A_z)\n\nw_sin = textIm(partial_x A_z) - textRe(partial_y A_z)\n\n","category":"section"},{"location":"advanced/particles/#3.-Wave-Induced-Stokes-Drift","page":"Particle Advection","title":"3. Wave-Induced Stokes Drift","text":"Physical interpretation: Even though waves are oscillatory with zero Eulerian mean velocity, particles experience a net Lagrangian drift in the direction of wave propagation. This is the Stokes drift, arising from the correlation between particle displacement and velocity gradients.","category":"section"},{"location":"advanced/particles/#Horizontal-Stokes-Drift-(Wagner-and-Young-2016,-eq.-3.16a-3.18)","page":"Particle Advection","title":"Horizontal Stokes Drift (Wagner & Young 2016, eq. 3.16a-3.18)","text":"The horizontal Stokes drift velocity is given by the complex velocity:\n\nU^S = u_S + i v_S\n\nFrom eq. (3.18), this satisfies:\n\ni f_0 U^S = J_0\n\nwhere J_0 is the horizontal Jacobian:\n\nJ_0 = fracpartial(M^* M_tildez)partial(tildez s^*) = (LA)^* partial_s^*(LA) - M^*_s^* cdot (M_tildez)_tildez\n\nExpanded form using M = (f_0^2N^2) A_z and M_tildez = LA:\n\nJ_0 = (LA)^* partial_s^*(LA) - fracf_0^2N^2 (partial_s^* A_z^*) cdot partial_z(LA)\n\nExtracting real velocities from U^S = J_0  (i f_0) = -i J_0  f_0:\n\nu_S = fractextIm(J_0)f_0 quad v_S = -fractextRe(J_0)f_0\n\nTwo-term structure:\n\nFirst term (LA)^* partial_s^*(LA): Primary Stokes drift from wave velocity gradients\nSecond term -(f_0^2N^2)(partial_s^* A_z^*) partial_z(LA): Correction from vertical structure of wave envelope\n\nSpectral space computation of partial_s^*:\n\npartial_s^* = frac12(partial_x + ipartial_y) quad Rightarrow quad widehatpartial_s^* f = frac12(i k_x - k_y) hatf","category":"section"},{"location":"advanced/particles/#Vertical-Stokes-Drift-(Wagner-and-Young-2016,-eq.-3.19-3.20)","page":"Particle Advection","title":"Vertical Stokes Drift (Wagner & Young 2016, eq. 3.19-3.20)","text":"The vertical Stokes drift satisfies:\n\ni f_0 w^S = K_0^* - K_0 = -2i  textIm(K_0)\n\nTherefore:\n\nw_S = -frac2  textIm(K_0)f_0\n\nThe K_0 Jacobian:\n\nK_0 = fracpartial(M^* M_s)partial(tildez s^*) = M^*_z cdot M_ss^* - M^*_s^* cdot M_sz\n\nwhere M = a cdot A_z with a = f_0^2N^2.\n\nDetailed expansion of each term:\n\nTerm Expression Computation\nM^*_z partial_z(a A_z^*) a_z A_z^* + a A_zz^*\nM_ss^* partial_s partial_s^*(a A_z) fraca4 nabla_H^2 A_z\nM^*_s^* partial_s^*(a A_z^*) a (partial_s^* A_z)^* = a (A_zs)^*\nM_sz partial_s partial_z(a A_z) a_z A_zs + a A_zzs\n\nwhere:\n\na_z = partial_z(f_0^2N^2) captures stratification variations\nA_zs = partial_s(A_z) = frac12(partial_x - ipartial_y) A_z\nA_zzs = partial_s(A_zz)\n\nSpectral space computation:\n\nnabla_H^2 A_z to -k_h^2 hatA_z\nA_zs to frac12(i k_x + k_y) hatA_z\nVertical derivatives use finite differences\n\n","category":"section"},{"location":"advanced/particles/#Total-Velocity-Summary","page":"Particle Advection","title":"Total Velocity Summary","text":"The complete velocity used for particle advection is:\n\nboxed\nbeginaligned\nu_total = u_QG + u_wave + u_S \nv_total = v_QG + v_wave + v_S \nw_total = w_QG + w_S\nendaligned\n\n\nComponent Horizontal Vertical\nQG -psi_y +psi_x Omega equation\nWave textRe(LA) textIm(LA) (included in QG or YBJ)\nStokes textIm(J_0)f_0 -textRe(J_0)f_0 -2textIm(K_0)f_0\n\n","category":"section"},{"location":"advanced/particles/#Advection-Options","page":"Particle Advection","title":"Advection Options","text":"The particle advection behavior can be controlled via ParticleConfig options:","category":"section"},{"location":"advanced/particles/#2D-vs-3D-Advection-(use_3d_advection)","page":"Particle Advection","title":"2D vs 3D Advection (use_3d_advection)","text":"Setting Behavior\nuse_3d_advection = true (default) Full 3D advection with vertical velocity\nuse_3d_advection = false Horizontal-only advection at constant z\n\nWhen use_3d_advection = false:\n\nThe vertical velocity w is not computed (skipped in compute_total_velocities!)\nThe dzdt = w time stepping is skipped in the advection loop\nParticles remain at their initial depth levels\n\nThis provides a performance benefit since vertical velocity computation (omega equation, vertical Stokes drift) is expensive. Useful for:\n\nTracking particles on specific isopycnal surfaces\nStudying horizontal dispersion without vertical mixing\nComparing with drifter observations at fixed depths\n\nExample:\n\n# Create configuration for 2D horizontal advection only\nconfig = ParticleConfig(\n    z_level = -500.0,           # Initial depth (particles stay here)\n    use_3d_advection = false,   # Disable vertical advection\n    # ... other options\n)","category":"section"},{"location":"advanced/particles/#Vertical-Velocity-Source-(use_ybj_w)","page":"Particle Advection","title":"Vertical Velocity Source (use_ybj_w)","text":"Setting Vertical velocity source\nuse_ybj_w = false (default) QG omega equation: w_QG\nuse_ybj_w = true YBJ wave-induced: w_YBJ\n\nThis option only affects w_{QG} in the total velocity; Stokes drift w_S is always included when use_3d_advection = true.\n\n","category":"section"},{"location":"advanced/particles/#Implementation-Notes","page":"Particle Advection","title":"Implementation Notes","text":"Order of operations: QG velocities are computed first, then wave velocity and Stokes drift are added in-place\nSpectral vs physical space: Derivatives are computed in spectral space; products (Jacobians) are computed in physical space\nVertical derivatives: Use second-order finite differences with one-sided stencils at boundaries\nStratification profile: The code supports both constant N^2 and depth-varying N^2(z)","category":"section"},{"location":"advanced/particles/#References","page":"Particle Advection","title":"References","text":"Asselin, O. & Young, W. R. (2019). Penetration of wind-generated near-inertial waves into a turbulent ocean. J. Fluid Mech., 876, 428-448.\nWagner, G. L. & Young, W. R. (2016). A three-component model for the coupled evolution of near-inertial waves, quasi-geostrophic flow and the near-inertial second harmonic. J. Fluid Mech., 802, 806-837.\nXie, J.-H. & Vanneste, J. (2015). A generalised-Lagrangian-mean model of the interactions between near-inertial waves and mean flow. J. Fluid Mech., 774, 143-169.","category":"section"},{"location":"advanced/particles/#Quick-Start","page":"Particle Advection","title":"Quick Start","text":"","category":"section"},{"location":"advanced/particles/#Co-Evolution-with-Fluid-(Recommended)","page":"Particle Advection","title":"Co-Evolution with Fluid (Recommended)","text":"Particles can be passed directly to the timestep functions to co-evolve with the wave and mean flow equations. This ensures particles use the same dt as the fluid simulation:\n\nusing QGYBJplus\n\n# Setup model first\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a = setup_model(par)\n\n# Create particle configuration (100 particles, default Euler integration)\n# NOTE: x_max, y_max are REQUIRED - use G.Lx, G.Ly from grid\nparticle_config = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\n\n# Create and initialize particle tracker\ntracker = ParticleTracker(particle_config, G)\ninitialize_particles!(tracker, particle_config)\n\n# Particles co-evolve automatically with the fluid\n# Option 1: Leapfrog time stepping\nfirst_projection_step!(S, G, par, plans; a=a, particle_tracker=tracker, current_time=0.0)\nfor step in 1:nsteps\n    current_time = step * par.dt\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a,\n                   particle_tracker=tracker, current_time=current_time)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\n# Option 2: IMEX time stepping\nfirst_imex_step!(S, G, par, plans, imex_ws; a=a, particle_tracker=tracker, current_time=0.0)\nfor step in 1:nsteps\n    current_time = step * par.dt\n    imex_cn_step!(Snp1, Sn, G, par, plans, imex_ws; a=a,\n                  particle_tracker=tracker, current_time=current_time)\n    Sn, Snp1 = Snp1, Sn\nend\n\n# Save trajectories\nwrite_particle_trajectories(\"particles.nc\", tracker)","category":"section"},{"location":"advanced/particles/#Manual-Advection-(Alternative)","page":"Particle Advection","title":"Manual Advection (Alternative)","text":"For more control, particles can be advected manually:\n\n# Create particle configuration\n# NOTE: x_max, y_max are REQUIRED - use G.Lx, G.Ly from grid\nparticle_config = particles_in_box(-2000.0;\n    x_max=G.Lx, y_max=G.Ly,  # REQUIRED\n    nx=10, ny=10,\n    save_interval=0.1\n)\n\n# Create particle tracker\ntracker = ParticleTracker(particle_config, sim.grid)\ninitialize_particles!(tracker, particle_config)\n\n# Advect particles manually after each timestep\nfor step in 1:nsteps\n    timestep!(sim)\n    advect_particles!(tracker, sim.state, sim.grid, par.dt, sim.current_time)\nend\n\n# Save trajectories\nwrite_particle_trajectories(\"particles.nc\", tracker)","category":"section"},{"location":"advanced/particles/#Time-Integration-Methods","page":"Particle Advection","title":"Time Integration Methods","text":"Three integration schemes are available:","category":"section"},{"location":"advanced/particles/#Euler-Method-(1st-order)","page":"Particle Advection","title":"Euler Method (1st order)","text":"mathbfx_n+1 = mathbfx_n + Delta t cdot mathbfu(mathbfx_n t_n)\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, integration_method=:euler)","category":"section"},{"location":"advanced/particles/#RK2-Midpoint-Method-(2nd-order)","page":"Particle Advection","title":"RK2 Midpoint Method (2nd order)","text":"beginaligned\nmathbfk_1 = mathbfu(mathbfx_n t_n) \nmathbfx_mid = mathbfx_n + fracDelta t2 mathbfk_1 \nmathbfk_2 = mathbfu(mathbfx_mid t_n + fracDelta t2) \nmathbfx_n+1 = mathbfx_n + Delta t cdot mathbfk_2\nendaligned\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, integration_method=:rk2)","category":"section"},{"location":"advanced/particles/#RK4-Classical-Method-(4th-order)","page":"Particle Advection","title":"RK4 Classical Method (4th order)","text":"beginaligned\nmathbfk_1 = mathbfu(mathbfx_n t_n) \nmathbfk_2 = mathbfu(mathbfx_n + fracDelta t2mathbfk_1 t_n + fracDelta t2) \nmathbfk_3 = mathbfu(mathbfx_n + fracDelta t2mathbfk_2 t_n + fracDelta t2) \nmathbfk_4 = mathbfu(mathbfx_n + Delta tmathbfk_3 t_n + Delta t) \nmathbfx_n+1 = mathbfx_n + fracDelta t6(mathbfk_1 + 2mathbfk_2 + 2mathbfk_3 + mathbfk_4)\nendaligned\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, integration_method=:rk4)\n\nMethod Order Velocity Evaluations/Step Recommended Use\n:euler (default) 1 1 Co-evolution with fluid, large dt\n:rk2 2 2 Balance of speed/accuracy\n:rk4 4 4 High accuracy studies","category":"section"},{"location":"advanced/particles/#Interpolation-Methods","page":"Particle Advection","title":"Interpolation Methods","text":"Velocity must be interpolated from the grid to particle positions.","category":"section"},{"location":"advanced/particles/#Trilinear-(Default)","page":"Particle Advection","title":"Trilinear (Default)","text":"Stencil: 2×2×2 = 8 points\nOrder: O(h²)\nSmoothness: C⁰ continuous\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, interpolation_method=TRILINEAR)","category":"section"},{"location":"advanced/particles/#Tricubic","page":"Particle Advection","title":"Tricubic","text":"Stencil: 4×4×4 = 64 points (Catmull-Rom splines)\nOrder: O(h⁴)\nSmoothness: C¹ continuous\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, interpolation_method=TRICUBIC)","category":"section"},{"location":"advanced/particles/#Quintic","page":"Particle Advection","title":"Quintic","text":"Stencil: 6×6×6 = 216 points (B-splines)\nOrder: O(h⁶)\nSmoothness: C⁴ continuous\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, interpolation_method=QUINTIC)","category":"section"},{"location":"advanced/particles/#Adaptive","page":"Particle Advection","title":"Adaptive","text":"Automatically selects trilinear or tricubic based on local field smoothness.\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, interpolation_method=ADAPTIVE)\n\nMethod Points Error Best For\nTRILINEAR 8 O(h²) Speed, rough fields\nTRICUBIC 64 O(h⁴) Accuracy, smooth fields\nQUINTIC 216 O(h⁶) Highest accuracy\nADAPTIVE 8-64 Variable Mixed conditions","category":"section"},{"location":"advanced/particles/#Particle-Initialization","page":"Particle Advection","title":"Particle Initialization","text":"QGYBJ+.jl provides simple, intuitive constructors for initializing particles:\n\nConstructor Description\nparticles_in_box(z; ...) Uniform grid in a 2D rectangular box at fixed z\nparticles_in_circle(z; ...) Circular disk at fixed z (sunflower/rings/random)\nparticles_in_grid_3d(; ...) Uniform 3D rectangular grid\nparticles_in_layers(z_levels; ...) Multiple 2D grids at different z-levels\nparticles_random_3d(n; ...) Random distribution in 3D volume\nparticles_custom(positions; ...) User-specified positions\n\nNote: the vertical coordinate is z ∈ [-Lz, 0] with z = 0 at the surface. Use negative z for a positive depth (e.g., depth 2000 m → z = -2000.0).","category":"section"},{"location":"advanced/particles/#Particles-in-a-Box-(2D-at-fixed-z)","page":"Particle Advection","title":"Particles in a Box (2D at fixed z)","text":"# 100 particles (10×10) in a box at z = -2000 m (depth 2000 m)\n# NOTE: x_max, y_max are REQUIRED\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\n\n# Custom subdomain\nconfig = particles_in_box(-2000.0;\n    x_min=100e3, x_max=400e3,  # subset of domain\n    y_min=100e3, y_max=400e3,\n    nx=20, ny=20               # 400 particles\n)","category":"section"},{"location":"advanced/particles/#Particles-in-a-Circle-(2D-at-fixed-z)","page":"Particle Advection","title":"Particles in a Circle (2D at fixed z)","text":"# 100 particles in a circle of radius 1.0 at z = -π/2\nconfig = particles_in_circle(-π/2; radius=1.0, n=100)\n\n# Custom center and pattern\nconfig = particles_in_circle(-1.0;\n    center=(2.0, 2.0),        # Circle center\n    radius=1.5,\n    n=200,\n    pattern=:sunflower        # :sunflower, :rings, or :random\n)\n\nAvailable patterns:\n\n:sunflower - Fibonacci spiral (very uniform, recommended)\n:rings - Concentric rings\n:random - Uniform random within disk\n\nSingle-level distributions (like particles_in_circle and particles_custom) can use z_min == z_max.","category":"section"},{"location":"advanced/particles/#Particles-in-a-3D-Grid","page":"Particle Advection","title":"Particles in a 3D Grid","text":"# 500 particles in a 10×10×5 grid\n# NOTE: x_max, y_max, z_max are REQUIRED\nconfig = particles_in_grid_3d(; x_max=G.Lx, y_max=G.Ly, z_max=G.Lz, nx=10, ny=10, nz=5)\n\n# Custom subdomain\nconfig = particles_in_grid_3d(;\n    x_min=100e3, x_max=400e3,\n    y_min=100e3, y_max=400e3,\n    z_min=-2500.0, z_max=-500.0,\n    nx=8, ny=8, nz=4\n)","category":"section"},{"location":"advanced/particles/#Particles-in-Layers-(multiple-z-levels)","page":"Particle Advection","title":"Particles in Layers (multiple z-levels)","text":"# 300 particles at 3 z-levels (10×10 per level)\n# NOTE: x_max, y_max are REQUIRED\nconfig = particles_in_layers([-1000.0, -2000.0, -3000.0]; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\n\n# Custom horizontal subdomain\nconfig = particles_in_layers([-500.0, -1000.0, -1500.0, -2000.0];\n    x_min=100e3, x_max=400e3,\n    y_min=100e3, y_max=400e3,\n    nx=5, ny=5\n)","category":"section"},{"location":"advanced/particles/#Random-3D-Distribution","page":"Particle Advection","title":"Random 3D Distribution","text":"# 500 random particles in full domain\n# NOTE: x_max, y_max, z_max are REQUIRED\nconfig = particles_random_3d(500; x_max=G.Lx, y_max=G.Ly, z_max=G.Lz)\n\n# Custom subdomain with seed\nconfig = particles_random_3d(1000;\n    x_min=100e3, x_max=400e3,\n    y_min=100e3, y_max=400e3,\n    z_min=-2500.0, z_max=-500.0,\n    seed=42\n)","category":"section"},{"location":"advanced/particles/#Custom-Positions","page":"Particle Advection","title":"Custom Positions","text":"# Particles at specific (x, y, z) locations\nconfig = particles_custom([\n    (1.0, 1.0, -0.5),\n    (2.0, 2.0, -1.0),\n    (3.0, 1.5, -0.75),\n    (1.5, 3.0, -1.25)\n])","category":"section"},{"location":"advanced/particles/#Boundary-Conditions","page":"Particle Advection","title":"Boundary Conditions","text":"","category":"section"},{"location":"advanced/particles/#Horizontal-(Periodic)","page":"Particle Advection","title":"Horizontal (Periodic)","text":"Particles wrap around domain edges:\n\nx_new = mod(x, Lx)\ny_new = mod(y, Ly)","category":"section"},{"location":"advanced/particles/#Vertical-(Reflective)","page":"Particle Advection","title":"Vertical (Reflective)","text":"Particles bounce off top and bottom:\n\nif z > 0\n    z = -z\n    w = -w  # Reverse vertical velocity\nelseif z < -Lz\n    z = -2*Lz - z\n    w = -w\nend\n\nConfigure via:\n\nconfig = particles_in_box(-2000.0;\n    x_max=G.Lx, y_max=G.Ly,\n    periodic_x=true,\n    periodic_y=true,\n    reflect_z=true      # Reflective vertical BCs\n)","category":"section"},{"location":"advanced/particles/#Delayed-Particle-Release","page":"Particle Advection","title":"Delayed Particle Release","text":"Start advecting particles after the flow has developed:\n\nconfig = particles_in_box(-2000.0; x_max=G.Lx, y_max=G.Ly, particle_advec_time=100.0)  # Start at t=100.0\n\nParticles remain stationary until current_time >= particle_advec_time.","category":"section"},{"location":"advanced/particles/#Trajectory-Output","page":"Particle Advection","title":"Trajectory Output","text":"","category":"section"},{"location":"advanced/particles/#Save-Interval","page":"Particle Advection","title":"Save Interval","text":"Control how often positions are recorded:\n\nconfig = particles_in_box(-2000.0;\n    x_max=G.Lx, y_max=G.Ly,\n    save_interval=10.0,       # Save every 10.0 time units\n    max_save_points=1000      # Max points per file\n)","category":"section"},{"location":"advanced/particles/#Automatic-File-Splitting","page":"Particle Advection","title":"Automatic File Splitting","text":"For long simulations:\n\ntracker = ParticleTracker(config, grid)\nenable_auto_file_splitting!(tracker, \"long_run\", max_points_per_file=500)\n\n# Files created: long_run.nc, long_run_part1.nc, long_run_part2.nc, ...","category":"section"},{"location":"advanced/particles/#Writing-Trajectories","page":"Particle Advection","title":"Writing Trajectories","text":"# Standard output\nwrite_particle_trajectories(\"particles.nc\", tracker)\n\n# With metadata\nwrite_particle_trajectories(\"particles.nc\", tracker;\n    metadata = Dict(\"experiment\" => \"test1\", \"description\" => \"...\")\n)\n\n# By z-level (for layered distributions)\nwrite_particle_trajectories_by_zlevel(\"particles\", tracker)\n# Creates: particles_z0.nc, particles_z1.nc, ...","category":"section"},{"location":"advanced/particles/#Parallel-Algorithm","page":"Particle Advection","title":"Parallel Algorithm","text":"When running with MPI, particle advection uses domain decomposition.","category":"section"},{"location":"advanced/particles/#Domain-Decomposition","page":"Particle Advection","title":"Domain Decomposition","text":"The domain is split in both x and y according to the MPI process grid (px × py). Each rank owns a tile in the horizontal plane and the full z-range.\n\nExample for a 2×2 topology:\n\n┌─────────────────────────┬─────────────────────────┐\n│ Rank (0,1)               │ Rank (1,1)              │\n│ x∈[0, Lx/2), y∈[Ly/2, Ly) │ x∈[Lx/2, Lx), y∈[Ly/2, Ly) │\n├─────────────────────────┼─────────────────────────┤\n│ Rank (0,0)               │ Rank (1,0)              │\n│ x∈[0, Lx/2), y∈[0, Ly/2)  │ x∈[Lx/2, Lx), y∈[0, Ly/2)  │\n└─────────────────────────┴─────────────────────────┘\n\nParticles belong to the rank that owns their (x, y) position.","category":"section"},{"location":"advanced/particles/#Halo-Exchange","page":"Particle Advection","title":"Halo Exchange","text":"For interpolation near domain boundaries, velocity data is exchanged between neighbors:\n\n┌─────────────────────────────────────────────────────────────┐\n│                     HALO EXCHANGE                           │\n│                                                             │\n│   Rank 0                        Rank 1                      │\n│   ┌─────────────────┐          ┌─────────────────┐          │\n│   │ Local │  Right  │          │ Left  │ Local   │          │\n│   │ Data  │  Halo   │  ←────→  │ Halo  │ Data    │          │\n│   │       │ (ghost) │          │(ghost)│         │          │\n│   └───────┴─────────┘          └───────┴─────────┘          │\n│                                                             │\n│   • Rank 0 sends RIGHT edge → Rank 1's LEFT halo            │\n│   • Rank 1 sends LEFT edge  → Rank 0's RIGHT halo           │\n│                                                             │\n│   Halo width depends on interpolation: 1 (trilinear), 2     │\n│   (tricubic), 3 (quintic/adaptive)                          │\n└─────────────────────────────────────────────────────────────┘\n\nFor 2D topologies (py > 1), halos are exchanged in both x and y directions, including corner halos needed by wider stencils.","category":"section"},{"location":"advanced/particles/#Particle-Migration","page":"Particle Advection","title":"Particle Migration","text":"When particles cross domain boundaries, they are transferred:\n\n┌─────────────────────────────────────────────────────────────┐\n│                   PARTICLE MIGRATION                        │\n│                                                             │\n│   1. After advection, check each particle's position        │\n│   2. If (x,y) outside local domain → pack into send buffer  │\n│   3. MPI.Alltoall to exchange particle counts               │\n│   4. MPI.Send/Recv to transfer particle data                │\n│   5. Unpack received particles into local collection        │\n│                                                             │\n│   Particle data transferred: [x, y, z, u, v, w]             │\n└─────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/particles/#Parallel-Timestep-Workflow","page":"Particle Advection","title":"Parallel Timestep Workflow","text":"┌───────────────────────────────────────────────────────────────┐\n│                  PARALLEL ADVECTION TIMESTEP                  │\n│                                                               │\n│  1. UPDATE VELOCITY FIELDS                                    │\n│     • Compute QG velocities (distributed FFT)                 │\n│     • Solve omega equation (tridiagonal in z)                 │\n│     • Add wave Stokes drift                                   │\n│     • Exchange velocity halos in x/y (and corners for 2D)     │\n│                              ↓                                │\n│  2. ADVECT PARTICLES (each rank processes local particles)    │\n│     • Interpolate velocity (use halo for boundary particles)  │\n│     • Time integration (Euler/RK2/RK4)                        │\n│                              ↓                                │\n│  3. MIGRATE PARTICLES                                         │\n│     • Identify particles that left local domain               │\n│     • Exchange particle data between ranks (MPI)              │\n│                              ↓                                │\n│  4. APPLY BOUNDARY CONDITIONS                                 │\n│     • Periodic wrap in x, y                                   │\n│     • Reflective bounce in z                                  │\n│                              ↓                                │\n│  5. SAVE TRAJECTORIES (if save_interval reached)              │\n│     • Each rank saves local particles, or                     │\n│     • Gather to rank 0 for unified output                     │\n└───────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/particles/#Using-Parallel-Particles","page":"Particle Advection","title":"Using Parallel Particles","text":"using MPI\nusing QGYBJplus\n\nMPI.Init()\n\n# Set up parallel configuration\nparallel_config = setup_mpi_environment()\n\n# Create particle tracker with parallel support\ntracker = ParticleTracker(particle_config, sim.grid, parallel_config)\ninitialize_particles!(tracker, particle_config)\n\n# Advection automatically handles:\n# - Halo exchange for boundary interpolation\n# - Particle migration between ranks\nfor step in 1:nsteps\n    timestep!(sim)\n    advect_particles!(tracker, sim.state, sim.grid, dt, sim.current_time)\nend\n\nMPI.Finalize()","category":"section"},{"location":"advanced/particles/#Key-Data-Structures","page":"Particle Advection","title":"Key Data Structures","text":"","category":"section"},{"location":"advanced/particles/#ParticleConfig","page":"Particle Advection","title":"ParticleConfig","text":"struct ParticleConfig{T}\n    # Spatial domain\n    x_min, x_max, y_min, y_max::T\n    z_level::T\n\n    # Particle count\n    nx_particles, ny_particles::Int\n\n    # Physics\n    use_ybj_w::Bool           # YBJ vs QG vertical velocity\n    use_3d_advection::Bool    # Include vertical advection\n\n    # Timing\n    particle_advec_time::T    # Delayed start time\n\n    # Numerics\n    integration_method::Symbol        # :euler, :rk2, :rk4\n    interpolation_method::InterpolationMethod  # TRILINEAR, etc.\n\n    # Boundaries\n    periodic_x, periodic_y::Bool\n    reflect_z::Bool\n\n    # I/O\n    save_interval::T\n    max_save_points::Int\n    auto_split_files::Bool\nend","category":"section"},{"location":"advanced/particles/#ParticleTracker","page":"Particle Advection","title":"ParticleTracker","text":"mutable struct ParticleTracker{T}  # Simplified view (omits I/O bookkeeping)\n    config::ParticleConfig{T}\n    particles::ParticleState{T}   # x, y, z, id, u, v, w arrays\n\n    # Grid info\n    nx, ny, nz::Int\n    Lx, Ly, Lz, dx, dy, dz::T\n\n    # Velocity workspace\n    u_field, v_field, w_field::Array{T,3}\n\n    # MPI info (for parallel)\n    comm, rank, nprocs, is_parallel\n    local_domain::NamedTuple  # x/y bounds, local sizes, topology info\n    halo_info::HaloInfo{T}\n    send_buffers, recv_buffers::Vector{Vector{T}}\n    is_io_rank::Bool\n    gather_for_io::Bool\nend","category":"section"},{"location":"advanced/particles/#Performance-Considerations","page":"Particle Advection","title":"Performance Considerations","text":"Aspect Serial Parallel\nVelocity computation O(N) O(N/P) per rank\nInterpolation O(Np × stencil) O(Np/P × stencil)\nHalo exchange N/A O((nxlocal + nylocal) × nz × halo_width)\nMigration N/A O(Np_crossing)\n\nTips:\n\nUse TRILINEAR for speed, TRICUBIC for accuracy\nRK4 costs 4× more than Euler but is much more accurate\nHalo exchange overhead is small for typical particle counts\nMigration cost depends on flow strength near boundaries","category":"section"},{"location":"advanced/particles/#Visualization","page":"Particle Advection","title":"Visualization","text":"","category":"section"},{"location":"advanced/particles/#Plot-Particle-Positions","page":"Particle Advection","title":"Plot Particle Positions","text":"using Plots\n\n# 2D scatter plot\nscatter(tracker.particles.x, tracker.particles.y,\n    markersize=2, alpha=0.6,\n    xlabel=\"x\", ylabel=\"y\",\n    title=\"Particle Distribution\"\n)","category":"section"},{"location":"advanced/particles/#Plot-Trajectories","page":"Particle Advection","title":"Plot Trajectories","text":"# Load saved trajectories\nusing NCDatasets\nds = NCDataset(\"particles.nc\")\nx_hist = ds[\"x\"][:]  # (np, ntime)\ny_hist = ds[\"y\"][:]\nclose(ds)\n\n# Plot first 50 particle tracks\np = plot(legend=false)\nfor i in 1:50\n    plot!(p, x_hist[i,:], y_hist[i,:], alpha=0.3)\nend\ndisplay(p)","category":"section"},{"location":"advanced/particles/#Animation","page":"Particle Advection","title":"Animation","text":"anim = @animate for t in 1:10:size(x_hist, 2)\n    scatter(x_hist[:,t], y_hist[:,t],\n        markersize=2, xlim=(0,2π), ylim=(0,2π),\n        title=\"t = $(t)\")\nend\ngif(anim, \"particles.gif\", fps=20)","category":"section"},{"location":"advanced/particles/#API-Reference","page":"Particle Advection","title":"API Reference","text":"See the Particle API Reference for complete documentation of:\n\nTypes:\n\nParticleConfig - Configuration options\nParticleState - Particle positions, IDs, and velocities\nParticleTracker - Main tracking object\n\nInitialization Constructors:\n\nparticles_in_box - 2D box at fixed z-level\nparticles_in_circle - Circular disk at fixed z-level\nparticles_in_grid_3d - Uniform 3D grid\nparticles_in_layers - Multiple z-levels\nparticles_random_3d - Random 3D distribution\nparticles_custom - User-specified positions\n\nCore Functions:\n\ninitialize_particles! - Initialize particle positions\nadvect_particles! - Advect particles one timestep\ninterpolate_velocity_at_position - Velocity interpolation\nwrite_particle_trajectories - Save to NetCDF","category":"section"},{"location":"api/timestepping/#api-timestepping","page":"Time Stepping","title":"Time Stepping","text":"This page documents the time integration functions.","category":"section"},{"location":"api/timestepping/#Available-Time-Stepping-Schemes","page":"Time Stepping","title":"Available Time Stepping Schemes","text":"QGYBJ+.jl provides two time stepping methods:\n\nMethod Description When to Use\nLeapfrog Explicit, 2nd order Default, dt ≤ 2f/N² (~2s)\nIMEX-CN Implicit dispersion, explicit advection Large dt (~20s), 10x speedup","category":"section"},{"location":"api/timestepping/#Choosing-a-Method","page":"Time Stepping","title":"Choosing a Method","text":"Use the timestepper keyword in run_simulation!:\n\n# Leapfrog (default, explicit)\nrun_simulation!(S, G, par, plans; timestepper=:leapfrog, ...)\n\n# IMEX Crank-Nicolson (implicit dispersion)\nrun_simulation!(S, G, par, plans; timestepper=:imex_cn, ...)\n\n","category":"section"},{"location":"api/timestepping/#Leapfrog-Scheme-(Default)","page":"Time Stepping","title":"Leapfrog Scheme (Default)","text":"The Leapfrog scheme with Robert-Asselin filter provides second-order accuracy with computational mode damping.","category":"section"},{"location":"api/timestepping/#Overview","page":"Time Stepping","title":"Overview","text":"The time stepping consists of two functions:\n\nfirst_projection_step! - Forward Euler initialization\nleapfrog_step! - Main leapfrog integration with Robert-Asselin filter","category":"section"},{"location":"api/timestepping/#Forward-Euler-Projection-Step","page":"Time Stepping","title":"Forward Euler Projection Step","text":"Purpose: Initialize the leapfrog scheme by providing values at times n and n-1.\n\nAlgorithm:\n\nCompute tendencies at time n (advection, refraction, diffusion)\nApply physics switches (linear, inviscid, etc.)\nForward Euler update with integrating factors\nWave feedback (optional)\nDiagnostic inversions (q → ψ → u, v)\n\nUsage:\n\n# Serial mode\nfirst_projection_step!(state, grid, params, plans; a=a_ell, dealias_mask=L)\n\n# Parallel mode (2D decomposition)\nfirst_projection_step!(state, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)","category":"section"},{"location":"api/timestepping/#Leapfrog-Step-with-Robert-Asselin-Filter","page":"Time Stepping","title":"Leapfrog Step with Robert-Asselin Filter","text":"The Leapfrog scheme:\n\nphi^n+1 = phi^n-1 + 2Delta t times F^n\n\nRobert-Asselin filter (damps computational mode):\n\ntildephi^n = phi^n + gamma(phi^n-1 - 2phi^n + phi^n+1)\n\nWith integrating factor for hyperdiffusion:\n\nphi^n+1 = phi^n-1 times e^-2lambdaDelta t + 2Delta t times F^n times e^-lambdaDelta t\n\nUsage:\n\n# Serial mode\nleapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L)\n\n# Parallel mode (2D decomposition)\nleapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)\n\n# Time level rotation after each step\nSnm1, Sn, Snp1 = Sn, Snp1, Snm1","category":"section"},{"location":"api/timestepping/#Forward-Euler-Update","page":"Time Stepping","title":"Forward Euler Update","text":"Used for the first (projection) step:\n\nphi^n+1 = leftphi^n - Delta t times Fright times e^-lambdaDelta t\n\nThe integrating factor e^{-λΔt} handles hyperdiffusion exactly.","category":"section"},{"location":"api/timestepping/#Tendency-Computation","page":"Time Stepping","title":"Tendency Computation","text":"Each time step computes the following tendencies:\n\nQG Potential Vorticity:\n\nF_q = -J(psi q) + nu_z fracpartial^2 qpartial z^2\n\nWave Envelope (complex form, YBJ+):\n\nF_B = -J(psi B) + ialpha_textdispk_h^2 A - fraci2zeta B\n\nEquivalent real/imaginary parts:\n\nF_BR = -J(psi BR) - frack_h^22A_I + frac12BI times zeta\n\nF_BI = -J(psi BI) + frack_h^22A_R - frac12BR times zeta","category":"section"},{"location":"api/timestepping/#Nonlinear-Terms","page":"Time Stepping","title":"Nonlinear Terms","text":"Advection:\n\nconvol_waqg_q! computes J(ψ, q)\nconvol_waqg_B! computes J(ψ, B) for the complex YBJ+ envelope\nconvol_waqg! computes J(ψ, q), J(ψ, BR), J(ψ, BI) for explicit BR/BI decomposition\n\nRefraction:\n\nrefraction_waqg_B! computes ζ × B for complex B\nrefraction_waqg! computes BR × ζ and BI × ζ for the decomposed form\n\nWave feedback:\n\ncompute_qw_complex! computes qʷ directly from complex B\ncompute_qw! computes qʷ from BR/BI","category":"section"},{"location":"api/timestepping/#Vertical-Diffusion","page":"Time Stepping","title":"Vertical Diffusion","text":"Computes νz ∂²q/∂z² using the tridiagonal solver. Automatically handles 2D decomposition transposes.","category":"section"},{"location":"api/timestepping/#Integrating-Factors","page":"Time Stepping","title":"Integrating Factors","text":"","category":"section"},{"location":"api/timestepping/#Purpose","page":"Time Stepping","title":"Purpose","text":"For stiff hyperdiffusion terms, we use an integrating factor approach:\n\ntildephi = phi times e^nu k^2p t\n\nThis allows exact treatment of the linear diffusion while using explicit time stepping.","category":"section"},{"location":"api/timestepping/#Function","page":"Time Stepping","title":"Function","text":"Usage:\n\n# Compute factor for a spectral mode\nIf = int_factor(kx, ky, params; waves=false)   # For mean flow (q)\nIfw = int_factor(kx, ky, params; waves=true)   # For waves (B)\n\n# Apply in time stepping\nq_new = q_old * exp(-2*If) - 2*dt * tendency * exp(-If)   # Leapfrog\nq_new = q_old * exp(-If) - dt * tendency                    # Euler","category":"section"},{"location":"api/timestepping/#Complete-Simulation-Loop","page":"Time Stepping","title":"Complete Simulation Loop","text":"","category":"section"},{"location":"api/timestepping/#Setup-and-Run","page":"Time Stepping","title":"Setup and Run","text":"using QGYBJplus\n\n# Initialize\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\ngrid = init_grid(params)\nplans = plan_transforms!(grid)\na_ell = a_ell_ut(params, grid)\nL = dealias_mask(grid)\n\n# Create three state arrays for leapfrog\nSnm1 = init_state(grid)  # n-1\nSn = init_state(grid)    # n\nSnp1 = init_state(grid)  # n+1\n\n# Initialize with random fields\ninit_random_psi!(Sn, grid, params, plans; a=a_ell)\n\n# Projection step (Forward Euler initialization)\nfirst_projection_step!(Sn, grid, params, plans; a=a_ell, dealias_mask=L)\n\n# Copy for n-1 state\ncopy_state!(Snm1, Sn)\n\n# Main time loop\nfor iter in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L)\n\n    # Rotate time levels\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend","category":"section"},{"location":"api/timestepping/#Parallel-Mode-(2D-Decomposition)","page":"Time Stepping","title":"Parallel Mode (2D Decomposition)","text":"using MPI, PencilArrays, PencilFFTs, QGYBJplus\n\nMPI.Init()\nmpi_config = QGYBJplus.setup_mpi_environment()\n\n# Initialize with MPI\nparams = default_params(Lx=1000e3, Ly=1000e3, Lz=5000.0, nx=256, ny=256, nz=128)\ngrid = QGYBJplus.init_mpi_grid(params, mpi_config)\nplans = QGYBJplus.plan_mpi_transforms(grid, mpi_config)\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)\n\na_ell = a_ell_ut(params, grid)\nL = dealias_mask(grid)\n\n# Create states\nSnm1 = QGYBJplus.init_mpi_state(grid, plans, mpi_config)\nSn = QGYBJplus.init_mpi_state(grid, plans, mpi_config)\nSnp1 = QGYBJplus.init_mpi_state(grid, plans, mpi_config)\n\n# Initialize\ninit_random_psi!(Sn, grid, params, plans; a=a_ell)\nfirst_projection_step!(Sn, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)\ncopy_state!(Snm1, Sn)\n\n# Main loop with workspace for 2D decomposition\nfor iter in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans;\n                   a=a_ell, dealias_mask=L, workspace=workspace)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\nMPI.Finalize()","category":"section"},{"location":"api/timestepping/#CFL-Condition","page":"Time Stepping","title":"CFL Condition","text":"","category":"section"},{"location":"api/timestepping/#Stability-Constraint","page":"Time Stepping","title":"Stability Constraint","text":"function compute_cfl(state, grid, dt)\n    u_max = maximum(abs.(state.u))\n    v_max = maximum(abs.(state.v))\n    return dt * max(u_max/grid.dx, v_max/grid.dy)\nend\n\nFor stability, CFL < 1 is required. Recommended: CFL ≈ 0.5.","category":"section"},{"location":"api/timestepping/#Adaptive-Time-Stepping","page":"Time Stepping","title":"Adaptive Time Stepping","text":"function adaptive_dt(state, grid; cfl_target=0.5, dt_max=0.01)\n    u_max = maximum(abs.(state.u)) + 1e-10  # Avoid division by zero\n    v_max = maximum(abs.(state.v)) + 1e-10\n\n    dt = cfl_target * min(grid.dx/u_max, grid.dy/v_max)\n    return min(dt, dt_max)\nend","category":"section"},{"location":"api/timestepping/#Robert-Asselin-Filter-Parameter","page":"Time Stepping","title":"Robert-Asselin Filter Parameter","text":"The filter coefficient γ (γ in QGParams) controls damping of the computational mode:\n\nToo large (γ > 0.01): Excessive damping, accuracy loss\nToo small (γ < 0.0001): Computational mode growth\nRecommended: γ ≈ 0.001 (default)\n\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32, γ=0.001)\n\nNote: Type \\gamma<tab> in the Julia REPL to enter γ.","category":"section"},{"location":"api/timestepping/#Time-Level-Management","page":"Time Stepping","title":"Time Level Management","text":"The leapfrog scheme requires three time levels:\n\nVariable Description Usage\nSnm1 State at n-1 Input, receives filtered n values\nSn State at n Input (unchanged)\nSnp1 State at n+1 Output\n\nAfter each step, rotate the pointers:\n\nSnm1, Sn, Snp1 = Sn, Snp1, Snm1\n\nThis avoids data copying by just swapping references.","category":"section"},{"location":"api/timestepping/#Physics-Switches","page":"Time Stepping","title":"Physics Switches","text":"The time stepping respects these QGParams switches:\n\nSwitch Effect\nlinear Zero nonlinear advection J(ψ, q), J(ψ, B)\ninviscid Zero vertical diffusion νz ∂²q/∂z²\npassive_scalar Waves as passive tracers (no dispersion/refraction)\nno_dispersion Zero wave dispersion (A = 0)\nfixed_flow Mean flow doesn't evolve (q unchanged)\nno_wave_feedback No qʷ feedback term","category":"section"},{"location":"api/timestepping/#Performance","page":"Time Stepping","title":"Performance","text":"","category":"section"},{"location":"api/timestepping/#Timing-Breakdown","page":"Time Stepping","title":"Timing Breakdown","text":"Typical distribution: | Component | Fraction | |:–––––|:––––-| | FFTs | 40-50% | | Elliptic solves | 20-30% | | Array operations | 15-25% | | Transpose operations (2D) | 5-10% |","category":"section"},{"location":"api/timestepping/#2D-Decomposition-Notes","page":"Time Stepping","title":"2D Decomposition Notes","text":"When using 2D decomposition:\n\nPass workspace argument to avoid repeated allocation\nVertical operations (inversions, diffusion) use automatic transposes\nThe workspace contains pre-allocated z-pencil arrays\n\n# Pre-allocate workspace (once)\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)\n\n# Reuse for all steps\nfor step in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans;\n                   a=a, dealias_mask=L, workspace=workspace)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\n","category":"section"},{"location":"api/timestepping/#IMEX-Crank-Nicolson-Scheme","page":"Time Stepping","title":"IMEX Crank-Nicolson Scheme","text":"The IMEX-CNAB scheme (Crank-Nicolson for implicit terms, Adams-Bashforth 2 for explicit terms) treats dispersion implicitly for unconditional stability, allowing timesteps ~10x larger than leapfrog.","category":"section"},{"location":"api/timestepping/#Why-IMEX-CNAB?","page":"Time Stepping","title":"Why IMEX-CNAB?","text":"The YBJ+ wave equation has three terms with different timescales:\n\nAdvection: J(ψ,B) - slow, O(hours)\nRefraction: (i/2)ζB - moderate, O(minutes)\nDispersion: i·αdisp·kₕ²·A - fast, CFL-limited to dt ≤ 2f/N² (~2s)\n\nIMEX-CNAB treats dispersion implicitly with Crank-Nicolson, removing the stiff CFL constraint.","category":"section"},{"location":"api/timestepping/#Algorithm:-Strang-Splitting-IMEX-CNAB","page":"Time Stepping","title":"Algorithm: Strang Splitting + IMEX-CNAB","text":"The scheme uses Strang splitting for refraction (second-order accurate) combined with IMEX-CNAB for advection/dispersion:\n\nStage 1 (First Half-Refraction - Strang):\n\nB^* = B^n times expleft(-i fracDelta t2 fraczeta2right)\n\nApplied in physical space with exact integrating factor (energy-preserving).\n\nStage 2 (IMEX-CNAB for Advection + Dispersion):\n\nB^** = B^* + fracDelta t2D^* + D^** + Delta t leftfrac32N^n - frac12N^n-1right\n\nwhere:\n\nD = i·αdisp·kₕ²·A (dispersion, treated implicitly with Crank-Nicolson)\nN = -J(ψ,B) (advection, treated explicitly with Adams-Bashforth 2)\n\nStage 3 (Second Half-Refraction - Strang):\n\nB^n+1 = B^** times expleft(-i fracDelta t2 fraczeta2right)\n\nThe symmetric half-steps ensure second-order accuracy in time.","category":"section"},{"location":"api/timestepping/#Functions","page":"Time Stepping","title":"Functions","text":"","category":"section"},{"location":"api/timestepping/#Usage","page":"Time Stepping","title":"Usage","text":"# Initialize IMEX workspace\nimex_ws = init_imex_workspace(state, grid)\nSnp1 = copy_state(state)\n\n# Time stepping loop\nfor step in 1:nsteps\n    imex_cn_step!(Snp1, Sn, grid, params, plans, imex_ws;\n                  a=a_ell, dealias_mask=L, workspace=workspace,\n                  N2_profile=N2_profile)\n\n    # Copy for next step (only need 2 time levels, not 3 like leapfrog)\n    parent(Sn.B) .= parent(Snp1.B)\n    parent(Sn.A) .= parent(Snp1.A)\n    parent(Sn.q) .= parent(Snp1.q)\n    parent(Sn.psi) .= parent(Snp1.psi)\nend","category":"section"},{"location":"api/timestepping/#Stability-Properties","page":"Time Stepping","title":"Stability Properties","text":"Term Treatment Stability\nRefraction Exact integrating factor (Strang split) Unconditionally stable\nDispersion Implicit Crank-Nicolson Unconditionally stable\nAdvection Explicit Adams-Bashforth 2 CFL: dt < dx/U_max\n\nFor U = 0.335 m/s and dx ≈ 273m (256 grid, 70km domain): dt_max ≈ 800s\n\nThis allows dt = 20s (vs dt = 2s for leapfrog), a 10x speedup.","category":"section"},{"location":"api/timestepping/#Key-Implementation-Details","page":"Time Stepping","title":"Key Implementation Details","text":"Strang Splitting: Refraction is split symmetrically with two half-steps: exp(-i·(dt/2)·ζ/2) before and after the IMEX solve\nAdams-Bashforth 2: Advection uses (3/2)N^n - (1/2)N^{n-1} extrapolation for both q and B (bootstraps with forward Euler on first step)\n**Consistent A***: After first half-refraction, A* = (L⁺)⁻¹B* is computed (critical for IMEX-CN consistency)\nModified Elliptic Solve: Each mode solves (L⁺ - β)·A^{n+1} = RHS where β = (dt/2)·i·αdisp·kₕ²\nUpdated Refraction: The second refraction half-step uses a ψ^{n+1} predictor (with q^w when enabled) to keep the coupled system second-order","category":"section"},{"location":"api/timestepping/#When-to-Use","page":"Time Stepping","title":"When to Use","text":"Use IMEX-CN when dispersion CFL is limiting (typical oceanographic simulations)\nUse Leapfrog for academic tests requiring exact 2nd-order temporal accuracy\n\n","category":"section"},{"location":"api/timestepping/#API-Summary","page":"Time Stepping","title":"API Summary","text":"All time stepping functions documented above:\n\nLeapfrog:\n\nfirst_projection_step! - Forward Euler initialization step\nleapfrog_step! - Main leapfrog integration with Robert-Asselin filter\n\nIMEX-CN:\n\ninit_imex_workspace - Allocate IMEX workspace arrays\nimex_cn_step! - IMEX Crank-Nicolson step with operator splitting\nfirst_imex_step! - First-order forward Euler initialization\n\nCommon:\n\nconvol_waqg_q! / convol_waqg_B! - Complex-form advection for q and B\nrefraction_waqg_B! - Complex-form wave refraction term\nconvol_waqg! / refraction_waqg! - BR/BI-decomposed advection/refraction\ndissipation_q_nv! - Vertical diffusion\nint_factor - Integrating factor for hyperdiffusion\ncompute_qw_complex! / compute_qw! - Wave feedback term (see Physics API)","category":"section"},{"location":"api/timestepping/#QGYBJplus.first_projection_step!","page":"Time Stepping","title":"QGYBJplus.first_projection_step!","text":"first_projection_step!(S, G, par, plans; a, dealias_mask=nothing, workspace=nothing, N2_profile=nothing)\n\nForward Euler initialization step for the leapfrog time stepper.\n\nPurpose\n\nThe leapfrog scheme requires values at two time levels (n and n-1). This function takes the initial state and advances it by one Forward Euler step, providing the needed second time level.\n\nAlgorithm\n\nCompute tendencies at time n:\nAdvection of q and B by geostrophic flow\nWave refraction by vorticity\nVertical diffusion\nApply physics switches:\nlinear: Zero nonlinear advection\ninviscid: Zero dissipation\npassive_scalar: Zero dispersion and refraction\nfixed_flow: Mean flow doesn't evolve\nForward Euler update: For each spectral mode:\nq^(n+1) = [q^n - dt × tendency_q + dt × diffusion] × exp(-λ_q × dt)\nB^(n+1) = [B^n - dt × tendency_B] × exp(-λ_B × dt)\nwhere λ is the hyperdiffusion factor.\nWave feedback (optional):\nq* = q - qʷ\nDiagnostic inversions:\nq → ψ (elliptic inversion)\nB → A, C (YBJ+ inversion)\nψ → u, v (velocity computation)\n\nArguments\n\nS::State: State to advance (modified in place)\nG::Grid: Grid struct\npar::QGParams: Model parameters\nplans: FFT plans\na: Elliptic coefficient array a_ell(z) = f²/N²\ndealias_mask: Optional 2/3 dealiasing mask (nx × ny)\nworkspace: Optional pre-allocated workspace for 2D decomposition\nN2_profile: Optional N²(z) profile for vertical velocity computation\n\nReturns\n\nModified state S at time n+1.\n\nFortran Correspondence\n\nThis matches the projection step in main_waqg.f90.\n\nExample\n\n# Initialize and run projection step\nstate = init_state(grid)\ninit_random_psi!(state, grid)\na = a_ell_ut(params, grid)\nL = dealias_mask(grid)\nfirst_projection_step!(state, grid, params, plans; a=a, dealias_mask=L)\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.leapfrog_step!","page":"Time Stepping","title":"QGYBJplus.leapfrog_step!","text":"leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a, dealias_mask=nothing, workspace=nothing, N2_profile=nothing)\n\nAdvance the solution by one leapfrog time step with Robert-Asselin filtering.\n\nAlgorithm\n\n1. Compute tendencies at time n:\n\nF_q^n = J(ψ^n, q^n) - νz∂²q^(n-1)/∂z²\nF_B^n = J(ψ^n, B^n) + dispersion + refraction\n\n2. Leapfrog update with integrating factors: For each spectral mode (k):\n\nq^(n+1) = q^(n-1) × e^(-2λdt) + 2dt × [-J(ψ,q)^n + diff^n] × e^(-λdt)\nB^(n+1) = B^(n-1) × e^(-2λdt) + 2dt × [-J(ψ,B)^n + dispersion + refraction] × e^(-λdt)\n\nNote: All tendencies are evaluated at time n and scaled by e^(-λdt) for second-order accuracy.\n\n3. Robert-Asselin filter:\n\nq̃^n = q^n + γ(q^(n-1) - 2q^n + q^(n+1))\nB̃^n = B^n + γ(B^(n-1) - 2B^n + B^(n+1))\n\nThe filtered values are stored in Sn (which becomes Snm1 after rotation).\n\n4. Wave feedback (if enabled):\n\nq*^(n+1) = q^(n+1) - qʷ^(n+1)\n\n5. Diagnostic inversions:\n\nq^(n+1) → ψ^(n+1)\nB^(n+1) → A^(n+1), C^(n+1)\nψ^(n+1) → u^(n+1), v^(n+1)\n\nArguments\n\nSnp1::State: State at time n+1 (output)\nSn::State: State at time n (input, filter applied to Snm1)\nSnm1::State: State at time n-1 (input, receives filtered values)\nG::Grid: Grid struct\npar::QGParams: Model parameters\nplans: FFT plans\na: Elliptic coefficient array\ndealias_mask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\nN2_profile: Optional N²(z) profile for vertical velocity computation\n\nReturns\n\nModified Snp1 with solution at time n+1.\n\nTime Level Management\n\nAfter this call:\n\nSnp1 contains fields at n+1\nSn contains filtered fields at n (becomes new n-1 after rotation)\nSnm1 is unchanged (will be overwritten after rotation)\n\nTypical loop structure:\n\nfor iter in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a)\n    # Rotate: Snm1 ← Sn, Sn ← Snp1\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\nFortran Correspondence\n\nThis matches the main leapfrog loop in main_waqg.f90.\n\nExample\n\n# After projection step, run leapfrog\nfor iter in 1:1000\n    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a, dealias_mask=L)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.convol_waqg!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.convol_waqg!","text":"convol_waqg!(nqk, nBRk, nBIk, u, v, qk, BRk, BIk, G, plans; Lmask=nothing)\n\nCompute advection terms in divergence form, matching Fortran convol_waqg.\n\nMathematical Form\n\nUses the divergence form of the Jacobian:\n\nJ(ψ, q) = ∂(uq)/∂x + ∂(vq)/∂y\n\nwhere u, v are the geostrophic velocities (in real space).\n\nOutput\n\nnqk:  Ĵ(ψ, q) - advection of QGPV\nnBRk: Ĵ(ψ, BR) - advection of wave real part\nnBIk: Ĵ(ψ, BI) - advection of wave imaginary part\n\nArguments\n\nnqk, nBRk, nBIk: Output arrays (spectral)\nu, v: Real-space velocity arrays (precomputed)\nqk, BRk, BIk: Input fields (spectral)\nG::Grid: Grid struct\nplans: FFT plans\nLmask: Dealiasing mask (true = keep mode, false = zero)\n\nAlgorithm\n\nFor each field χ ∈ {q, BR, BI}:\n\nTransform χ̂ → χ (inverse FFT)\nCompute uχ and vχ (pointwise in real space)\nTransform back: (ûχ), (v̂χ)\nCompute divergence: ikₓ(ûχ) + ikᵧ(v̂χ)\nApply dealiasing mask\n\nFortran Correspondence\n\nThis matches convol_waqg in derivatives.f90.\n\nNote\n\nThe velocities u, v should be precomputed and passed in real space.\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.convol_waqg_q!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.convol_waqg_q!","text":"convol_waqg_q!(nqk, u, v, qk, G, plans; Lmask=nothing)\n\nCompute advection of q using divergence form without splitting wave fields.\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.convol_waqg_B!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.convol_waqg_B!","text":"convol_waqg_B!(nBk, u, v, Bk, G, plans; Lmask=nothing)\n\nCompute advection of complex B directly (YBJ+ path).\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.refraction_waqg!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.refraction_waqg!","text":"refraction_waqg!(rBRk, rBIk, BRk, BIk, psik, G, plans; Lmask=nothing)\n\nCompute wave refraction term: B × ζ where ζ = ∇²ψ is relative vorticity.\n\nPhysical Interpretation\n\nNear-inertial waves are refracted by vorticity gradients:\n\nAnticyclones (ζ < 0): Wave focusing, amplitude increase\nCyclones (ζ > 0): Wave defocusing, amplitude decrease\n\nThis is the \"wave capture\" mechanism that traps NIWs in anticyclonic eddies.\n\nMathematical Form\n\nrefraction = B × ζ\n\nwhere ζ = ∇²ψ = -kₕ²ψ̂ in spectral space.\n\nOutput\n\nrBRk: Real part of refraction term (spectral)\nrBIk: Imaginary part of refraction term (spectral)\n\nAlgorithm\n\nCompute ζ̂ = -kₕ²ψ̂ (spectral)\nTransform ζ̂, B̂R, B̂I to real space\nCompute products: rBR = ζ × BR, rBI = ζ × BI\nTransform back and apply dealiasing\n\nFortran Correspondence\n\nThis matches refraction_waqg in derivatives.f90.\n\nExample\n\nrefraction_waqg!(rBR, rBI, BR, BI, psi, grid, plans; Lmask=L)\n# rBR, rBI now contain the refraction tendencies\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.refraction_waqg_B!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.refraction_waqg_B!","text":"refraction_waqg_B!(rBk, Bk, ψₖ, G, plans; Lmask=nothing)\n\nCompute wave refraction term ζ*B directly for complex B (YBJ+ path).\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.compute_qw!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.compute_qw!","text":"compute_qw!(qwk, BRk, BIk, par, G, plans; Lmask=nothing)\n\nCompute wave feedback on mean flow: qʷ from wave field B.\n\nPhysical Interpretation\n\nThe wave feedback qʷ represents how near-inertial waves modify the quasi-geostrophic flow. This is a key component of wave-mean flow interaction in the QG-YBJ+ model.\n\nMathematical Form (Xie & Vanneste 2015)\n\nFor dimensional equations where B has velocity units [m/s]:\n\nqʷ = (i/2f)J(B*, B) + (1/4f)∇²|B|²\n\nwhere:\n\nB* is the complex conjugate of B\nJ(B, B) = BₓBᵧ - B*ᵧBₓ is the Jacobian\n|B|² = BR² + BI² is the wave energy density\n\nNo W2F scaling is applied since B already has its actual dimensional amplitude.\n\nDecomposition\n\nLet B = BR + i×BI. Then:\n\nJ(B*, B) = 2i(BRₓBIᵧ - BRᵧBIₓ) [purely imaginary]\n∇²|B|² = ∇²(BR² + BI²)\n\nThe final qʷ is real-valued after combining terms.\n\nArguments\n\nqwk: Output array for q̂ʷ (spectral)\nBRk, BIk: Wave field components (spectral)\npar: QGParams\nG::Grid: Grid struct\nplans: FFT plans\nLmask: Dealiasing mask (true = keep mode, false = zero)\n\nExample\n\ncompute_qw!(qw, BR, BI, params, grid, plans; Lmask=L)\n# qw now contains wave feedback term\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.compute_qw_complex!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.compute_qw_complex!","text":"compute_qw_complex!(qʷₖ, Bk, par, G, plans; Lmask=nothing)\n\nCompute wave feedback directly from complex B without spectral BR/BI splitting.\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.dissipation_q_nv!","page":"Time Stepping","title":"QGYBJplus.Nonlinear.dissipation_q_nv!","text":"dissipation_q_nv!(dqk, qok, par, G; workspace=nothing)\n\nCompute vertical diffusion of q with Neumann boundary conditions.\n\nMathematical Form\n\nD = νz ∂²q/∂z²\n\nwith ∂q/∂z = 0 at z = -Lz and z = 0.\n\nDiscretization\n\nInterior points (1 < k < nz):     D[k] = νz (q[k+1] - 2q[k] + q[k-1]) / dz²\n\nBoundary points (Neumann):     D[1]  = νz (q[2] - q[1]) / dz²     D[nz] = νz (q[nz-1] - q[nz]) / dz²\n\nArguments\n\ndqk: Output array for diffusion term\nqok: Input q field at time n-1 (for leapfrog)\npar: QGParams (for nuz coefficient)\nG::Grid: Grid struct\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nNote\n\nThis operates on spectral q but the vertical derivative is in physical space, so the operation is the same for each (kx, ky) mode.\n\nFortran Correspondence\n\nThis matches dissipation_q_nv in derivatives.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.Nonlinear.int_factor","page":"Time Stepping","title":"QGYBJplus.Nonlinear.int_factor","text":"int_factor(kx, ky, par; waves=false)\n\nCompute hyperdiffusion integrating factor for given wavenumber.\n\nMathematical Background\n\nThe hyperdiffusion operator is:\n\nD = -ν₁(-∇²)^n₁ - ν₂(-∇²)^n₂\n\nIn spectral space, this becomes multiplication by:\n\nλ = ν₁|k|^(2n₁) + ν₂|k|^(2n₂)\n\nThe integrating factor for one time step is: exp(-λ×dt)\n\nFor efficiency, we return just λ×dt (the exponent).\n\nArguments\n\nkx, ky: Horizontal wavenumber components\npar: QGParams (contains ν₁, ν₂, n₁, n₂)\nwaves::Bool: If true, use wave hyperdiffusion (nuh1w, ilap1w, etc.)\n\nReturns\n\nλ×dt = dt × [ν₁(kx² + ky²)^n₁ + ν₂(kx² + ky²)^n₂] = dt × [ν₁ kₕ^(2n₁) + ν₂ kₕ^(2n₂)]\n\nNote: Uses isotropic form (kx² + ky²)^n for proper damping of diagonal modes.\n\nUsage in Time Stepping\n\n# After computing tendency\nfactor = exp(-int_factor(kx, ky, par))\nq_new = factor * q_tendency\n\nFortran Correspondence\n\nThis matches the integrating factor computation in the main loop of main_waqg.f90.\n\nExample\n\n# Get integrating factor for wavenumber (3, 4)\nlambda_dt = int_factor(3.0, 4.0, params)\nfactor = exp(-lambda_dt)  # Multiply solution by this\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.init_imex_workspace","page":"Time Stepping","title":"QGYBJplus.init_imex_workspace","text":"init_imex_workspace(S, G; nthreads=Threads.maxthreadid())\n\nInitialize workspace for IMEX time stepping with threading support.\n\nNOTE: All work arrays are pre-allocated here to avoid heap corruption from repeated allocation/deallocation in tight loops during time stepping. Per-thread workspaces are created for the tridiagonal solves to enable parallel processing of horizontal modes.\n\nThe workspace includes storage for Adams-Bashforth 2 (previous tendency) and Strang splitting (intermediate B* state).\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.imex_cn_step!","page":"Time Stepping","title":"QGYBJplus.imex_cn_step!","text":"imex_cn_step!(Snp1, Sn, G, par, plans, imex_ws; a, dealias_mask=nothing, workspace=nothing, N2_profile=nothing)\n\nSecond-order IMEX-CNAB time step for YBJ+ equation with Strang splitting for refraction.\n\nUses Strang splitting with Adams-Bashforth 2 for advection (waves and mean flow) and Crank-Nicolson for linear PV diffusion/hyperdiffusion:\n\nStage 1 (First Half-Refraction): B* = B^n × exp(-i·(dt/2)·ζ/2)\nStage 2 (IMEX-CNAB for Advection + Dispersion):\nAdvection (AB2): (3/2)N^n - (1/2)N^{n-1} where N = -J(ψ,B)\nDispersion (CN): (1/2)[L(B*) + L(B^{n+1})]\nStage 3 (Second Half-Refraction): B^{n+1} = B** × exp(-i·(dt/2)·ζ/2) using ψ^{n+1} predictor\n\nThis achieves second-order temporal accuracy through:\n\nStrang splitting (second-order) instead of Lie splitting (first-order)\nAdams-Bashforth 2 (second-order) for advection (q and B)\nCrank-Nicolson for dispersion (second-order)\n\nAlgorithm\n\nCompute q advection at time n: Q^n = -J(ψ^n, q^n)\nApply first half-refraction: B* = B^n × exp(-i·(dt/2)·ζ/2)\nCompute B advection using B: N^n = -J(ψ^n, B)\nFor each spectral mode (kx, ky) solve IMEX-CNAB for B: a. Compute A* = (L⁺)⁻¹B* (essential for IMEX-CN consistency!) b. Build RHS = B* + (dt/2)·i·αdisp·kₕ²·A* + (3dt/2)·N^n - (dt/2)·N^{n-1} c. Solve modified elliptic: (L⁺ - β)·A^{n+1} = RHS where β = (dt/2)·i·αdisp·kₕ² d. Recover B** = RHS + β·A^{n+1}\nUpdate q with CNAB: (I - dt/2·L)·q^{n+1} = (I + dt/2·L)·q^n + dt·[ (3/2)Q^n - (1/2)Q^{n-1} ] where L = νz∂zz - λ_h (vertical diffusion + hyperdiffusion)\nCompute ψ^{n+1} predictor from q^{n+1} (and q^w predictor when enabled)\nApply second half-refraction using ψ^{n+1} predictor\nStore tendencies for next step (AB2)\n\nArguments\n\nSnp1::State: State at time n+1 (output)\nSn::State: State at time n (input)\nG::Grid: Grid\npar::QGParams: Parameters\nplans: FFT plans\nimex_ws::IMEXWorkspace: Pre-allocated workspace (stores N^{n-1} for AB2)\na: Elliptic coefficient a_ell = f²/N²\ndealias_mask: Dealiasing mask\nworkspace: Additional workspace for elliptic solvers\nN2_profile: N²(z) profile\n\nTemporal Accuracy\n\nOverall: Second-order in time\nFirst step: Falls back to forward Euler for advection (AB2 bootstrap)\n\nStability\n\nRefraction: Exactly energy-preserving (integrating factor)\nDispersion: Unconditionally stable (implicit CN)\nAdvection CFL: dt < dx/U_max ≈ 1600s for this problem\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJplus.first_imex_step!","page":"Time Stepping","title":"QGYBJplus.first_imex_step!","text":"first_imex_step!(S, G, par, plans, imex_ws; a, dealias_mask=nothing, workspace=nothing, N2_profile=nothing)\n\nFirst-order forward Euler step to initialize IMEX time stepping.\n\nThis function:\n\nPerforms a first-order forward Euler step (same as firstprojectionstep!)\nInitializes the AB2 state by computing and storing the q and B advection tendencies\n\nAfter this function is called, subsequent calls to imexcnstep! will use second-order Adams-Bashforth 2 for advection.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guide/configuration/#Two-APIs","page":"Configuration","title":"Two APIs","text":"Use Case API\nQuick start create_simple_config() → run_simple_simulation()\nFull control default_params() → setup_model() → manual stepping\n\nwarning: Different Defaults\nFlag Simple API Full API\ninviscid true false\nno_wave_feedback false true","category":"section"},{"location":"guide/configuration/#Simple-API","page":"Configuration","title":"Simple API","text":"config = create_simple_config(\n    # Domain (REQUIRED)\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    # Grid\n    nx=64, ny=64, nz=32,\n    # Time\n    dt=0.001, total_time=1.0,\n    # Physics\n    ybj_plus=true, inviscid=true, linear=false,\n    # Output\n    output_interval=100\n)\nresult = run_simple_simulation(config)","category":"section"},{"location":"guide/configuration/#Full-API","page":"Configuration","title":"Full API","text":"par = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    nx=64, ny=64, nz=32,\n    dt=0.001, nt=1000,\n    f₀=1.0, N²=1.0,\n    ybj_plus=true, inviscid=false\n)\n\nG, S, plans, a_ell = setup_model(par)\ninit_random_psi!(S, G; amplitude=0.1)\ncompute_q_from_psi!(S, G, plans, a_ell)\n\nfirst_projection_step!(S, G, par, plans, a_ell)\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\nend\n\ntip: IMEX\nUse imex_cn_step!() instead of leapfrog_step!() for ~10× faster wave-dominated problems.","category":"section"},{"location":"guide/configuration/#Parameter-Reference","page":"Configuration","title":"Parameter Reference","text":"","category":"section"},{"location":"guide/configuration/#Domain-(REQUIRED)","page":"Configuration","title":"Domain (REQUIRED)","text":"Parameter Description\nLx, Ly Horizontal domain size [m]\nLz Vertical depth [m]\nnx, ny, nz Grid points (default: 64)","category":"section"},{"location":"guide/configuration/#Physics","page":"Configuration","title":"Physics","text":"Parameter Default Description\nf₀ 1.0 Coriolis parameter\nN² 1.0 Buoyancy frequency squared\nγ 1e-3 Robert-Asselin filter\n\nUnicode: type f\\_0<tab> → f₀, \\nu<tab> → ν","category":"section"},{"location":"guide/configuration/#Model-Flags","page":"Configuration","title":"Model Flags","text":"Flag Default Effect\nybj_plus true Use YBJ+ formulation\ninviscid false Disable dissipation\nlinear false Disable nonlinear terms\nno_wave_feedback true Disable qʷ term\nno_dispersion false Disable wave dispersion\nfixed_flow false Keep ψ constant","category":"section"},{"location":"guide/configuration/#Dissipation","page":"Configuration","title":"Dissipation","text":"Two hyperdiffusion operators: ν₁(-∇²)^ilap1 + ν₂(-∇²)^ilap2\n\nParameter Default Description\nνₕ₁, νₕ₂ 0.01, 10.0 Hyperviscosity (flow)\nilap1, ilap2 2, 6 Laplacian power\nνₕ₁ʷ, νₕ₂ʷ 0.0, 10.0 Hyperviscosity (waves)\n\nHigher ilap = more scale-selective: 1 (∇²), 2 (∇⁴), 4 (∇⁸)","category":"section"},{"location":"guide/configuration/#Examples","page":"Configuration","title":"Examples","text":"","category":"section"},{"location":"guide/configuration/#QG-Only-(No-Waves)","page":"Configuration","title":"QG-Only (No Waves)","text":"par = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, no_dispersion=true)","category":"section"},{"location":"guide/configuration/#Linear-Wave-Propagation","page":"Configuration","title":"Linear Wave Propagation","text":"config = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    linear=true, inviscid=true, no_wave_feedback=true\n)","category":"section"},{"location":"guide/configuration/#Save/Load","page":"Configuration","title":"Save/Load","text":"using JLD2\n@save \"config.jld2\" par\n@load \"config.jld2\" par","category":"section"},{"location":"guide/configuration/#See-Also","page":"Configuration","title":"See Also","text":"Stratification\nI/O and Output\nMPI Parallelization","category":"section"},{"location":"guide/initial_conditions/#initial-conditions","page":"Initial Conditions","title":"Initial Conditions","text":"This page describes how to set up initial conditions for QGYBJ+.jl simulations.","category":"section"},{"location":"guide/initial_conditions/#Overview","page":"Initial Conditions","title":"Overview","text":"Initial conditions must be specified for:\n\nPotential vorticity q (or streamfunction psi)\nWave envelope B (or wave amplitude A)","category":"section"},{"location":"guide/initial_conditions/#Random-Initialization","page":"Initial Conditions","title":"Random Initialization","text":"","category":"section"},{"location":"guide/initial_conditions/#Random-Streamfunction","page":"Initial Conditions","title":"Random Streamfunction","text":"The most common way to initialize a simulation is with random streamfunction:\n\nusing QGYBJplus\n\n# Create parameters and setup\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a_ell = setup_model(par)\n\n# Random streamfunction\ninit_random_psi!(S, G; amplitude=0.1, seed=12345)\n\n# Compute q from psi (required before time stepping)\ncompute_q_from_psi!(S, G, plans, a_ell)\n\nThe random field is band-limited to resolved wavenumbers.","category":"section"},{"location":"guide/initial_conditions/#Analytical-Initial-Conditions","page":"Initial Conditions","title":"Analytical Initial Conditions","text":"","category":"section"},{"location":"guide/initial_conditions/#Analytical-Streamfunction","page":"Initial Conditions","title":"Analytical Streamfunction","text":"# Initialize with analytical pattern (e.g., dipole)\ninit_analytical_psi!(S, G; mode=:dipole, amplitude=1.0)\n\n# Or single mode\ninit_analytical_psi!(S, G; mode=:single, kx=2, ky=2, amplitude=0.5)\n\n# Compute q from psi\ncompute_q_from_psi!(S, G, plans, a_ell)","category":"section"},{"location":"guide/initial_conditions/#Analytical-Waves","page":"Initial Conditions","title":"Analytical Waves","text":"# Initialize wave envelope with analytical pattern\ninit_analytical_waves!(S, G; amplitude=0.01, vertical_mode=1)","category":"section"},{"location":"guide/initial_conditions/#Balanced-Initialization","page":"Initial Conditions","title":"Balanced Initialization","text":"To ensure the flow starts in geostrophic balance:\n\n# First set up streamfunction\ninit_random_psi!(S, G; amplitude=0.1)\n\n# Add balanced component\nadd_balanced_component!(S, G, plans, a_ell)\n\n# Compute q from the balanced psi\ncompute_q_from_psi!(S, G, plans, a_ell)","category":"section"},{"location":"guide/initial_conditions/#From-Configuration","page":"Initial Conditions","title":"From Configuration","text":"Using the high-level API, initial conditions can be specified in the configuration:\n\nusing QGYBJplus\n\n# Create initial condition configuration\ninit_config = create_initial_condition_config(\n    psi_type=:random,     # :analytical, :from_file, :random\n    wave_type=:random,    # :zero, :analytical, :from_file, :random\n    wave_amplitude=1e-3,\n    random_seed=1234,\n)\n\n# Use in simulation setup\ndomain = create_domain_config(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)\nstrat = create_stratification_config(type=:constant_N)\n\nsim = setup_simulation(domain, strat; initial_conditions=init_config)","category":"section"},{"location":"guide/initial_conditions/#Exponentially-Decaying-Surface-Waves-(Config)","page":"Initial Conditions","title":"Exponentially Decaying Surface Waves (Config)","text":"using QGYBJplus\n\ninit_config = create_initial_condition_config(\n    psi_type=:analytical,\n    wave_type=:surface_exponential,\n    wave_amplitude=0.1,      # u₀ [m/s]\n    wave_surface_depth=50.0, # e-folding depth [m]\n    wave_uniform=true\n)\n\ndomain = create_domain_config(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)\nstrat = create_stratification_config(type=:constant_N)\n\nsim = setup_simulation(domain, strat; initial_conditions=init_config)","category":"section"},{"location":"guide/initial_conditions/#From-Data-Files","page":"Initial Conditions","title":"From Data Files","text":"","category":"section"},{"location":"guide/initial_conditions/#From-NetCDF","page":"Initial Conditions","title":"From NetCDF","text":"using QGYBJplus\n\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a_ell = setup_model(par)\n\n# Read initial streamfunction from file\npsi_init = read_initial_psi(\"initial_conditions.nc\", G)\nS.psi .= psi_init\n\n# Read initial waves from file (optional)\nB_init = read_initial_waves(\"initial_conditions.nc\", G)\nS.B .= B_init\n\n# Compute derived quantities\ncompute_q_from_psi!(S, G, plans, a_ell)\ncompute_velocities!(S, G, plans)","category":"section"},{"location":"guide/initial_conditions/#From-NetCDF-with-MPI","page":"Initial Conditions","title":"From NetCDF with MPI","text":"For MPI runs, prefer the config-based path so rank 0 reads and the field is scattered automatically:\n\nusing QGYBJplus\n\ninit_config = create_initial_condition_config(\n    psi_type=:from_file,\n    psi_filename=\"initial_conditions.nc\"\n)\n\ndomain = create_domain_config(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)\nstrat = create_stratification_config(type=:constant_N)\n\nsim = setup_simulation(domain, strat; initial_conditions=init_config)\n\nRun with mpirun -n 4 julia --project your_script.jl to enable MPI.","category":"section"},{"location":"guide/initial_conditions/#Using-ncread-Functions","page":"Initial Conditions","title":"Using ncread Functions","text":"For legacy compatibility:\n\n# Read streamfunction\nncread_psi!(S, G, \"psi_file.nc\")\n\n# Read wave envelope\nncread_la!(S, G, \"waves_file.nc\")","category":"section"},{"location":"guide/initial_conditions/#Direct-Assignment","page":"Initial Conditions","title":"Direct Assignment","text":"You can directly assign values in spectral space:\n\nusing QGYBJplus\n\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a_ell = setup_model(par)\n\n# Direct assignment (in spectral space)\nS.psi .= 0.0  # Zero everywhere\nS.B .= 0.0    # No waves\n\n# Or set specific modes\n# S.psi[kx_idx, ky_idx, kz] = amplitude\n\n# Always compute q from psi after modifying psi\ncompute_q_from_psi!(S, G, plans, a_ell)","category":"section"},{"location":"guide/initial_conditions/#Complete-Example:-Spin-Up","page":"Initial Conditions","title":"Complete Example: Spin-Up","text":"For realistic simulations, start with random initialization and spin up:\n\nusing QGYBJplus\n\n# Setup\npar = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    nx=64, ny=64, nz=32,\n    dt=0.001, nt=10000\n)\nG, S, plans, a_ell = setup_model(par)\n\n# Initialize flow randomly\ninit_random_psi!(S, G; amplitude=0.1)\ncompute_q_from_psi!(S, G, plans, a_ell)\n\n# Spin-up phase (develop turbulence) - no waves\nspinup_steps = 1000\nfirst_projection_step!(S, G, par, plans, a_ell)\nfor step = 2:spinup_steps\n    leapfrog_step!(S, G, par, plans, a_ell)\nend\n\n# Now add waves\ninit_analytical_waves!(S, G; amplitude=0.01)\n\n# Production run\nfor step = 1:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\nend","category":"section"},{"location":"guide/initial_conditions/#Verification","page":"Initial Conditions","title":"Verification","text":"","category":"section"},{"location":"guide/initial_conditions/#Check-Initial-Energy","page":"Initial Conditions","title":"Check Initial Energy","text":"# Compute velocities first\ncompute_velocities!(S, G, plans)\n\n# Check flow kinetic energy\nKE = flow_kinetic_energy(S.u, S.v)\nprintln(\"Initial KE: $KE\")\n\n# Check wave energy\nWE_B, WE_A = wave_energy(S.B, S.A)\nprintln(\"Initial Wave Energy (B): $WE_B\")\nprintln(\"Initial Wave Energy (A): $WE_A\")","category":"section"},{"location":"guide/initial_conditions/#Visualize","page":"Initial Conditions","title":"Visualize","text":"using Plots\n\n# Get horizontal slice\npsi_slice = slice_horizontal(S.psi, G, plans; k=G.nz)\n\nheatmap(real(psi_slice), title=\"Initial Surface ψ\", aspect_ratio=1)","category":"section"},{"location":"guide/initial_conditions/#API-Reference","page":"Initial Conditions","title":"API Reference","text":"The following functions are available for initial conditions:\n\nFunction Description\ninit_random_psi! Random streamfunction field\ninit_analytical_psi! Analytical streamfunction pattern\ninit_analytical_waves! Analytical wave envelope\nadd_balanced_component! Add balanced component to flow\ncompute_q_from_psi! Compute PV from streamfunction\ninitialize_from_config Initialize from configuration object\nread_initial_psi Read ψ from NetCDF file\nread_initial_waves Read B from NetCDF file\nncread_psi! Legacy NetCDF read for ψ\nncread_la! Legacy NetCDF read for waves\n\nSee the Grid & State API for more details on state initialization.","category":"section"},{"location":"physics/wave_mean/#wave-mean","page":"Wave-Mean Interaction","title":"Wave-Mean Interaction","text":"This page describes the two-way coupling between near-inertial waves and the balanced mean flow.","category":"section"},{"location":"physics/wave_mean/#Physical-Motivation","page":"Wave-Mean Interaction","title":"Physical Motivation","text":"","category":"section"},{"location":"physics/wave_mean/#Why-Waves-Affect-the-Mean-Flow","page":"Wave-Mean Interaction","title":"Why Waves Affect the Mean Flow","text":"Near-inertial waves carry momentum and energy. When they:\n\nBreak or dissipate\nRefract through vorticity gradients\nInteract nonlinearly with the flow\n\n...they can transfer energy and momentum to the balanced circulation.","category":"section"},{"location":"physics/wave_mean/#Observational-Evidence","page":"Wave-Mean Interaction","title":"Observational Evidence","text":"Anticyclones contain enhanced NIW energy (chimney effect)\nWave dissipation correlates with mixing in anticyclones\nWaves can energize the mesoscale eddy field","category":"section"},{"location":"physics/wave_mean/#The-Wave-Feedback-Term","page":"Wave-Mean Interaction","title":"The Wave Feedback Term","text":"","category":"section"},{"location":"physics/wave_mean/#Definition","page":"Wave-Mean Interaction","title":"Definition","text":"Following Xie & Vanneste (2015), the wave-induced potential vorticity is:\n\nq^w = fraci2f_0 J(B^* B) + frac14f_0 nabla_h^2 B^2\n\nwhere B is the complex wave envelope with units of velocity (m/s) and f_0 is the Coriolis parameter.\n\nnote: Dimensional Equations\nThe model solves dimensional equations where B has actual velocity amplitude. No additional scaling factors (like W2F) are needed.","category":"section"},{"location":"physics/wave_mean/#Decomposition-in-Real/Imaginary-Parts","page":"Wave-Mean Interaction","title":"Decomposition in Real/Imaginary Parts","text":"Writing B = B_R + i B_I, the Jacobian term becomes:\n\nfraci2f_0 J(B^* B) = frac1f_0left(fracpartial B_Rpartial y fracpartial B_Ipartial x - fracpartial B_Rpartial x fracpartial B_Ipartial yright)\n\nAnd the wave intensity:\n\nB^2 = B_R^2 + B_I^2\n\nSo the complete formula in spectral space is:\n\nq^w = frac1f_0left( fracpartial B_Rpartial y fracpartial B_Ipartial x - fracpartial B_Rpartial x fracpartial B_Ipartial y right) - frack_h^24f_0 (B_R^2 + B_I^2)\n\nNote: In spectral space, nabla_h^2 to -k_h^2, so +frac14f_0nabla_h^2B^2 to -frack_h^24f_0B^2.","category":"section"},{"location":"physics/wave_mean/#How-It-Enters-the-QG-Equation","page":"Wave-Mean Interaction","title":"How It Enters the QG Equation","text":"The wave feedback modifies the effective PV used for streamfunction inversion:\n\nq^* = q - q^w\n\nThen psi is computed from q^* via the elliptic inversion:\n\nnabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q^*","category":"section"},{"location":"physics/wave_mean/#Physical-Interpretation","page":"Wave-Mean Interaction","title":"Physical Interpretation","text":"Term Meaning\nJ(B^* B) Jacobian of complex wave field (wave momentum flux)\nnabla_h^2B^2 Horizontal curvature of wave energy density\n\nThe wave feedback represents:\n\nRadiation stress from wave momentum flux\nForm drag from wave-induced pressure fluctuations","category":"section"},{"location":"physics/wave_mean/#Energy-Exchange","page":"Wave-Mean Interaction","title":"Energy Exchange","text":"","category":"section"},{"location":"physics/wave_mean/#Wave-to-Flow-Transfer","page":"Wave-Mean Interaction","title":"Wave-to-Flow Transfer","text":"Energy flows from waves to mean flow when:\n\nmathcalE_w to f = -int psi cdot J(psi q^w)  dV\n\nThis can be positive or negative:\n\nPositive: Waves energize the flow\nNegative: Flow energizes waves (less common)","category":"section"},{"location":"physics/wave_mean/#Conservation","page":"Wave-Mean Interaction","title":"Conservation","text":"In the inviscid limit, total energy is conserved:\n\nfracddt(E_flow + E_wave) = 0\n\nThe wave feedback term merely redistributes energy.","category":"section"},{"location":"physics/wave_mean/#Refraction-Mechanism","page":"Wave-Mean Interaction","title":"Refraction Mechanism","text":"","category":"section"},{"location":"physics/wave_mean/#How-Eddies-Focus-Waves","page":"Wave-Mean Interaction","title":"How Eddies Focus Waves","text":"Anticyclones (negative vorticity) trap waves:\n\nEffective frequency is reduced: f_eff = f_0 + zeta2\nWaves propagate toward lower effective frequency\nEnergy accumulates in anticyclone cores","category":"section"},{"location":"physics/wave_mean/#The-Chimney-Effect","page":"Wave-Mean Interaction","title":"The Chimney Effect","text":"         Wind Forcing\n              ↓\n    ┌─────────────────────┐\n    │   Surface Layer     │\n    └─────────┬───────────┘\n              │\n    ┌─────────┼───────────┐\n    │    ↙    ↓    ↘      │  ← Waves spread horizontally\n    │   ↙     ↓     ↘     │\n    └──↙──────┼──────↘────┘\n       ↘      ↓      ↙\n        ↘     ↓     ↙\n         ↘    ↓    ↙        ← Anticyclone focuses waves\n    ┌─────────┼───────────┐\n    │         ↓           │\n    │    Anticyclone      │  ← Enhanced dissipation\n    │      (ζ < 0)        │\n    └─────────────────────┘\n\nWaves are funneled into anticyclones, enhancing deep mixing.","category":"section"},{"location":"physics/wave_mean/#Implementation","page":"Wave-Mean Interaction","title":"Implementation","text":"","category":"section"},{"location":"physics/wave_mean/#Computing-Wave-Feedback","page":"Wave-Mean Interaction","title":"Computing Wave Feedback","text":"# In nonlinear.jl: compute_qw! (BR/BI form)\nfunction compute_qw!(qwk, BRk, BIk, par, G, plans; Lmask=nothing)\n    f0 = par.f₀  # Coriolis parameter\n\n    # 1. Compute derivatives of BR and BI\n    # BRx = ∂BR/∂x, BRy = ∂BR/∂y, etc.\n    BRxk = im * kx .* BRk\n    BRyk = im * ky .* BRk\n    BIxk = im * kx .* BIk\n    BIyk = im * ky .* BIk\n\n    # 2. Transform to real space\n    # ...\n\n    # 3. Compute Jacobian term: (1/f₀)(BRy*BIx - BRx*BIy)\n    qwr = (BRyr .* BIxr - BRxr .* BIyr) / f0\n\n    # 4. Compute |B|² = BR² + BI²\n    mag2 = BRr.^2 + BIr.^2\n\n    # 5. Assemble in spectral space\n    # qw = J_term - (kh²/4f₀)*|B|²  (note: ∇² → -kh² in spectral)\n    qwk = fft(qwr) - (0.25/f0) * kh2 .* fft(mag2)\n\n    # Note: No additional scaling needed - B has dimensional velocity units (m/s)\nend\n\nFor the complex envelope form used in YBJ+ time stepping, use:\n\ncompute_qw_complex!(qwk, Bk, par, G, plans; Lmask=L)","category":"section"},{"location":"physics/wave_mean/#Usage-in-Time-Stepping","page":"Wave-Mean Interaction","title":"Usage in Time Stepping","text":"The wave feedback enters via q* = q - qw:\n\n# After computing q at new time step\nif wave_feedback_enabled\n    compute_qw!(qwk, BRk, BIk, par, G, plans; Lmask=L)\n    q_arr .-= qwk_arr  # q* = q - qw\nend\n\n# Complex B form (YBJ+ path)\nif wave_feedback_enabled\n    compute_qw_complex!(qwk, Bk, par, G, plans; Lmask=L)\n    q_arr .-= qwk_arr  # q* = q - qw\nend\n\n# Then invert q* to get ψ\ninvert_q_to_psi!(state, grid; a=a_vec)","category":"section"},{"location":"physics/wave_mean/#Enabling/Disabling","page":"Wave-Mean Interaction","title":"Enabling/Disabling","text":"# With wave feedback (default)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0; no_feedback=false, no_wave_feedback=false)\n\n# Without wave feedback\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0; no_feedback=true)\n# or\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0; no_wave_feedback=true)\n\nDisabling is useful for:\n\nStudying one-way wave-flow interaction\nIsolating wave dynamics from flow effects\nComputational efficiency when feedback is weak","category":"section"},{"location":"physics/wave_mean/#Scaling-Analysis","page":"Wave-Mean Interaction","title":"Scaling Analysis","text":"","category":"section"},{"location":"physics/wave_mean/#When-is-Feedback-Important?","page":"Wave-Mean Interaction","title":"When is Feedback Important?","text":"The feedback strength scales as:\n\nfracq^wq sim left(fracA_0Uright)^2 cdot left(fracL_wLright)^2\n\nwhere:\n\nA_0U: Wave-to-flow velocity ratio\nL_wL: Wave-to-eddy length ratio\n\nFeedback matters when:\n\nStrong wind forcing (large A_0)\nCompact wave packets (small L_w)\nWeak background flow (small U)","category":"section"},{"location":"physics/wave_mean/#Typical-Values","page":"Wave-Mean Interaction","title":"Typical Values","text":"Scenario Wave Feedback\nWeak winds, strong eddies Negligible\nStorm forcing Moderate (1-10%)\nTropical cyclone Strong (10-50%)","category":"section"},{"location":"physics/wave_mean/#Coupled-Dynamics","page":"Wave-Mean Interaction","title":"Coupled Dynamics","text":"","category":"section"},{"location":"physics/wave_mean/#Feedback-Loop","page":"Wave-Mean Interaction","title":"Feedback Loop","text":"┌──────────────┐         ┌──────────────┐\n│              │         │              │\n│   Eddies     │◄────────│    Waves     │\n│   (ψ, q)     │         │   (A, B)     │\n│              │         │              │\n└──────┬───────┘         └──────┬───────┘\n       │                        │\n       │ Refraction             │ Feedback\n       │ ∂ζ/∂t                  │ qw\n       │                        │\n       ▼                        ▼\n┌──────────────────────────────────────┐\n│                                      │\n│       Wave-Mean Energy Exchange      │\n│                                      │\n└──────────────────────────────────────┘","category":"section"},{"location":"physics/wave_mean/#Equilibration","page":"Wave-Mean Interaction","title":"Equilibration","text":"The coupled system can reach statistical equilibrium where:\n\nWave generation (wind) balances dissipation\nEnergy flux from waves to flow balances eddy dissipation\nNet energy is constant on average","category":"section"},{"location":"physics/wave_mean/#Diagnostics","page":"Wave-Mean Interaction","title":"Diagnostics","text":"","category":"section"},{"location":"physics/wave_mean/#Monitoring-Energy-Exchange","page":"Wave-Mean Interaction","title":"Monitoring Energy Exchange","text":"# Compute wave feedback contribution\nqw = compute_wave_pv(state.A, grid)\n\n# Energy exchange rate\nexchange_rate = compute_energy_exchange(state.psi, qw, grid, plans)","category":"section"},{"location":"physics/wave_mean/#Typical-Analysis","page":"Wave-Mean Interaction","title":"Typical Analysis","text":"Track E_flow and E_wave over time\nCompute their time derivatives\nCompare with wave feedback term to verify energy conservation","category":"section"},{"location":"physics/wave_mean/#Complete-Energy-Budget","page":"Wave-Mean Interaction","title":"Complete Energy Budget","text":"","category":"section"},{"location":"physics/wave_mean/#Energy-Components","page":"Wave-Mean Interaction","title":"Energy Components","text":"The total energy of the QG-YBJ+ system consists of five components:\n\nE_total = underbraceE_KE^flow + E_PE^flow_textMean flow energy + underbraceE_KE^wave + E_PE^wave + E_CE^wave_textWave energy","category":"section"},{"location":"physics/wave_mean/#Mean-Flow-Kinetic-Energy","page":"Wave-Mean Interaction","title":"Mean Flow Kinetic Energy","text":"E_KE^flow = frac12 int int int (u^2 + v^2)  dx dy dz\n\nIn spectral space with dealiasing:\n\nE_KE^flow = frac12 sum_k_x k_y z L(k_x k_y) cdot k_h^2 hatpsi^2 - frac12hatpsi(k_h=0)^2\n\nwhere L(k_x k_y) is the dealiasing mask (2/3 rule) and the second term corrects for the zero-wavenumber mode.","category":"section"},{"location":"physics/wave_mean/#Mean-Flow-Potential-Energy","page":"Wave-Mean Interaction","title":"Mean Flow Potential Energy","text":"E_PE^flow = frac12 int int int fracf_0^2N^2 left(fracpartial psipartial zright)^2 dx dy dz\n\nIn spectral space:\n\nE_PE^flow = frac12 sum_k_x k_y z fracf_0^2N^2(z) hatb^2\n\nwhere b = partialpsipartial z is the buoyancy from thermal wind balance.","category":"section"},{"location":"physics/wave_mean/#Wave-Kinetic-Energy","page":"Wave-Mean Interaction","title":"Wave Kinetic Energy","text":"E_KE^wave = frac12 int int int B^2  dx dy dz\n\nIn spectral space with B = B_R + iB_I:\n\nE_KE^wave = frac12 sum_k_x k_y z (hatB_R^2 + hatB_I^2) - frac12hatB(k_h=0)^2","category":"section"},{"location":"physics/wave_mean/#Wave-Potential-Energy","page":"Wave-Mean Interaction","title":"Wave Potential Energy","text":"From the YBJ+ formulation, the wave potential energy involves C = partial Apartial z:\n\nE_PE^wave = frac12 int int int fracN^22f_0^2 k_h^2 C^2  dx dy dz\n\nIn spectral space:\n\nE_PE^wave = frac12 sum_k_x k_y z frack_h^22 a_ell (hatC_R^2 + hatC_I^2)\n\nwhere a_ell = f_0^2N^2 is the elliptic coefficient.","category":"section"},{"location":"physics/wave_mean/#Wave-Correction-Energy-(YBJ)","page":"Wave-Mean Interaction","title":"Wave Correction Energy (YBJ+)","text":"The YBJ+ equation introduces a higher-order correction:\n\nE_CE^wave = frac18 int int int fracN^4f_0^4 k_h^4 A^2  dx dy dz\n\nIn spectral space:\n\nE_CE^wave = frac12 sum_k_x k_y z frack_h^48 a_ell^2 (hatA_R^2 + hatA_I^2)\n\nThis term accounts for horizontal wave dispersion and becomes significant at small scales.","category":"section"},{"location":"physics/wave_mean/#Energy-Conservation-Theorem","page":"Wave-Mean Interaction","title":"Energy Conservation Theorem","text":"Theorem: In the inviscid limit (no dissipation), the total energy is conserved:\n\nfracdE_totaldt = 0\n\nProof sketch:\n\nThe QG PV equation conserves mean flow energy in the absence of wave feedback\nThe YBJ+ equation conserves wave energy in the absence of mean flow\nThe wave feedback term q^w transfers energy between waves and flow without dissipation\nThe refraction term frac12B cdot zeta exchanges energy via wave-vorticity interaction","category":"section"},{"location":"physics/wave_mean/#Energy-Transfer-Pathways","page":"Wave-Mean Interaction","title":"Energy Transfer Pathways","text":"                    Wind Forcing\n                         │\n                         ▼\n    ┌────────────────────────────────────────┐\n    │           Wave Energy                  │\n    │   E_KE^wave + E_PE^wave + E_CE^wave    │\n    └────────────────┬───────────────────────┘\n                     │\n           Refraction │ Wave Feedback\n           (B·ζ term) │ (q^w term)\n                     │\n                     ▼\n    ┌────────────────────────────────────────┐\n    │         Mean Flow Energy               │\n    │        E_KE^flow + E_PE^flow           │\n    └────────────────┬───────────────────────┘\n                     │\n                     ▼\n              Viscous Dissipation","category":"section"},{"location":"physics/wave_mean/#Energy-Exchange-Rate","page":"Wave-Mean Interaction","title":"Energy Exchange Rate","text":"The rate of energy transfer from waves to mean flow is:\n\nmathcalP_w to f = -int psi cdot J(psi q^w)  dV\n\nThis can be computed diagnostically:\n\n# Compute energy exchange rate\nqw = compute_qw(state, grid, params, plans)\nP_exchange = -sum(psi .* jacobian(psi, qw, grid, plans))","category":"section"},{"location":"physics/wave_mean/#Energy-Scales","page":"Wave-Mean Interaction","title":"Energy Scales","text":"Using the characteristic scales:\n\nVelocity: U (mean flow), U_w (waves)\nLength: L (horizontal), H (vertical)\nTime: 1f_0\n\nThe energy ratio scales as:\n\nfracE^waveE^flow sim left(fracU_wUright)^2\n\nTypical oceanic values for wave-to-flow energy ratio:\n\nGulf Stream region: sim 10^-2 to 10^-1\nOpen ocean: sim 10^-3\nAfter storm: sim 1","category":"section"},{"location":"physics/wave_mean/#Diagnostic-Implementation","page":"Wave-Mean Interaction","title":"Diagnostic Implementation","text":"Energy diagnostics are automatically saved to separate files:\n\n# Output files in diagnostic/ folder:\n# - wave_KE.nc: E_KE^wave time series\n# - wave_PE.nc: E_PE^wave time series\n# - wave_CE.nc: E_CE^wave time series\n# - mean_flow_KE.nc: E_KE^flow time series\n# - mean_flow_PE.nc: E_PE^flow time series\n# - total_energy.nc: All energies + totals\n\n# Verify conservation\nds = NCDataset(\"output/diagnostic/total_energy.nc\")\nE_total = ds[\"total_energy\"][:]\ndE = (E_total[end] - E_total[1]) / E_total[1]\n# Should be < 10^-6 for inviscid runs\n\nSee Diagnostics Guide for detailed usage.","category":"section"},{"location":"physics/wave_mean/#References","page":"Wave-Mean Interaction","title":"References","text":"Xie, J.-H., & Vanneste, J. (2015). A generalised-Lagrangian-mean model of the interactions between near-inertial waves and mean flow. J. Fluid Mech., 774, 143-169.\nWagner, G. L., & Young, W. R. (2016). A three-component model for the coupled evolution of near-inertial waves, quasi-geostrophic flow and the near-inertial second harmonic. J. Fluid Mech., 802, 806-837.\nAsselin, O., & Young, W. R. (2019). An improved model of near-inertial wave dynamics. J. Fluid Mech., 876, 428-448.","category":"section"},{"location":"api/types/#api-types","page":"Core Types","title":"Core Types","text":"This page documents the core data types in QGYBJ+.jl.","category":"section"},{"location":"api/types/#QGParams","page":"Core Types","title":"QGParams","text":"The main parameter structure containing all simulation settings.","category":"section"},{"location":"api/types/#Fields","page":"Core Types","title":"Fields","text":"Field Type Description\nnx, ny, nz Int Grid dimensions\nLx, Ly, Lz Float64 Domain sizes (REQUIRED)\ndt Float64 Time step\nnt Int Number of time steps\nf₀ Float64 Coriolis parameter\nN² Float64 Buoyancy frequency squared\nγ Float64 Robert-Asselin filter coefficient\nybj_plus Bool Use YBJ+ formulation\nno_feedback Bool Master switch: disable all wave-mean coupling\nno_wave_feedback Bool Disable wave feedback on mean flow\ninviscid Bool Disable all dissipation\nlinear Bool Disable nonlinear terms\nνₕ₁ Float64 First hyperviscosity coefficient (flow)\nilap1 Int Laplacian power for νₕ₁\nνₕ₂ Float64 Second hyperviscosity coefficient (flow)\nilap2 Int Laplacian power for νₕ₂\nνₕ₁ʷ Float64 First hyperviscosity coefficient (waves)\nνₕ₂ʷ Float64 Second hyperviscosity coefficient (waves)\nνz Float64 Vertical diffusivity\n\nNote: Type Unicode characters using \\ + name + <tab> in Julia REPL (e.g., f\\_0<tab> → f₀)","category":"section"},{"location":"api/types/#Constructors","page":"Core Types","title":"Constructors","text":"# Domain size is REQUIRED (no defaults)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0)  # 500km × 500km × 4km\n\n# Custom parameters with domain size\nparams = default_params(;\n    Lx = 500e3, Ly = 500e3, Lz = 4000.0,  # Domain size (REQUIRED)\n    nx = 128, ny = 128, nz = 64,           # Grid dimensions\n    f₀ = 1.0,\n    N² = 1.0,\n    ybj_plus = true,\n    νₕ₂ = 10.0,\n    ilap2 = 6\n)","category":"section"},{"location":"api/types/#Example","page":"Core Types","title":"Example","text":"# High-resolution parameters (domain size REQUIRED)\nparams = default_params(;\n    Lx = 500e3, Ly = 500e3, Lz = 4000.0,\n    nx = 256, ny = 256, nz = 128,\n    ybj_plus = true,\n    no_feedback = false,\n    νₕ₂ = 1e-12,\n    ilap2 = 8\n)","category":"section"},{"location":"api/types/#Grid","page":"Core Types","title":"Grid","text":"The computational grid structure.","category":"section"},{"location":"api/types/#Fields-2","page":"Core Types","title":"Fields","text":"Field Type Description\nnx, ny, nz Int Grid dimensions\nLx, Ly, Lz Float64 Domain sizes\ndx, dy, dz Float64 Grid spacings\nx, y, z Vector{Float64} Coordinate arrays\nkx, ky Vector{Float64} Wavenumber arrays\nkh2 Array{Float64,2} Horizontal wavenumber squared","category":"section"},{"location":"api/types/#Constructors-2","page":"Core Types","title":"Constructors","text":"# Initialize grid from parameters (recommended)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\ngrid = init_grid(params)","category":"section"},{"location":"api/types/#Grid-Utilities","page":"Core Types","title":"Grid Utilities","text":"# Get wavenumbers at local indices (works with MPI)\nkx = get_kx(grid, i)   # Get kx at local index i\nky = get_ky(grid, j)   # Get ky at local index j\nkh2 = get_kh2(grid, i, j)  # Get horizontal wavenumber squared","category":"section"},{"location":"api/types/#State","page":"Core Types","title":"State","text":"The simulation state containing all prognostic and diagnostic fields.","category":"section"},{"location":"api/types/#Fields-3","page":"Core Types","title":"Fields","text":"Prognostic Fields (evolved in time):\n\nField Type Description\nq Array{ComplexF64,3} QG potential vorticity (spectral)\nB Array{ComplexF64,3} YBJ+ wave envelope B = L⁺A (spectral)\n\nDiagnostic Fields (computed from prognostic):\n\nField Type Description\npsi Array{ComplexF64,3} Streamfunction ψ (spectral)\nA Array{ComplexF64,3} Wave amplitude (spectral)\nC Array{ComplexF64,3} Vertical derivative ∂A/∂z (spectral)\n\nVelocity Fields (real space):\n\nField Type Description\nu Array{Float64,3} Zonal velocity u = -∂ψ/∂y\nv Array{Float64,3} Meridional velocity v = ∂ψ/∂x\nw Array{Float64,3} Vertical velocity (from omega equation)\n\nnote: Leapfrog Time-Stepping\nThe leapfrog scheme uses separate State objects (Snm1, Sn, Snp1) rather than storing previous time levels within a single State struct. This design allows proper handling of MPI parallel arrays (PencilArrays).","category":"section"},{"location":"api/types/#Constructors-3","page":"Core Types","title":"Constructors","text":"# Create empty state from grid\nstate = init_state(grid)\n\n# Copy state (preserves PencilArray topology for MPI)\nstate_copy = copy_state(state)","category":"section"},{"location":"api/types/#Copying-States","page":"Core Types","title":"Copying States","text":"For MPI parallel runs, always use copy_state instead of deepcopy:\n\n# CORRECT: preserves pencil topology\nSnm1 = copy_state(S)\n\n# WRONG: breaks PencilArray transpose operations\nSnm1 = deepcopy(S)  # Causes \"pencil topologies must be the same\" error","category":"section"},{"location":"api/types/#Accessing-Fields","page":"Core Types","title":"Accessing Fields","text":"# Spectral fields (complex)\npsi_k = state.psi  # size (nz, nx, ny)\n\n# Physical fields (real)\nu = state.u        # size (nz, nx, ny)\nv = state.v        # size (nz, nx, ny)","category":"section"},{"location":"api/types/#FFT-Plans","page":"Core Types","title":"FFT Plans","text":"FFTW plan structures for efficient transforms.","category":"section"},{"location":"api/types/#Creating-Plans","page":"Core Types","title":"Creating Plans","text":"# Standard plans\nplans = plan_transforms!(grid)\n\n# With optimization\nplans = plan_transforms!(grid; flags=FFTW.MEASURE)\n\n# With threading\nFFTW.set_num_threads(8)\nplans = plan_transforms!(grid)","category":"section"},{"location":"api/types/#Using-Transforms","page":"Core Types","title":"Using Transforms","text":"# Forward transform: Physical → Spectral\nfft_forward!(dst, src, plans)\n\n# Backward transform: Spectral → Physical\nfft_backward!(dst, src, plans)","category":"section"},{"location":"api/types/#Setup-Model","page":"Core Types","title":"Setup Model","text":"The setup_model function is the recommended way to initialize all components:\n\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a_ell = setup_model(par)\n\nThis returns:\n\nG: Grid structure\nS: State structure\nplans: FFT plans\na_ell: Elliptic coefficient array for PV inversion\n\nFor non-constant stratification, use:\n\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, stratification=:skewed_gaussian)\nG, S, plans, a_ell, N2_profile = setup_model_with_profile(par)","category":"section"},{"location":"api/types/#Type-Hierarchy","page":"Core Types","title":"Type Hierarchy","text":"QGParams{T}     - Model parameters\n\nGrid            - Spatial grid and wavenumbers\n\nState           - Prognostic and diagnostic fields","category":"section"},{"location":"api/types/#Type-Stability","page":"Core Types","title":"Type Stability","text":"All core types are fully type-stable:\n\nusing Test\n@inferred init_state(grid)\n@inferred leapfrog_step!(state, grid, params, plans, a_ell)","category":"section"},{"location":"api/types/#Serialization","page":"Core Types","title":"Serialization","text":"Types support JLD2 serialization:\n\nusing JLD2\n\n# Save\n@save \"simulation.jld2\" grid params state\n\n# Load\n@load \"simulation.jld2\" grid params state","category":"section"},{"location":"api/types/#QGYBJplus.QGParams","page":"Core Types","title":"QGYBJplus.QGParams","text":"QGParams{T}\n\nContainer for all physical and numerical parameters of the QG-YBJ+ model.\n\nDomain Parameters\n\nnx, ny, nz: Grid resolution in x, y, z directions\nLx, Ly, Lz: Domain size in x, y, z in meters (REQUIRED - no default)\nx0, y0: Domain origin in x, y (default: 0, use -Lx/2,-Ly/2 for centered domain)\n\nTime Stepping\n\ndt: Time step size\nnt: Total number of time steps\n\nPhysical Parameters\n\nf₀: Coriolis parameter (typically 1.0 for nondimensional)\nN²: Buoyancy frequency squared (default 1.0)\nW2F: DEPRECATED - no longer used (kept for backward compatibility)\nγ: Robert-Asselin filter coefficient (typically 10⁻³)\nlinear_vert_structure: Legacy Fortran flag (0 or 1), typically 0\n\nViscosity/Hyperviscosity\n\nThe model uses two hyperdiffusion operators for stability:\n\nνₕ, νᵥ: Legacy generic viscosity coefficients (prefer specific coefficients below)\nνₕ₁, ilap1: First hyperviscosity coefficient and Laplacian power for mean flow\nνₕ₂, ilap2: Second hyperviscosity coefficient and Laplacian power for mean flow\nνₕ₁ʷ, ilap1w: First hyperviscosity for waves\nνₕ₂ʷ, ilap2w: Second hyperviscosity for waves\nνz: Vertical diffusion coefficient\n\nThe hyperdiffusion term is: ν₁(-∇²)^ilap1 + ν₂(-∇²)^ilap2\n\nPhysics Switches\n\nThese boolean flags control different physics modes:\n\ninviscid: If true, disable all dissipation\nlinear: If true, disable nonlinear advection terms\nno_dispersion: If true, disable wave dispersion (A=0)\npassive_scalar: If true, waves are passive (no dispersion, no refraction)\nybj_plus: If true, use YBJ+ formulation; if false, use normal YBJ\nno_feedback: If true, disable ALL wave-mean flow coupling (master switch)\nfixed_flow: If true, mean flow doesn't evolve (ψ constant in time)\nno_wave_feedback: If true, disable qʷ term specifically (waves don't modify PV)\n\nNote: Wave feedback is enabled only when BOTH no_feedback=false AND no_wave_feedback=false.\n\nStratification Parameters (Skewed Gaussian profile)\n\nFor the skewed Gaussian N²(z) profile:     N²(z) = N₁² exp(-(z-z₀)²/σ²) [1 + erf(α(z-z₀)/(σ√2))] + N₀²\n\nN₀²_sg: Background N² (N₀²)\nN₁²_sg: Peak N² amplitude (N₁²)\nσ_sg: Width parameter (σ)\nz₀_sg: Center depth (z₀)\nα_sg: Skewness parameter (α)\n\nExample\n\npar = default_params(nx=128, ny=128, nz=64, Lx=500e3, Ly=500e3, Lz=4000.0, dt=0.001, nt=10000)\n\nSee also: default_params, with_density_profiles\n\n\n\n\n\n","category":"type"},{"location":"api/types/#QGYBJplus.Grid","page":"Core Types","title":"QGYBJplus.Grid","text":"Grid{T, AT}\n\nNumerical grid and spectral metadata for the QG-YBJ+ model.\n\nType Parameters\n\nT: Floating point type (typically Float64)\nAT: Array type for 2D arrays (Array{T,2} or PencilArray{T,2})\n\nFields\n\nGrid Dimensions\n\nnx, ny, nz::Int: Number of grid points in x, y, z directions\nLx, Ly, Lz::T: Domain size in x, y, z in meters (REQUIRED - no default)\nx0, y0::T: Domain origin in x, y (0 = standard [0,Lx), -Lx/2 = centered [-Lx/2,Lx/2))\ndx, dy::T: Grid spacing in x, y (computed as Lx/nx, Ly/ny)\n\nVertical Grid\n\nz::Vector{T}: Staggered (cell-centered) vertical levels, length nz\ndz::Vector{T}: Layer thicknesses between levels, length nz-1 (or length 1 containing Lz when nz=1)\n\nSpectral Wavenumbers\n\nkx::Vector{T}: x-wavenumbers following FFTW convention, length nx\nky::Vector{T}: y-wavenumbers following FFTW convention, length ny\nkh2::AT: Horizontal wavenumber squared kx² + ky², size (nx, ny) in serial, or a 3D PencilArray with shape (nz, nx, ny) in parallel.\n\nParallel Decomposition\n\ndecomp::Any: PencilArrays decomposition (nothing for serial)\n\nWavenumber Convention\n\nFor a domain of size L with n points:\n\nk[i] = (2π/L) × m  where m = i-1        for i ≤ (n+1)÷2\n                          m = i-1-n      for i > (n+1)÷2\n\nExample\n\npar = default_params(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)\nG = init_grid(par)\n# G.kx[1] = 0 (mean mode)\n# G.kx[33] = -32 × (2π/Lx) (most negative wavenumber)\n\nSee also: init_grid, State\n\n\n\n\n\n","category":"type"},{"location":"api/types/#QGYBJplus.State","page":"Core Types","title":"QGYBJplus.State","text":"State{T, RT, CT}\n\nContainer for all prognostic and diagnostic fields in the QG-YBJ+ model.\n\nType Parameters\n\nT: Floating point type (Float64)\nRT: Real array type (Array{T,3} or PencilArray{T,3})\nCT: Complex array type (Array{Complex{T},3} or PencilArray{Complex{T},3})\n\nPrognostic Fields (evolved in time)\n\nq::CT: QG potential vorticity in spectral space\nB::CT: YBJ+ wave envelope B = L⁺A in spectral space\n\nDiagnostic Fields (computed from prognostic)\n\npsi::CT: Streamfunction ψ (from q via elliptic inversion)\nA::CT: Wave amplitude (from B via YBJ+ inversion)\nC::CT: Vertical derivative C = ∂A/∂z (for wave velocities)\n\nVelocity Fields (real space)\n\nu::RT: Zonal velocity u = -∂ψ/∂y\nv::RT: Meridional velocity v = ∂ψ/∂x\nw::RT: Vertical velocity (from omega equation or YBJ)\n\nArray Dimensions\n\nAll arrays have shape (nz, nx, ny).\n\nSpectral fields (q, psi, A, B, C): Complex arrays\nReal-space fields (u, v, w): Real arrays\n\nPhysical Interpretation\n\nThe prognostic variables are:\n\nq: Quasi-geostrophic potential vorticity\nRelated to ψ by: q = ∇²ψ + (f²/N²)∂²ψ/∂z²\nB: YBJ+ wave envelope\nRelated to wave amplitude A by: B = L⁺A\nL⁺ is an elliptic operator involving ∂²/∂z² and kh²\n\nExample\n\nG = init_grid(par)\nS = init_state(G)\n\n# Access fields\nq_spectral = S.q          # Complex (nz, nx, ny)\nu_realspace = S.u         # Real (nz, nx, ny)\n\nSee also: init_state, Grid\n\n\n\n\n\n","category":"type"},{"location":"advanced/performance/#performance","page":"Performance Tips","title":"Performance Tips","text":"This page provides guidance for optimizing QGYBJ+.jl performance.","category":"section"},{"location":"advanced/performance/#Quick-Performance-Wins","page":"Performance Tips","title":"Quick Performance Wins","text":"","category":"section"},{"location":"advanced/performance/#1.-Use-FFTW-Wisdom","page":"Performance Tips","title":"1. Use FFTW Wisdom","text":"Pre-compute optimal FFT plans:\n\nusing FFTW\n\n# Measure FFT plans (slower startup, faster runtime)\nFFTW.set_num_threads(Threads.nthreads())\nplans = plan_transforms!(grid; flags=FFTW.MEASURE)\n\n# For production: save and load wisdom\nFFTW.export_wisdom(\"fftw_wisdom.txt\")\n# Later:\nFFTW.import_wisdom(\"fftw_wisdom.txt\")","category":"section"},{"location":"advanced/performance/#2.-Enable-Multi-threading","page":"Performance Tips","title":"2. Enable Multi-threading","text":"# Set threads before running Julia\nexport JULIA_NUM_THREADS=8\njulia --threads=8 simulation.jl\n\nIn Julia:\n\n# Check thread count\nThreads.nthreads()\n\n# FFTW uses its own threading\nFFTW.set_num_threads(8)","category":"section"},{"location":"advanced/performance/#3.-Use-Appropriate-Precision","page":"Performance Tips","title":"3. Use Appropriate Precision","text":"# Double precision (default, most accurate)\nstate = init_state(grid)\n\n# Single precision (2x memory savings, faster)\n# Note: Requires initializing parameters and grid with Float32\n\nwarning: Warning\nSingle precision may cause numerical instabilities for long simulations.","category":"section"},{"location":"advanced/performance/#Memory-Optimization","page":"Performance Tips","title":"Memory Optimization","text":"","category":"section"},{"location":"advanced/performance/#Pre-allocation","page":"Performance Tips","title":"Pre-allocation","text":"All arrays are pre-allocated to avoid GC:\n\n# All arrays are pre-allocated in setup_model()\nG, S, plans, a_ell = setup_model(params)\n\n# Reused every time step\nleapfrog_step!(S, G, params, plans, a_ell)","category":"section"},{"location":"advanced/performance/#Memory-Usage-Estimate","page":"Performance Tips","title":"Memory Usage Estimate","text":"function estimate_memory(nx, ny, nz; T=Float64)\n    # Main arrays\n    complex_size = sizeof(Complex{T}) * (nx÷2+1) * ny * nz\n    real_size = sizeof(T) * nx * ny * nz\n\n    n_complex = 10  # psi, q, B, A, etc.\n    n_real = 5      # u, v, work arrays\n\n    total = n_complex * complex_size + n_real * real_size\n    return total / 1e9  # GB\nend\n\nprintln(\"Memory: \", estimate_memory(256, 256, 128), \" GB\")","category":"section"},{"location":"advanced/performance/#Memory-Efficient-Output","page":"Performance Tips","title":"Memory-Efficient Output","text":"Write in chunks rather than storing everything:\n\n# Don't do this (stores all data)\nall_psi = zeros(nx, ny, nz, nsteps)\n\n# Do this (stream to disk)\nfor step = 1:nsteps\n    timestep!(state, ...)\n    if step % output_interval == 0\n        write_to_disk(state.psi, step)\n    end\nend","category":"section"},{"location":"advanced/performance/#Computational-Bottlenecks","page":"Performance Tips","title":"Computational Bottlenecks","text":"","category":"section"},{"location":"advanced/performance/#Profiling","page":"Performance Tips","title":"Profiling","text":"using Profile\n\n@profile run_simulation(config)\nProfile.print(mincount=100)\n\n# Flamegraph visualization\nusing ProfileSVG\nProfileSVG.save(\"profile.svg\")","category":"section"},{"location":"advanced/performance/#Typical-Time-Distribution","page":"Performance Tips","title":"Typical Time Distribution","text":"Operation Fraction Optimization\nFFT/IFFT 40-50% FFTW wisdom, threading\nTridiagonal solves 20-30% Pre-factorization\nArray operations 15-25% Loop fusion with @.\nI/O 5-10% Buffering, compression","category":"section"},{"location":"advanced/performance/#Timing-Individual-Components","page":"Performance Tips","title":"Timing Individual Components","text":"using BenchmarkTools\n\n# Time FFT\n@btime fft_forward!($work.tmp_k, $work.tmp, $plans)\n\n# Time elliptic solve\n@btime invert_q_to_psi!($state, $grid, $params, $a_ell)\n\n# Time full step\n@btime leapfrog_step!($S, $G, $params, $plans, $a_ell)","category":"section"},{"location":"advanced/performance/#Numerical-Efficiency","page":"Performance Tips","title":"Numerical Efficiency","text":"","category":"section"},{"location":"advanced/performance/#Time-Step-Selection","page":"Performance Tips","title":"Time Step Selection","text":"Use the largest stable time step:\n\n# CFL-based time step\nu_max = maximum(abs.(state.u))\ndt_cfl = 0.5 * grid.dx / u_max\n\n# Use slightly smaller for safety\ndt = 0.8 * dt_cfl","category":"section"},{"location":"advanced/performance/#Adaptive-Time-Stepping","page":"Performance Tips","title":"Adaptive Time Stepping","text":"function adaptive_dt(state, grid, params; cfl=0.5, dt_max=0.01)\n    u_max = maximum(abs.(state.u))\n    v_max = maximum(abs.(state.v))\n\n    dx = grid.Lx / grid.nx\n    dy = grid.Ly / grid.ny\n\n    dt = cfl * min(dx/u_max, dy/v_max)\n    return min(dt, dt_max)\nend","category":"section"},{"location":"advanced/performance/#Dissipation-Tuning","page":"Performance Tips","title":"Dissipation Tuning","text":"Too much dissipation wastes resolution. Too little causes instability.\n\n# Minimal dissipation for given resolution\nnu_h2 = 1e-4 * (2π/nx)^8  # Scales with grid spacing\n\n# Or based on energy pile-up check\nE_k = horizontal_energy_spectrum(state.psi, grid)\nif E_k[end] > 0.01 * maximum(E_k)\n    @warn \"Energy piling up at small scales, increase dissipation\"\nend","category":"section"},{"location":"advanced/performance/#Loop-Optimization","page":"Performance Tips","title":"Loop Optimization","text":"","category":"section"},{"location":"advanced/performance/#Broadcasting","page":"Performance Tips","title":"Broadcasting","text":"Use @. for fused operations:\n\n# Slow (multiple allocations)\nresult = a .+ b .* c\n\n# Fast (single pass, no allocation)\n@. result = a + b * c","category":"section"},{"location":"advanced/performance/#In-place-Operations","page":"Performance Tips","title":"In-place Operations","text":"# Allocating\nb = fft(a)\n\n# In-place\nmul!(b, plan, a)","category":"section"},{"location":"advanced/performance/#Loop-Order","page":"Performance Tips","title":"Loop Order","text":"Julia is column-major (like Fortran):\n\n# Fast (memory-contiguous)\nfor k in 1:nz\n    for j in 1:ny\n        for i in 1:nx\n            a[k, i, j] = ...\n        end\n    end\nend\n\n# Slow (cache-unfriendly)\nfor i in 1:nx\n    for j in 1:ny\n        for k in 1:nz\n            a[k, i, j] = ...\n        end\n    end\nend","category":"section"},{"location":"advanced/performance/#SIMD-and-LoopVectorization","page":"Performance Tips","title":"SIMD and LoopVectorization","text":"using LoopVectorization\n\n# Auto-vectorized loop\n@turbo for i in eachindex(a)\n    a[i] = b[i] * c[i] + d[i]\nend","category":"section"},{"location":"advanced/performance/#GPU-Acceleration","page":"Performance Tips","title":"GPU Acceleration","text":"","category":"section"},{"location":"advanced/performance/#CUDA-Support","page":"Performance Tips","title":"CUDA Support","text":"using CUDA\n\n# Note: GPU support is experimental/future feature\n# Move arrays to GPU\nS_gpu = cu(S)\nG_gpu = cu(G)\n\n# GPU FFT plans\nplans_gpu = plan_gpu_transforms!(G_gpu)\n\n# Run on GPU\nleapfrog_step!(S_gpu, G_gpu, params, plans_gpu, a_ell_gpu)","category":"section"},{"location":"advanced/performance/#When-to-Use-GPU","page":"Performance Tips","title":"When to Use GPU","text":"Scenario Recommendation\nnx, ny < 256 CPU often faster\nnx, ny ≥ 512 GPU beneficial\nMany particles GPU for interpolation\nMPI cluster CPU per node","category":"section"},{"location":"advanced/performance/#Parallelization-Strategy","page":"Performance Tips","title":"Parallelization Strategy","text":"","category":"section"},{"location":"advanced/performance/#Shared-Memory-(OpenMP/Threads)","page":"Performance Tips","title":"Shared Memory (OpenMP/Threads)","text":"Best for:\n\nSingle node\nnx × ny < 512²\nMemory-bound operations\n\n# Set threads\nThreads.@threads for k in 1:nz\n    process_layer!(state, k)\nend","category":"section"},{"location":"advanced/performance/#Distributed-Memory-(MPI)","page":"Performance Tips","title":"Distributed Memory (MPI)","text":"Best for:\n\nMultiple nodes\nnx × ny ≥ 512²\nLarge domains\n\nmpiexec -n 64 julia simulation.jl","category":"section"},{"location":"advanced/performance/#Hybrid-(MPI-Threads)","page":"Performance Tips","title":"Hybrid (MPI + Threads)","text":"# 4 MPI ranks × 8 threads each = 32 cores\nexport JULIA_NUM_THREADS=8\nmpiexec -n 4 julia simulation.jl","category":"section"},{"location":"advanced/performance/#I/O-Performance","page":"Performance Tips","title":"I/O Performance","text":"","category":"section"},{"location":"advanced/performance/#Buffered-Output","page":"Performance Tips","title":"Buffered Output","text":"# Write less frequently\noutput_interval = 1000  # Not every step\n\n# Buffer multiple snapshots\nbuffer_size = 10\noutput_buffer = zeros(nx, ny, nz, buffer_size)","category":"section"},{"location":"advanced/performance/#Compression","page":"Performance Tips","title":"Compression","text":"using NCDatasets\n\n# Compressed NetCDF\ndefVar(ds, \"psi\", Float64, (\"x\", \"y\", \"z\", \"t\");\n    deflatelevel = 5,\n    chunksizes = (nx, ny, nz, 1)\n)","category":"section"},{"location":"advanced/performance/#Parallel-I/O","page":"Performance Tips","title":"Parallel I/O","text":"# HDF5 with MPI I/O\nusing HDF5\n\nh5open(\"output.h5\", \"w\", mpi_comm) do fid\n    write_mpi(fid, \"psi\", local_psi, global_dims, local_range)\nend","category":"section"},{"location":"advanced/performance/#Benchmarking-Guide","page":"Performance Tips","title":"Benchmarking Guide","text":"","category":"section"},{"location":"advanced/performance/#Full-Benchmark-Suite","page":"Performance Tips","title":"Full Benchmark Suite","text":"function benchmark_simulation(nx, ny, nz; nsteps=100, Lx=500e3, Ly=500e3, Lz=4000.0)\n    params = default_params(Lx=Lx, Ly=Ly, Lz=Lz, nx=nx, ny=ny, nz=nz)\n    G, S, plans, a_ell = setup_model(params)\n\n    # Initialize\n    init_random_psi!(S, G; amplitude=0.1)\n    compute_q_from_psi!(S, G, plans, a_ell)\n\n    # Warm-up\n    first_projection_step!(S, G, params, plans, a_ell)\n    for _ in 1:9\n        leapfrog_step!(S, G, params, plans, a_ell)\n    end\n\n    # Timed run\n    t_start = time()\n    for _ in 1:nsteps\n        leapfrog_step!(S, G, params, plans, a_ell)\n    end\n    t_end = time()\n\n    dt_avg = (t_end - t_start) / nsteps\n    throughput = nx * ny * nz / dt_avg / 1e6  # Million cells/second\n\n    return (dt_avg=dt_avg, throughput=throughput)\nend\n\n# Run benchmark\nresult = benchmark_simulation(128, 128, 64)\nprintln(\"Time per step: $(result.dt_avg*1000) ms\")\nprintln(\"Throughput: $(result.throughput) Mcells/s\")","category":"section"},{"location":"advanced/performance/#Scaling-Tests","page":"Performance Tips","title":"Scaling Tests","text":"# Strong scaling\nfor nprocs in [1, 2, 4, 8, 16]\n    # Run with mpiexec -n $nprocs\n    run_benchmark(256, 256, 128)\nend\n\n# Weak scaling\nfor n in [64, 128, 256, 512]\n    run_benchmark(n, n, n÷2)\nend","category":"section"},{"location":"advanced/performance/#Summary-Checklist","page":"Performance Tips","title":"Summary Checklist","text":"Before running:\n[ ] Set JULIA_NUM_THREADS appropriately\n[ ] Enable FFTW threading\n[ ] Use FFTW.MEASURE for plans\n[ ] Pre-allocate all arrays\nFor production:\n[ ] Profile to find bottlenecks\n[ ] Use appropriate time step (CFL)\n[ ] Minimize I/O frequency\n[ ] Enable compression for output\nFor large runs:\n[ ] Use MPI for distributed memory\n[ ] Consider GPU for large grids\n[ ] Use parallel I/O\n[ ] Monitor memory usage","category":"section"},{"location":"guide/simulation/#running","page":"Running Simulations","title":"Running Simulations","text":"This page explains how to run and monitor QGYBJ+.jl simulations.","category":"section"},{"location":"guide/simulation/#Quick-Start","page":"Running Simulations","title":"Quick Start","text":"","category":"section"},{"location":"guide/simulation/#Simple-Interface","page":"Running Simulations","title":"Simple Interface","text":"using QGYBJplus\n\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # Domain size (REQUIRED)\n    nx=64, ny=64, nz=32,\n    dt=0.001,\n    total_time=10.0\n)\n\nresult = run_simple_simulation(config)","category":"section"},{"location":"guide/simulation/#Manual-Control","page":"Running Simulations","title":"Manual Control","text":"using QGYBJplus\n\n# Setup with domain size (REQUIRED)\npar = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    nx=64, ny=64, nz=32,\n    dt=0.001, nt=10000\n)\nG, S, plans, a_ell = setup_model(par)\n\n# Initialize\ninit_random_psi!(S, G; amplitude=0.1)\ncompute_q_from_psi!(S, G, plans, a_ell)\n\n# Time loop\nfirst_projection_step!(S, G, par, plans, a_ell)\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\nend","category":"section"},{"location":"guide/simulation/#Time-Stepping","page":"Running Simulations","title":"Time Stepping","text":"","category":"section"},{"location":"guide/simulation/#Available-Schemes","page":"Running Simulations","title":"Available Schemes","text":"Scheme Description Best For\n:leapfrog Explicit, 2nd order, Robert-Asselin filter dt ≤ 2f/N² (~2s), academic tests\n:imex_cn IMEX Crank-Nicolson with operator splitting Large dt (~20s), production runs","category":"section"},{"location":"guide/simulation/#Using-run_simulation!-(Recommended)","page":"Running Simulations","title":"Using run_simulation! (Recommended)","text":"# Leapfrog (default)\nrun_simulation!(S, G, par, plans;\n    timestepper=:leapfrog, ...)\n\n# IMEX-CN (10x larger timestep)\nrun_simulation!(S, G, par, plans;\n    timestepper=:imex_cn, ...)","category":"section"},{"location":"guide/simulation/#Manual-Time-Loop-(Leapfrog)","page":"Running Simulations","title":"Manual Time Loop (Leapfrog)","text":"# First step uses forward Euler\nfirst_projection_step!(S, G, par, plans, a_ell)\n\n# Subsequent steps use leapfrog\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\nend","category":"section"},{"location":"guide/simulation/#Manual-Time-Loop-(IMEX-CN)","page":"Running Simulations","title":"Manual Time Loop (IMEX-CN)","text":"imex_ws = init_imex_workspace(S, G)\nSnp1 = copy_state(S)\n\nfor step = 1:par.nt\n    imex_cn_step!(Snp1, S, G, par, plans, imex_ws;\n                  a=a_ell, dealias_mask=L,\n                  workspace=workspace, N2_profile=N2)\n\n    # Copy for next step (only 2 time levels needed)\n    parent(S.B) .= parent(Snp1.B)\n    parent(S.A) .= parent(Snp1.A)\n    parent(S.q) .= parent(Snp1.q)\n    parent(S.psi) .= parent(Snp1.psi)\nend","category":"section"},{"location":"guide/simulation/#Choosing-a-Timestep","page":"Running Simulations","title":"Choosing a Timestep","text":"Scheme Stability Constraint Typical dt\nLeapfrog dt ≤ min(2f/N², dx/U) ~2s (dispersion-limited)\nIMEX-CN dt ≤ dx/U ~20s (advection CFL only)\n\nEach time step performs:\n\nCompute nonlinear terms (Jacobians, refraction)\nApply dissipation via integrating factors\nUpdate prognostic variables (q, B)\nInvert elliptic equations (q→ψ, B→A)\nCompute velocities","category":"section"},{"location":"guide/simulation/#Progress-Monitoring","page":"Running Simulations","title":"Progress Monitoring","text":"","category":"section"},{"location":"guide/simulation/#Basic-Progress","page":"Running Simulations","title":"Basic Progress","text":"for step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n\n    if step % 100 == 0\n        println(\"Step $step / $(par.nt) ($(100*step/par.nt)%)\")\n    end\nend","category":"section"},{"location":"guide/simulation/#With-Diagnostics","page":"Running Simulations","title":"With Diagnostics","text":"for step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n\n    if step % 100 == 0\n        compute_velocities!(S, G, plans)\n        KE = flow_kinetic_energy(S.u, S.v)\n        WE_B, WE_A = wave_energy(S.B, S.A)\n        println(\"Step $step: KE=$KE, WE_B=$WE_B\")\n    end\nend","category":"section"},{"location":"guide/simulation/#Progress-Bar","page":"Running Simulations","title":"Progress Bar","text":"using ProgressMeter\n\n@showprogress for step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\nend","category":"section"},{"location":"guide/simulation/#Checkpointing","page":"Running Simulations","title":"Checkpointing","text":"","category":"section"},{"location":"guide/simulation/#Save-Checkpoints","page":"Running Simulations","title":"Save Checkpoints","text":"using JLD2\n\ncheckpoint_interval = 1000\n\nfirst_projection_step!(S, G, par, plans, a_ell)\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n\n    if step % checkpoint_interval == 0\n        filename = \"checkpoint_$(lpad(step, 8, '0')).jld2\"\n        @save filename S G par step\n    end\nend","category":"section"},{"location":"guide/simulation/#Restart-from-Checkpoint","page":"Running Simulations","title":"Restart from Checkpoint","text":"using JLD2\n\n# Load checkpoint\n@load \"checkpoint_00005000.jld2\" S G par step\n\n# Continue simulation\nfor step = step+1:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\nend","category":"section"},{"location":"guide/simulation/#Stability-Monitoring","page":"Running Simulations","title":"Stability Monitoring","text":"","category":"section"},{"location":"guide/simulation/#CFL-Check","page":"Running Simulations","title":"CFL Check","text":"function check_cfl(S, G, dt)\n    u_max = maximum(abs.(S.u))\n    v_max = maximum(abs.(S.v))\n    cfl = dt * max(u_max/G.dx, v_max/G.dy)\n    return cfl\nend\n\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n    compute_velocities!(S, G, plans)\n\n    cfl = check_cfl(S, G, par.dt)\n    if cfl > 1.0\n        @warn \"CFL > 1 at step $step: $cfl\"\n    end\nend","category":"section"},{"location":"guide/simulation/#Energy-Conservation","page":"Running Simulations","title":"Energy Conservation","text":"compute_velocities!(S, G, plans)\nE0 = flow_kinetic_energy(S.u, S.v)\n\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n\n    if step % 100 == 0\n        compute_velocities!(S, G, plans)\n        E = flow_kinetic_energy(S.u, S.v)\n        dE = (E - E0) / E0\n        if abs(dE) > 0.1\n            @warn \"Energy drift: $dE at step $step\"\n        end\n    end\nend","category":"section"},{"location":"guide/simulation/#Output-During-Simulation","page":"Running Simulations","title":"Output During Simulation","text":"","category":"section"},{"location":"guide/simulation/#Snapshots-with-NetCDF","page":"Running Simulations","title":"Snapshots with NetCDF","text":"using QGYBJplus\n\noutput_interval = 100\n\nfirst_projection_step!(S, G, par, plans, a_ell)\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n    time = step * par.dt\n\n    if step % output_interval == 0\n        # Save streamfunction\n        ncdump_psi(S, G, step, time, \"output/\")\n\n        # Save wave envelope\n        ncdump_la(S, G, step, time, \"output/\")\n    end\nend","category":"section"},{"location":"guide/simulation/#Time-Series","page":"Running Simulations","title":"Time Series","text":"KE_history = Float64[]\nWE_history = Float64[]\ntime_history = Float64[]\n\nfor step = 2:par.nt\n    leapfrog_step!(S, G, par, plans, a_ell)\n\n    push!(time_history, step * par.dt)\n    compute_velocities!(S, G, plans)\n    push!(KE_history, flow_kinetic_energy(S.u, S.v))\n    push!(WE_history, wave_energy(S.B, S.A)[1])\nend","category":"section"},{"location":"guide/simulation/#Using-the-High-Level-API","page":"Running Simulations","title":"Using the High-Level API","text":"","category":"section"},{"location":"guide/simulation/#QGYBJSimulation","page":"Running Simulations","title":"QGYBJSimulation","text":"using QGYBJplus\n\n# Create configuration\ndomain = create_domain_config(\n    nx=64, ny=64, nz=32,\n    Lx=500e3, Ly=500e3, Lz=4000.0\n)\n\nstrat = create_stratification_config(type=:constant_N)\n\nmodel = create_model_config(\n    ybj_plus=true,\n    inviscid=false\n)\n\noutput = create_output_config(\n    output_dir=\"output\",\n    output_interval=100\n)\n\n# Setup simulation\nsim = setup_simulation(domain, strat; model=model, output=output)\n\n# Run\nrun_simulation!(sim, dt=0.001, nsteps=10000)","category":"section"},{"location":"guide/simulation/#Parallel-Execution","page":"Running Simulations","title":"Parallel Execution","text":"","category":"section"},{"location":"guide/simulation/#Multi-threaded-(FFTs)","page":"Running Simulations","title":"Multi-threaded (FFTs)","text":"# Set before starting Julia\nexport JULIA_NUM_THREADS=8\n\n# Or check in code\nprintln(\"Using $(Threads.nthreads()) threads\")","category":"section"},{"location":"guide/simulation/#MPI-with-2D-Pencil-Decomposition","page":"Running Simulations","title":"MPI with 2D Pencil Decomposition","text":"using MPI, PencilArrays, PencilFFTs, QGYBJplus\n\nMPI.Init()\nmpi_config = QGYBJplus.setup_mpi_environment()\n\n# Setup distributed simulation\nparams = default_params(\n    Lx=1000e3, Ly=1000e3, Lz=5000.0,\n    nx=256, ny=256, nz=128\n)\ngrid = QGYBJplus.init_mpi_grid(params, mpi_config)\nplans = QGYBJplus.plan_mpi_transforms(grid, mpi_config)\nstate = QGYBJplus.init_mpi_state(grid, plans, mpi_config)\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)\n\n# Run with: mpiexec -n 16 julia simulation.jl\n\nMPI.Finalize()\n\nSee MPI Parallelization for details.","category":"section"},{"location":"guide/simulation/#Common-Patterns","page":"Running Simulations","title":"Common Patterns","text":"","category":"section"},{"location":"guide/simulation/#Production-Run-Template","page":"Running Simulations","title":"Production Run Template","text":"using QGYBJplus\nusing JLD2\n\nfunction run_production(;\n    Lx, Ly, Lz,              # Domain size (REQUIRED)\n    nx, ny, nz,\n    dt, nsteps,\n    output_interval=100,\n    checkpoint_interval=1000,\n    output_dir=\"output\"\n)\n    # Setup\n    mkpath(output_dir)\n    par = default_params(\n        Lx=Lx, Ly=Ly, Lz=Lz,\n        nx=nx, ny=ny, nz=nz,\n        dt=dt, nt=nsteps\n    )\n    G, S, plans, a_ell = setup_model(par)\n\n    # Initialize\n    init_random_psi!(S, G; amplitude=0.1)\n    compute_q_from_psi!(S, G, plans, a_ell)\n\n    # Time loop\n    first_projection_step!(S, G, par, plans, a_ell)\n    for step = 2:nsteps\n        leapfrog_step!(S, G, par, plans, a_ell)\n\n        # Output\n        if step % output_interval == 0\n            ncdump_psi(S, G, step, step*dt, output_dir)\n        end\n\n        # Checkpoint\n        if step % checkpoint_interval == 0\n            @save \"$output_dir/checkpoint.jld2\" S G par step\n        end\n    end\n\n    return S\nend\n\n# Run\nrun_production(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    nx=64, ny=64, nz=32,\n    dt=0.001, nsteps=10000\n)","category":"section"},{"location":"guide/simulation/#Troubleshooting","page":"Running Simulations","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/simulation/#NaN-Values","page":"Running Simulations","title":"NaN Values","text":"if any(isnan, S.psi)\n    error(\"NaN detected at step $step\")\nend","category":"section"},{"location":"guide/simulation/#Instability","page":"Running Simulations","title":"Instability","text":"Switch to IMEX-CN: Use timestepper=:imex_cn for unconditional dispersion stability\nReduce time step (dt)\nIncrease dissipation (νₕ₂, ilap2)\nCheck initial conditions for sharp gradients","category":"section"},{"location":"guide/simulation/#Memory-Issues","page":"Running Simulations","title":"Memory Issues","text":"Reduce grid size\nUse checkpointing\nEnable MPI for distribution across nodes","category":"section"},{"location":"troubleshooting/#troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Quick-Diagnostic","page":"Troubleshooting","title":"Quick Diagnostic","text":"Symptom Check First\nWon't run Are Lx, Ly, Lz provided? (required)\nBlows up (NaN) Is dt small enough? Try dt/2\nWrong results Check ybj_plus=true vs false\nToo slow Use IMEX-CN instead of leapfrog\nOut of memory Reduce grid size or use MPI","category":"section"},{"location":"troubleshooting/#Installation","page":"Troubleshooting","title":"Installation","text":"Package not found: Install from GitHub:\n\nPkg.add(url=\"https://github.com/subhk/QGYBJplus.jl\")\n\nMPI fails: Install system MPI first:\n\nmacOS: brew install open-mpi\nUbuntu: sudo apt install libopenmpi-dev openmpi-bin\nHPC: module load openmpi\n\nThen: Pkg.build(\"MPI\")","category":"section"},{"location":"troubleshooting/#Runtime-Errors","page":"Troubleshooting","title":"Runtime Errors","text":"","category":"section"},{"location":"troubleshooting/#Missing-Domain-Size","page":"Troubleshooting","title":"Missing Domain Size","text":"# Wrong - MethodError\npar = default_params(nx=64, ny=64, nz=32)\n\n# Correct\npar = default_params(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)","category":"section"},{"location":"troubleshooting/#Simulation-Blows-Up-(NaN)","page":"Troubleshooting","title":"Simulation Blows Up (NaN)","text":"Reduce time step: dt = dt / 2\nIncrease dissipation: νₕ₁ = 1e8, ilap1 = 2\nUse IMEX for wave-dominated problems: imex_cn_step!() instead of leapfrog_step!()\nDebug with linear mode: par = default_params(..., linear=true)\n\ntip: Wave CFL\nFor YBJ+: dt ≤ 2f₀/N². For ocean values: dt ≤ 20s.","category":"section"},{"location":"troubleshooting/#Out-of-Memory","page":"Troubleshooting","title":"Out of Memory","text":"Reduce grid: nx, ny, nz = 128, 128, 64\nUse MPI: mpiexec -n 16 julia script.jl\nUse Float32: par = default_params(..., T=Float32)\n\nMemory: 256³ complex array ≈ 1 GB. Full simulation needs 5-10× this.","category":"section"},{"location":"troubleshooting/#MPI-Issues","page":"Troubleshooting","title":"MPI Issues","text":"Pencil topology mismatch: Use copy_state(S) not deepcopy(S):\n\nSnm1 = copy_state(S)  # Correct\n\nDeadlock: Ensure all ranks call collective operations. Debug with:\n\nMPI.Barrier(comm)\nprintln(\"Rank $(MPI.Comm_rank(comm)) reached checkpoint\")\n\nSegfaults: Use actual array dimensions, not grid dimensions:\n\nnz_phys, nx_phys, ny_phys = size(parent(phys_arr))","category":"section"},{"location":"troubleshooting/#Unicode-Characters","page":"Troubleshooting","title":"Unicode Characters","text":"Type LaTeX + Tab in Julia REPL:\n\nType Get\nf\\_0<tab> f₀\n\\nu<tab> ν\nN\\^2<tab> N²","category":"section"},{"location":"troubleshooting/#Performance","page":"Troubleshooting","title":"Performance","text":"Use IMEX time stepping (10× faster for waves)\nRun with threads: julia -t auto script.jl\nUse MPI for large grids\nReduce output frequency","category":"section"},{"location":"troubleshooting/#Stability:-Hyperdiffusion","page":"Troubleshooting","title":"Stability: Hyperdiffusion","text":"par = default_params(\n    ...,\n    νₕ₁ʷ = 1e7, ilap1w = 2,  # Biharmonic (recommended)\n    γ = 0.01                  # Stronger Robert-Asselin filter\n)\n\nHigher ilap = more scale-selective: ilap=1 (∇²), ilap=2 (∇⁴), ilap=4 (∇⁸)","category":"section"},{"location":"troubleshooting/#Still-Stuck?","page":"Troubleshooting","title":"Still Stuck?","text":"Open an issue with:\n\nJulia version, package versions\nMinimal reproducible example\nFull error message","category":"section"},{"location":"advanced/interpolation/#interpolation","page":"Interpolation","title":"Interpolation Methods","text":"This page describes interpolation methods available in QGYBJ+.jl.","category":"section"},{"location":"advanced/interpolation/#Overview","page":"Interpolation","title":"Overview","text":"Interpolation is needed for:\n\nParticle advection: Evaluating velocities at particle positions\nOutput: Sampling fields at specific locations\nRegridding: Transferring data between grids","category":"section"},{"location":"advanced/interpolation/#Available-Methods","page":"Interpolation","title":"Available Methods","text":"","category":"section"},{"location":"advanced/interpolation/#Nearest-Neighbor","page":"Interpolation","title":"Nearest Neighbor","text":"Fastest but lowest accuracy:\n\nvalue = interpolate(field, x, y, z, grid; method=:nearest)\n\nOrder: 0\nContinuity: None (discontinuous)\nBest for: Quick visualization, large particle counts","category":"section"},{"location":"advanced/interpolation/#Trilinear","page":"Interpolation","title":"Trilinear","text":"Standard method for smooth fields:\n\nvalue = interpolate(field, x, y, z, grid; method=:linear)\n\nOrder: 1\nContinuity: C⁰ (continuous values, discontinuous derivatives)\nBest for: General-purpose interpolation","category":"section"},{"location":"advanced/interpolation/#Tricubic","page":"Interpolation","title":"Tricubic","text":"High-accuracy interpolation:\n\nvalue = interpolate(field, x, y, z, grid; method=:cubic)\n\nOrder: 3\nContinuity: C¹ (continuous first derivatives)\nBest for: Accurate particle trajectories, smooth fields","category":"section"},{"location":"advanced/interpolation/#Spectral","page":"Interpolation","title":"Spectral","text":"Exact for band-limited fields:\n\nvalue = interpolate_spectral(field_k, x, y, z, grid, plans)\n\nOrder: Spectral (N)\nContinuity: C^∞\nBest for: Highest accuracy, single-point queries","category":"section"},{"location":"advanced/interpolation/#Batch-Interpolation","page":"Interpolation","title":"Batch Interpolation","text":"For many points (e.g., particles):\n\n# Pre-allocate output\nvalues = zeros(nparticles)\n\n# Batch interpolation\ninterpolate_batch!(values, field, xs, ys, zs, grid; method=:linear)","category":"section"},{"location":"advanced/interpolation/#Performance-Comparison","page":"Interpolation","title":"Performance Comparison","text":"Method Points/second Memory\nNearest 10⁸ Minimal\nLinear 10⁷ Minimal\nCubic 10⁶ 64 coeff/point\nSpectral 10⁴ Full field","category":"section"},{"location":"advanced/interpolation/#Horizontal-Interpolation","page":"Interpolation","title":"Horizontal Interpolation","text":"For 2D slices:\n\n# At fixed depth\nvalue_xy = interpolate_horizontal(field[:,:,k], x, y, grid; method=:linear)","category":"section"},{"location":"advanced/interpolation/#Vertical-Interpolation","page":"Interpolation","title":"Vertical Interpolation","text":"Along the vertical:\n\n# At fixed horizontal position\nvalue_z = interpolate_vertical(field[i,j,:], z, grid; method=:linear)","category":"section"},{"location":"advanced/interpolation/#Spectral-Interpolation","page":"Interpolation","title":"Spectral Interpolation","text":"","category":"section"},{"location":"advanced/interpolation/#Theory","page":"Interpolation","title":"Theory","text":"For a spectral field:\n\nf(xyz) = sum_k_x k_y hatf(k_x k_y z) e^i(k_x x + k_y y)","category":"section"},{"location":"advanced/interpolation/#Implementation","page":"Interpolation","title":"Implementation","text":"function interpolate_spectral(field_k, x, y, z, grid, plans)\n    # Compute phase factors\n    phases = exp.(im .* (grid.kx .* x .+ grid.ky' .* y))\n\n    # Find vertical indices\n    k_lo, k_hi, wz = find_vertical_cell(z, grid)\n\n    # Interpolate vertically\n    field_z = (1-wz) .* field_k[:,:,k_lo] .+ wz .* field_k[:,:,k_hi]\n\n    # Sum over wavenumbers\n    return real(sum(field_z .* phases))\nend","category":"section"},{"location":"advanced/interpolation/#Stencil-Coefficients","page":"Interpolation","title":"Stencil Coefficients","text":"","category":"section"},{"location":"advanced/interpolation/#Linear-(8-point)","page":"Interpolation","title":"Linear (8-point)","text":"      z₁ -------- z₁\n      /|         /|\n     / |        / |\n   z₀ -------- z₀ |\n    |  y₁ -----|-- y₁\n    | /        | /\n    |/         |/\n   y₀ -------- y₀\n   x₀         x₁\n\nWeights: Product of 1D linear weights in each direction.","category":"section"},{"location":"advanced/interpolation/#Cubic-(64-point)","page":"Interpolation","title":"Cubic (64-point)","text":"Uses 4×4×4 stencil with Catmull-Rom spline weights.","category":"section"},{"location":"advanced/interpolation/#Boundary-Handling","page":"Interpolation","title":"Boundary Handling","text":"","category":"section"},{"location":"advanced/interpolation/#Periodic","page":"Interpolation","title":"Periodic","text":"Default for horizontal directions:\n\nx_wrapped = mod(x, grid.Lx)\ny_wrapped = mod(y, grid.Ly)","category":"section"},{"location":"advanced/interpolation/#Extrapolation","page":"Interpolation","title":"Extrapolation","text":"For vertical boundaries:\n\n# Clamp to domain\nz_clamped = clamp(z, 0, grid.H)\n\n# Or extrapolate linearly\nif z > grid.H\n    value = field[end] + (z - grid.H) * gradient[end]\nend","category":"section"},{"location":"advanced/interpolation/#Interpolation-for-Derivatives","page":"Interpolation","title":"Interpolation for Derivatives","text":"","category":"section"},{"location":"advanced/interpolation/#Gradient-Interpolation","page":"Interpolation","title":"Gradient Interpolation","text":"# Interpolate gradient components\ndudx = interpolate(dudx_field, x, y, z, grid)\ndudy = interpolate(dudy_field, x, y, z, grid)","category":"section"},{"location":"advanced/interpolation/#Directly-from-Spectral","page":"Interpolation","title":"Directly from Spectral","text":"function interpolate_gradient_spectral(field_k, x, y, z, grid, plans)\n    # Compute spectral derivatives\n    dfdx_k = im .* grid.kx .* field_k\n    dfdy_k = im .* grid.ky' .* field_k\n\n    # Interpolate both\n    dfdx = interpolate_spectral(dfdx_k, x, y, z, grid, plans)\n    dfdy = interpolate_spectral(dfdy_k, x, y, z, grid, plans)\n\n    return dfdx, dfdy\nend","category":"section"},{"location":"advanced/interpolation/#Regridding","page":"Interpolation","title":"Regridding","text":"","category":"section"},{"location":"advanced/interpolation/#To-Finer-Grid","page":"Interpolation","title":"To Finer Grid","text":"function regrid_fine(field_coarse, grid_coarse, grid_fine)\n    field_fine = zeros(grid_fine.nx, grid_fine.ny, grid_fine.nz)\n\n    for k in 1:grid_fine.nz\n        for j in 1:grid_fine.ny\n            for i in 1:grid_fine.nx\n                x = grid_fine.x[i]\n                y = grid_fine.y[j]\n                z = grid_fine.z[k]\n                field_fine[k,i,j] = interpolate(field_coarse, x, y, z,\n                                                 grid_coarse)\n            end\n        end\n    end\n\n    return field_fine\nend","category":"section"},{"location":"advanced/interpolation/#Spectral-Padding","page":"Interpolation","title":"Spectral Padding","text":"For spectral fields, zero-pad in wavenumber space:\n\nfunction spectral_refine(field_k_coarse, grid_coarse, grid_fine)\n    field_k_fine = zeros(ComplexF64, grid_fine.nx÷2+1, grid_fine.ny, grid_fine.nz)\n\n    # Copy low wavenumbers\n    nkx = grid_coarse.nx÷2+1\n    nky = grid_coarse.ny\n\n    field_k_fine[1:nkx, 1:nky÷2, :] = field_k_coarse[:, 1:nky÷2, :]\n    field_k_fine[1:nkx, end-nky÷2+1:end, :] = field_k_coarse[:, nky÷2+1:end, :]\n\n    return field_k_fine\nend","category":"section"},{"location":"advanced/interpolation/#API-Reference","page":"Interpolation","title":"API Reference","text":"The interpolation functionality is provided through the particle advection system. See interpolate_velocity_at_position in the particles module for the main interpolation interface used for Lagrangian particle tracking.","category":"section"},{"location":"api/grid_state/#api-grid-state","page":"Grid & State","title":"Grid & State","text":"This page documents the core data structures: Grid and State.","category":"section"},{"location":"api/grid_state/#Grid-Type","page":"Grid & State","title":"Grid Type","text":"The Grid struct contains spatial coordinates, spectral wavenumbers, and parallel decomposition information.","category":"section"},{"location":"api/grid_state/#Definition","page":"Grid & State","title":"Definition","text":"mutable struct Grid{T, AT}\n    # Grid dimensions\n    nx::Int                # Number of points in x (horizontal)\n    ny::Int                # Number of points in y (horizontal)\n    nz::Int                # Number of points in z (vertical)\n\n    # Domain sizes\n    Lx::T                  # Domain size in x\n    Ly::T                  # Domain size in y\n\n    # Grid spacings\n    dx::T                  # Grid spacing in x: dx = Lx/nx\n    dy::T                  # Grid spacing in y: dy = Ly/ny\n\n    # Vertical grid (staggered, cell-centered)\n    z::Vector{T}           # Vertical levels z[k], size nz\n    dz::Vector{T}          # Layer thicknesses: dz[k] = z[k+1] - z[k], size nz-1\n\n    # Spectral wavenumbers\n    kx::Vector{T}          # x-wavenumbers, size nx\n    ky::Vector{T}          # y-wavenumbers, size ny\n    kh2::AT                # kx² + ky² on spectral grid\n\n    # MPI decomposition (PencilArrays)\n    decomp::Any            # PencilDecomp or nothing for serial\nend","category":"section"},{"location":"api/grid_state/#Type-Parameters","page":"Grid & State","title":"Type Parameters","text":"T: Floating point type (typically Float64)\nAT: Array type for kh2 (Array{T,2} for serial, PencilArray{T,3} for parallel)","category":"section"},{"location":"api/grid_state/#Constructors","page":"Grid & State","title":"Constructors","text":"# Initialize from parameters (serial mode)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\ngrid = init_grid(params)\n\n# Initialize with MPI decomposition\nusing MPI, PencilArrays, PencilFFTs\nMPI.Init()\nmpi_config = QGYBJplus.setup_mpi_environment()\ngrid = QGYBJplus.init_mpi_grid(params, mpi_config)","category":"section"},{"location":"api/grid_state/#Grid-Properties","page":"Grid & State","title":"Grid Properties","text":"# Dimensions\nnx, ny, nz = grid.nx, grid.ny, grid.nz\n\n# Domain size\nLx, Ly = grid.Lx, grid.Ly\n\n# Grid spacings\ndx, dy = grid.dx, grid.dy\n\n# Vertical levels (staggered grid: z runs from -Lz+dz/2 to -dz/2 with dz = Lz/nz)\nz = grid.z       # Vector of length nz\ndz = grid.dz     # Vector of length nz-1\n# Unstaggered (face) levels used for coefficients: z_face = z .- (grid.Lz / grid.nz) / 2\n\n# Check if parallel\nis_parallel = grid.decomp !== nothing","category":"section"},{"location":"api/grid_state/#Wavenumber-Access","page":"Grid & State","title":"Wavenumber Access","text":"# Wavenumber vectors (global, same on all processes)\nkx = grid.kx     # Vector of length nx\nky = grid.ky     # Vector of length ny\n\n# Horizontal wavenumber squared\n# Serial: 2D array (nx, ny)\n# Parallel: 3D PencilArray (local_nz, local_nx, local_ny)\nkh2 = grid.kh2\n\n# Convenience functions (handle serial/parallel automatically)\nkx_val = get_kx(i_local, grid)    # Get kx for local index\nky_val = get_ky(j_local, grid)    # Get ky for local index\nkh2_val = get_kh2(i, j, k, arr, grid)  # Get kh² for local indices","category":"section"},{"location":"api/grid_state/#Index-Mapping-(Parallel)","page":"Grid & State","title":"Index Mapping (Parallel)","text":"When using parallel decomposition, local indices must be mapped to global indices:\n\n# Get local index ranges (xy-pencil / FFT input)\nlocal_range = get_local_range(grid)   # (k_range, i_range, j_range)\n\n# Map local to global indices for a given array's pencil\ni_global = local_to_global(i_local, 2, field)  # x dimension\nj_global = local_to_global(j_local, 3, field)  # y dimension\nk_global = local_to_global(k_local, 1, field)  # z dimension\n\n# Map local to global indices (z-pencil)\ni_global = local_to_global_z(i_local, 2, grid)\nj_global = local_to_global_z(j_local, 3, grid)\n\n# Get local dimensions of any array\nnz_local, nx_local, ny_local = get_local_dims(arr)\n\n# Check if array is parallel\nis_distributed = is_parallel_array(arr)","category":"section"},{"location":"api/grid_state/#Decomposition-Access","page":"Grid & State","title":"Decomposition Access","text":"# Access decomposition (parallel mode only)\nif grid.decomp !== nothing\n    decomp = grid.decomp\n\n    # Pencil configurations\n    pencil_xy = decomp.pencil_xy   # For horizontal FFTs\n    pencil_z = decomp.pencil_z     # For vertical operations\n\n    # Local ranges\n    range_xy = decomp.local_range_xy\n    range_z = decomp.local_range_z\n\n    # Global dimensions\n    global_dims = decomp.global_dims   # (nz, nx, ny)\n\n    # Process topology\n    topology = decomp.topology   # (px, py)\nend","category":"section"},{"location":"api/grid_state/#State-Type","page":"Grid & State","title":"State Type","text":"The State struct contains all prognostic and diagnostic fields.","category":"section"},{"location":"api/grid_state/#Definition-2","page":"Grid & State","title":"Definition","text":"mutable struct State{T, RT<:AbstractArray{T,3}, CT<:AbstractArray{Complex{T},3}}\n    # Prognostic fields (spectral space, complex)\n    q::CT           # QG potential vorticity\n    B::CT           # YBJ+ wave envelope (B = L⁺A)\n\n    # Diagnostic fields (spectral space, complex)\n    psi::CT         # Streamfunction (from q via inversion)\n    A::CT           # Wave amplitude (from B via YBJ+ inversion)\n    C::CT           # Vertical derivative A_z\n\n    # Velocity fields (real space, real)\n    u::RT           # Zonal velocity: u = -dψ/dy\n    v::RT           # Meridional velocity: v = dψ/dx\n    w::RT           # Vertical velocity (from omega equation)\nend","category":"section"},{"location":"api/grid_state/#Type-Parameters-2","page":"Grid & State","title":"Type Parameters","text":"T: Floating point type (Float64)\nRT: Real array type (Array{T,3} or PencilArray{T,3})\nCT: Complex array type (Array{Complex{T},3} or PencilArray{Complex{T},3})","category":"section"},{"location":"api/grid_state/#Constructors-2","page":"Grid & State","title":"Constructors","text":"# Initialize from grid (serial mode)\nstate = init_state(grid)\n\n# Initialize with MPI (parallel mode)\nplans = QGYBJplus.plan_mpi_transforms(grid, mpi_config)\nstate = QGYBJplus.init_mpi_state(grid, plans, mpi_config)","category":"section"},{"location":"api/grid_state/#Field-Access","page":"Grid & State","title":"Field Access","text":"# Prognostic fields (time-stepped)\nq = state.q      # QG potential vorticity (spectral)\nB = state.B      # Wave envelope (spectral)\n\n# Diagnostic fields (computed)\npsi = state.psi  # Streamfunction (spectral)\nA = state.A      # Wave amplitude (spectral)\nC = state.C      # Vertical derivative dA/dz (spectral)\n\n# Velocity fields (real space)\nu = state.u      # Zonal velocity\nv = state.v      # Meridional velocity\nw = state.w      # Vertical velocity","category":"section"},{"location":"api/grid_state/#Working-with-Arrays","page":"Grid & State","title":"Working with Arrays","text":"# Get underlying data (works for both Array and PencilArray)\npsi_data = parent(state.psi)\n\n# Get local dimensions\nnz_local, nx_local, ny_local = size(parent(state.psi))\n\n# Access single element\nval = state.psi[k, i, j]\n\n# Access slice\ntop_level = state.psi[end, :, :]  # Closest level to the surface\nprofile = state.psi[:, i, j]\n\n# Set values\nstate.psi[k, i, j] = complex_value\nstate.psi[end, :, :] .= top_values\n\n# Copy all of one field\nstate.psi .= initial_psi","category":"section"},{"location":"api/grid_state/#Physical-Interpretation","page":"Grid & State","title":"Physical Interpretation","text":"Field Symbol Physical Meaning\nq q QG potential vorticity: q = nabla²psi + (f²/N²)d²psi/dz²\nB B YBJ+ wave envelope: B = L⁺A\npsi psi Streamfunction\nA A Wave amplitude\nC dA/dz Vertical derivative of wave amplitude\nu u Zonal velocity: u = -dpsi/dy\nv v Meridional velocity: v = dpsi/dx\nw w Vertical velocity (from omega equation or YBJ)","category":"section"},{"location":"api/grid_state/#MPI-Workspace","page":"Grid & State","title":"MPI Workspace","text":"For 2D parallel decomposition, workspace arrays store z-pencil data:","category":"section"},{"location":"api/grid_state/#Definition-3","page":"Grid & State","title":"Definition","text":"struct MPIWorkspace{T, PA}\n    q_z::PA      # q in z-pencil configuration\n    psi_z::PA    # psi in z-pencil configuration\n    B_z::PA      # B in z-pencil configuration\n    A_z::PA      # A in z-pencil configuration\n    C_z::PA      # C in z-pencil configuration\n    work_z::PA   # General workspace\nend","category":"section"},{"location":"api/grid_state/#Constructor","page":"Grid & State","title":"Constructor","text":"# Initialize workspace (parallel mode only)\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)","category":"section"},{"location":"api/grid_state/#Usage","page":"Grid & State","title":"Usage","text":"# Pass workspace to functions requiring vertical operations\ninvert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\ninvert_B_to_A!(state, grid, params, a_vec; workspace=workspace)\ncompute_vertical_velocity!(state, grid, plans, params; workspace=workspace)","category":"section"},{"location":"api/grid_state/#Allocating-Arrays","page":"Grid & State","title":"Allocating Arrays","text":"","category":"section"},{"location":"api/grid_state/#Serial-Mode","page":"Grid & State","title":"Serial Mode","text":"# Allocate using grid\nq = allocate_field(Float64, grid; complex=true)   # Complex spectral\nu = allocate_field(Float64, grid; complex=false)  # Real physical","category":"section"},{"location":"api/grid_state/#Parallel-Mode","page":"Grid & State","title":"Parallel Mode","text":"# Allocate in xy-pencil (for FFTs, horizontal operations)\narr_xy = QGYBJplus.allocate_xy_pencil(grid, ComplexF64)\n\n# Allocate in z-pencil (for vertical operations)\narr_z = QGYBJplus.allocate_z_pencil(grid, ComplexF64)\n\n# Allocate FFT backward destination (handles spectral→physical pencil difference)\nphys_arr = QGYBJplus.allocate_fft_backward_dst(spectral_arr, plans)","category":"section"},{"location":"api/grid_state/#FFT-Backward-Destination-Allocation","page":"Grid & State","title":"FFT Backward Destination Allocation","text":"In 2D MPI decomposition, spectral arrays (FFT output pencil) and physical arrays (FFT input pencil) may have different local dimensions. Use allocate_fft_backward_dst to correctly allocate the destination for fft_backward!:\n\n# Allocate physical-space destination for backward FFT\nphys = allocate_fft_backward_dst(spectral_arr, plans)\n\n# Now safe to transform\nfft_backward!(phys, spectral_arr, plans)\n\n# Loop over physical array with correct dimensions\nnz_phys, nx_phys, ny_phys = size(parent(phys))\nfor k in 1:nz_phys, j in 1:ny_phys, i in 1:nx_phys\n    # Access phys[k, i, j]\nend","category":"section"},{"location":"api/grid_state/#Utility-Functions","page":"Grid & State","title":"Utility Functions","text":"","category":"section"},{"location":"api/grid_state/#Grid-Utilities","page":"Grid & State","title":"Grid Utilities","text":"# Compute wavenumbers (after changing Lx, Ly)\ncompute_wavenumbers!(grid)\n\n# Get dealiasing mask\nmask = dealias_mask(grid)  # 2D Bool array (nx, ny)","category":"section"},{"location":"api/grid_state/#State-Utilities","page":"Grid & State","title":"State Utilities","text":"# Zero all fields\nfill!(state.q, 0)\nfill!(state.B, 0)\nfill!(state.psi, 0)\n\n# Check for NaN\nhas_nan = any(isnan, parent(state.psi))","category":"section"},{"location":"api/grid_state/#Serial-vs-Parallel-Comparison","page":"Grid & State","title":"Serial vs Parallel Comparison","text":"Operation Serial Parallel\nGrid initialization init_grid(params) init_mpi_grid(params, mpi_config)\nState initialization init_state(grid) init_mpi_state(grid, plans, mpi_config)\nArray type Array{T,3} PencilArray{T,3}\nIndex access Direct arr[k,i,j] Via parent(arr)[k,i,j]\nWavenumber lookup Direct grid.kx[i] grid.kx[local_to_global(i,2,grid)]\ngrid.decomp nothing PencilDecomp struct","category":"section"},{"location":"api/grid_state/#API-Reference","page":"Grid & State","title":"API Reference","text":"","category":"section"},{"location":"api/grid_state/#Grid-Initialization","page":"Grid & State","title":"Grid Initialization","text":"","category":"section"},{"location":"api/grid_state/#State-Initialization","page":"Grid & State","title":"State Initialization","text":"Field allocation is handled internally by init_state. For manual array creation, use standard Julia array allocation or allocate_xy_pencil/allocate_z_pencil for parallel mode.","category":"section"},{"location":"api/grid_state/#Index-Mapping-Functions","page":"Grid & State","title":"Index Mapping Functions","text":"","category":"section"},{"location":"api/grid_state/#FFT-Array-Allocation","page":"Grid & State","title":"FFT Array Allocation","text":"","category":"section"},{"location":"api/grid_state/#QGYBJplus.init_grid","page":"Grid & State","title":"QGYBJplus.init_grid","text":"init_grid(par::QGParams) -> Grid\n\nInitialize the spatial grid and spectral wavenumbers from parameters.\n\nGrid Setup\n\nHorizontal: Uniform grid with spacing dx = Lx/nx, dy = Ly/ny\nVertical: Uniform staggered grid from -Lz+dz/2 to -dz/2 with spacing dz = Lz/nz\nDomain size (Lx, Ly, Lz) is REQUIRED - specify in meters (e.g., 500e3 for 500 km)\n\nWavenumber Arrays\n\nComputes kx, ky following FFTW conventions for periodic domain:\n\nkx[i] = (i-1)           for i = 1, ..., (nx+1)÷2\n        (i-1-nx)        for i = (nx+1)÷2+1, ..., nx\n\nmultiplied by 2π/Lx.\n\nArguments\n\npar::QGParams: Parameter struct with nx, ny, nz, Lx, Ly, Lz\n\nReturns\n\nInitialized Grid struct with all arrays allocated.\n\nExample\n\n# Domain size is REQUIRED - specify in meters\npar = default_params(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)  # 500km × 500km × 4km\nG = init_grid(par)\n\nFortran Correspondence\n\nThis matches init_arrays in init.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.compute_wavenumbers!","page":"Grid & State","title":"QGYBJplus.compute_wavenumbers!","text":"compute_wavenumbers!(G::Grid)\n\nRecompute wavenumber arrays kx, ky, kh2 if grid parameters changed.\n\nThis is useful after modifying grid dimensions or domain size.\n\nExample\n\nG.Lx = 4π  # Change domain size\ncompute_wavenumbers!(G)  # Update wavenumbers\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.init_state","page":"Grid & State","title":"QGYBJplus.init_state","text":"init_state(G::Grid; T=Float64) -> State\n\nAllocate and initialize a State with all fields set to zero.\n\nArguments\n\nG::Grid: Grid struct (determines array sizes)\nT::Type: Floating point type (default Float64)\n\nReturns\n\nState struct with:\n\nSpectral fields (q, psi, A, B, C): Complex arrays, initialized to 0\nReal fields (u, v, w): Real arrays, initialized to 0\n\nExample\n\nG = init_grid(par)\nS = init_state(G)\n\n# All fields are zero - use init_random_psi! or similar to set ICs\ninit_random_psi!(S, G, par, plans)\n\nSee also: State, init_random_psi!\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.get_local_range","page":"Grid & State","title":"QGYBJplus.get_local_range","text":"get_local_range(G::Grid) -> NTuple{3, UnitRange{Int}}\n\nGet the local index range for the current process (xy-pencil configuration).\n\nFor 2D decomposition, this returns the xy-pencil ranges where z is local and x,y are distributed. Use get_local_range_z for z-pencil configuration.\n\nReturns\n\nSerial mode: (1:nz, 1:nx, 1:ny)\nParallel mode: The local range from the xy-pencil decomposition\n\nExample\n\nlocal_range = get_local_range(grid)\nfor k in local_range[1], i in local_range[2], j in local_range[3]\n    # Access data at local indices\nend\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.local_to_global","page":"Grid & State","title":"QGYBJplus.local_to_global","text":"local_to_global(local_idx::Int, dim::Int, G::Grid) -> Int\nlocal_to_global(local_idx::Int, dim::Int, arr::AbstractArray) -> Int\n\nConvert a local array index to a global index.\n\nFor MPI PencilArrays, use local_to_global(local_idx, dim, arr) so the mapping follows the array's pencil decomposition (input/output pencils can differ). For serial arrays, this returns local_idx.\n\nDimensions are ordered (z, x, y) so dim=1 is z, dim=2 is x, dim=3 is y.\n\nArguments\n\nlocal_idx: Local index in the array\ndim: Dimension (1, 2, or 3 for z, x, y)\nG::Grid: Grid with optional decomposition (xy-pencil mapping)\narr: Array to infer the local→global mapping (preferred for MPI)\n\nReturns\n\nGlobal index for wavenumber lookup.\n\nExample\n\nfor j_local in axes(ψk, 3), i_local in axes(ψk, 2)\n    i_global = local_to_global(i_local, 2, ψk)\n    j_global = local_to_global(j_local, 3, ψk)\n    kx = grid.kx[i_global]\n    ky = grid.ky[j_global]\nend\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.get_local_dims","page":"Grid & State","title":"QGYBJplus.get_local_dims","text":"get_local_dims(arr) -> Tuple{Int, Int, Int}\n\nGet the local dimensions of an array (works for both Array and PencilArray).\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.get_kx","page":"Grid & State","title":"QGYBJplus.get_kx","text":"get_kx(i_local::Int, G::Grid) -> Real\n\nGet the x-wavenumber for a local index, handling both serial and parallel cases.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.get_ky","page":"Grid & State","title":"QGYBJplus.get_ky","text":"get_ky(j_local::Int, G::Grid) -> Real\n\nGet the y-wavenumber for a local index, handling both serial and parallel cases.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.get_kh2","page":"Grid & State","title":"QGYBJplus.get_kh2","text":"get_kh2(i_local::Int, j_local::Int, k_local::Int, arr, G::Grid) -> Real\n\nGet horizontal wavenumber squared for local indices.\n\nFor serial mode, accesses G.kh2 directly. For parallel mode, accesses the local PencilArray element.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJplus.allocate_fft_backward_dst","page":"Grid & State","title":"QGYBJplus.allocate_fft_backward_dst","text":"allocate_fft_backward_dst(spectral_arr, plans)\n\nAllocate a destination array for fft_backward! that is on the correct pencil.\n\nFor MPI plans with inputpencil, allocates on inputpencil (physical space). For serial plans, uses similar() which works correctly.\n\nThis is the centralized helper function for all modules to use when allocating arrays as destinations for fft_backward!.\n\nArguments\n\nspectral_arr: A spectral-space array to use as template for element type\nplans: FFT plans (MPIPlans or serial)\n\nReturns\n\nAn array allocated on the correct pencil for fft_backward! destination.\n\n\n\n\n\n","category":"function"},{"location":"advanced/parallel/#parallel","page":"MPI Parallelization","title":"MPI Parallelization","text":"Run QGYBJ+.jl on distributed memory systems using 2D pencil decomposition.\n\nnote: When to Use\nRecommended for grids ≥256³ or when memory is limited. For smaller problems, use threading: julia -t auto.","category":"section"},{"location":"advanced/parallel/#Quick-Start","page":"MPI Parallelization","title":"Quick Start","text":"# parallel_run.jl\nusing MPI, PencilArrays, PencilFFTs, QGYBJplus\n\nMPI.Init()\nmpi_config = QGYBJplus.setup_mpi_environment()\n\nparams = default_params(Lx=1000e3, Ly=1000e3, Lz=5000.0, nx=256, ny=256, nz=128)\ngrid = QGYBJplus.init_mpi_grid(params, mpi_config)\nplans = QGYBJplus.plan_mpi_transforms(grid, mpi_config)\nstate = QGYBJplus.init_mpi_state(grid, plans, mpi_config)\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)\n\na_vec = a_ell_ut(params, grid)\n\nfor step in 1:1000\n    invert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\n    leapfrog_step!(state, state, state, grid, params, plans; a=a_vec, workspace=workspace)\nend\n\nMPI.Finalize()\n\nRun with:\n\nmpiexec -n 16 julia --project parallel_run.jl","category":"section"},{"location":"advanced/parallel/#Requirements","page":"MPI Parallelization","title":"Requirements","text":"MPI parallel packages (MPI.jl, PencilArrays.jl, PencilFFTs.jl) are included as dependencies and installed automatically with QGYBJ+.jl.\n\nSystem MPI library required:\n\nmacOS: brew install open-mpi\nUbuntu: apt install libopenmpi-dev","category":"section"},{"location":"advanced/parallel/#Scaling","page":"MPI Parallelization","title":"Scaling","text":"Processes Topology Grid Size\n4 2×2 128³\n16 4×4 256³\n64 8×8 512³\n\nUse powers of 2 for optimal performance.","category":"section"},{"location":"advanced/parallel/#Key-Concepts","page":"MPI Parallelization","title":"Key Concepts","text":"2D Pencil Decomposition: Domain split across px × py process grid. z-dimension stays local for efficient vertical solves.\n\nWorkspace: Pre-allocate once to avoid repeated allocation:\n\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)\n\nState Copies: Use copy_state(S) not deepcopy(S) to preserve pencil topology.","category":"section"},{"location":"advanced/parallel/#Key-Functions","page":"MPI Parallelization","title":"Key Functions","text":"Function Purpose\nsetup_mpi_environment() Initialize MPI config\ninit_mpi_grid() Create distributed grid\nplan_mpi_transforms() Create PencilFFT plans\ninit_mpi_state() Create distributed state\ninit_mpi_workspace() Allocate workspace\ncopy_state() Copy state (preserves topology)\nmpi_reduce_sum() Sum across processes","category":"section"},{"location":"advanced/parallel/#Global-Reductions","page":"MPI Parallelization","title":"Global Reductions","text":"local_ke = flow_kinetic_energy(state.u, state.v)\nglobal_ke = QGYBJplus.mpi_reduce_sum(local_ke, mpi_config)\nif mpi_config.is_root\n    println(\"Total KE: $global_ke\")\nend","category":"section"},{"location":"advanced/parallel/#Job-Scripts","page":"MPI Parallelization","title":"Job Scripts","text":"","category":"section"},{"location":"advanced/parallel/#SLURM","page":"MPI Parallelization","title":"SLURM","text":"#!/bin/bash\n#SBATCH --nodes=4 --ntasks-per-node=16\nmpiexec -n 64 julia --project script.jl","category":"section"},{"location":"advanced/parallel/#Troubleshooting","page":"MPI Parallelization","title":"Troubleshooting","text":"Problem Solution\nPencil topology mismatch Use copy_state(S) not deepcopy(S)\nDeadlock All ranks must call collective operations\nSegfaults Use size(parent(arr)) for array dimensions\n\nSee Troubleshooting for more details.","category":"section"},{"location":"physics/numerical_methods/#numerical-methods","page":"Numerical Methods","title":"Numerical Methods","text":"This page describes the numerical algorithms used in QGYBJ+.jl, including the 2D pencil decomposition strategy for parallel execution.","category":"section"},{"location":"physics/numerical_methods/#Spatial-Discretization","page":"Numerical Methods","title":"Spatial Discretization","text":"","category":"section"},{"location":"physics/numerical_methods/#Horizontal:-Pseudo-Spectral-Method","page":"Numerical Methods","title":"Horizontal: Pseudo-Spectral Method","text":"The model uses a pseudo-spectral approach in the horizontal:\n\nOperation Space Method\nLinear derivatives Spectral Multiply by ik_x, ik_y\nNonlinear products Physical Pointwise multiplication\nTransform Both FFT / IFFT","category":"section"},{"location":"physics/numerical_methods/#Advantages","page":"Numerical Methods","title":"Advantages","text":"Spectral accuracy for smooth fields\nEfficient O(N log N) via FFT\nNo numerical diffusion from derivatives","category":"section"},{"location":"physics/numerical_methods/#Dealiasing","page":"Numerical Methods","title":"Dealiasing","text":"Nonlinear products create aliasing errors. We use the radial 2/3 rule:\n\nk_max = fracmin(N_x N_y)3\n\nModes with k_x^2 + k_y^2  k_max^2 are set to zero after each nonlinear term. The radial cutoff ensures isotropic treatment of modes.\n\n# Apply dealiasing mask (radial cutoff)\nmask = dealias_mask(grid)  # Returns 2D array of 0s and 1s\n@. field_k *= mask","category":"section"},{"location":"physics/numerical_methods/#Hyperdiffusion-Helper-Functions","page":"Numerical Methods","title":"Hyperdiffusion Helper Functions","text":"For dimensional simulations, use the helper functions to compute appropriate hyperdiffusion coefficients:\n\n# Compute 4th order hyperdiffusion for 10-step e-folding at grid scale\nhd = compute_hyperdiff_params(\n    nx=128, ny=128, Lx=70e3, Ly=70e3, dt=10.0,\n    order=4, efold_steps=10\n)\n\n# Returns: (ν=..., ilap=2, order=4)\n# ν is in m⁴/s for 4th order (biharmonic ∇⁴)\n\nThe coefficient is computed such that the grid-scale mode decays by a factor of e in the specified number of time steps.","category":"section"},{"location":"physics/numerical_methods/#Vertical:-Finite-Differences","page":"Numerical Methods","title":"Vertical: Finite Differences","text":"The vertical direction uses second-order centered differences:\n\nfracpartial fpartial zbigg_k approx fracf_k+1 - f_k-12Delta z\n\nfracpartial^2 fpartial z^2bigg_k approx fracf_k+1 - 2f_k + f_k-1Delta z^2\n\nFor variable coefficients (stratification):\n\nfracpartialpartial zleft(a(z)fracpartial fpartial zright) approx fraca_k+12(f_k+1 - f_k) - a_k-12(f_k - f_k-1)Delta z^2","category":"section"},{"location":"physics/numerical_methods/#Time-Integration","page":"Numerical Methods","title":"Time Integration","text":"","category":"section"},{"location":"physics/numerical_methods/#Leapfrog-with-Robert-Asselin-Filter-and-Integrating-Factors","page":"Numerical Methods","title":"Leapfrog with Robert-Asselin Filter and Integrating Factors","text":"The primary time stepping scheme is leapfrog with Robert-Asselin filtering and integrating factors for hyperdiffusion.","category":"section"},{"location":"physics/numerical_methods/#Forward-Euler-(First-Step)","page":"Numerical Methods","title":"Forward Euler (First Step)","text":"The first step uses forward Euler to bootstrap the leapfrog scheme:\n\nq^n+1 = left q^n - Delta t cdot J(psi q)^n + Delta t cdot D_q^n right cdot e^-lambda Delta t\n\nFor the wave envelope (in real/imaginary form):\n\nB_R^n+1 = left B_R^n - Delta t cdot J(psi B_R) - Delta t cdot fracN^2 k_h^22 f_0 A_I + Delta t cdot frac12 r_BI right cdot e^-lambda_w Delta t\n\nB_I^n+1 = left B_I^n - Delta t cdot J(psi B_I) + Delta t cdot fracN^2 k_h^22 f_0 A_R - Delta t cdot frac12 r_BR right cdot e^-lambda_w Delta t\n\nwhere N^2 is the buoyancy frequency squared and f_0 is the Coriolis parameter.","category":"section"},{"location":"physics/numerical_methods/#Leapfrog-(Subsequent-Steps)","page":"Numerical Methods","title":"Leapfrog (Subsequent Steps)","text":"Subsequent steps use centered leapfrog with integrating factors:\n\nq^n+1 = q^n-1 cdot e^-2lambda Delta t - 2Delta t cdot J(psi q)^n cdot e^-lambda Delta t + 2Delta t cdot D_q^n cdot e^-2lambda Delta t\n\nB_R^n+1 = B_R^n-1 cdot e^-2lambda_w Delta t - 2Delta t cdot left J(psi B_R) + fracN^2 k_h^22 f_0 A_I - frac12 r_BI right^n cdot e^-lambda_w Delta t\n\nB_I^n+1 = B_I^n-1 cdot e^-2lambda_w Delta t - 2Delta t cdot left J(psi B_I) - fracN^2 k_h^22 f_0 A_R + frac12 r_BR right^n cdot e^-lambda_w Delta t","category":"section"},{"location":"physics/numerical_methods/#Robert-Asselin-Filter","page":"Numerical Methods","title":"Robert-Asselin Filter","text":"The Robert-Asselin filter damps the computational mode that can grow with leapfrog:\n\ntildeq^n = q^n + gamma left( q^n-1 - 2q^n + q^n+1 right)\n\nwhere gamma approx 0001 (typically very small to minimize physical mode damping).\n\n# First step: Forward Euler\nfirst_projection_step!(state, grid, params, plans; a=a_vec, dealias_mask=mask)\n\n# Subsequent steps: Leapfrog with Robert-Asselin\nleapfrog_step!(state_np1, state_n, state_nm1, grid, params, plans;\n               a=a_vec, dealias_mask=mask)","category":"section"},{"location":"physics/numerical_methods/#Integrating-Factor-Method","page":"Numerical Methods","title":"Integrating Factor Method","text":"The integrating factor lambda handles hyperdiffusion exactly:\n\nlambda = nu_h1 left( k_x^2 cdot ilap1 + k_y^2 cdot ilap1 right) + nu_h2 left( k_x^2 cdot ilap2 + k_y^2 cdot ilap2 right)\n\nwhere (using Unicode parameters):\n\nnu_h1 (νₕ₁), ilap1: First hyperdiffusion operator (default: biharmonic with ilap1=2)\nnu_h2 (νₕ₂), ilap2: Second hyperdiffusion operator (default: hyper-6 with ilap2=6)\n\nThe wave field has its own integrating factor lambda_w with potentially different coefficients.\n\nAdvantages of integrating factors:\n\nHyperdiffusion is treated exactly (no stability restriction)\nAllows much larger time steps than explicit diffusion treatment\nSecond-order accuracy preserved for advective terms","category":"section"},{"location":"physics/numerical_methods/#Second-Order-IMEX-CNAB-with-Strang-Splitting","page":"Numerical Methods","title":"Second-Order IMEX-CNAB with Strang Splitting","text":"For applications where the dispersion CFL constraint (dt ≤ 2f/N² ≈ 2s) is limiting, we provide a second-order IMEX-CNAB scheme that treats dispersion implicitly and uses Strang splitting for refraction.","category":"section"},{"location":"physics/numerical_methods/#The-Challenge:-Refraction-Instability","page":"Numerical Methods","title":"The Challenge: Refraction Instability","text":"The YBJ+ equation includes a refraction term -(i2)zeta B which, when discretized with forward Euler, is unconditionally unstable:\n\n1 - i Delta t zeta2 = sqrt1 + (Delta t zeta2)^2  1\n\nThis amplifies energy regardless of time step size.","category":"section"},{"location":"physics/numerical_methods/#Solution:-Strang-Splitting-IMEX-CNAB","page":"Numerical Methods","title":"Solution: Strang Splitting + IMEX-CNAB","text":"We use Strang splitting for refraction (second-order) combined with Adams-Bashforth 2 for advection (second-order):\n\nStage 1 - First Half-Refraction (Strang):\n\nB^* = B^n times exp(-i fracDelta t2 fraczeta2)\n\nStage 2 - IMEX-CNAB for Advection + Dispersion:\n\nB^** - fracDelta t2 i alpha_textdisp k_h^2 A^n+1 = B^* + fracDelta t2 i alpha_textdisp k_h^2 A^* + frac3Delta t2 N^n - fracDelta t2 N^n-1\n\nwhere N^n = -J(psi^n B^n) is the advection tendency at time n, and Adams-Bashforth 2 extrapolation frac32N^n - frac12N^n-1 provides second-order accuracy.\n\nStage 3 - Second Half-Refraction (Strang):\n\nB^n+1 = B^** times exp(-i fracDelta t2 fraczeta2)\n\nSince exp(-i theta) = 1 for real theta, refraction is exactly energy-preserving.\n\nMean-Flow Update (q): The PV equation is advanced with Adams–Bashforth 2 on -J(psiq) + textdiffusion, using the integrating factor for hyperdiffusion. To keep the coupled system second-order, the second refraction half-step uses psi^n+1 predicted from the updated q (and q^w when wave feedback is enabled).","category":"section"},{"location":"physics/numerical_methods/#Critical:-Consistent-A*","page":"Numerical Methods","title":"Critical: Consistent A*","text":"After applying refraction to get B^*, we must compute A^* = (L^+)^-1 B^* (not use A^n). Using A^n with B^* breaks the consistency required by IMEX-CN, causing instability.","category":"section"},{"location":"physics/numerical_methods/#Modified-Elliptic-Problem","page":"Numerical Methods","title":"Modified Elliptic Problem","text":"Substituting B = L^+ A into the IMEX-CN equation:\n\n(L^+ - beta) A^n+1 = textRHS\n\nwhere beta = (Delta t2) cdot i cdot alpha_textdisp cdot k_h^2.\n\nThis is a tridiagonal system for each (k_x k_y) mode, solved with the Thomas algorithm.","category":"section"},{"location":"physics/numerical_methods/#Temporal-Accuracy","page":"Numerical Methods","title":"Temporal Accuracy","text":"Component Method Order\nRefraction Strang splitting 2nd\nDispersion Crank-Nicolson 2nd\nAdvection Adams-Bashforth 2 2nd\nOverall IMEX-CNAB 2nd\n\nNote: The first time step uses forward Euler for advection (AB2 bootstrap), so the very first step is first-order.","category":"section"},{"location":"physics/numerical_methods/#Stability-Summary","page":"Numerical Methods","title":"Stability Summary","text":"Term Treatment Stability\nRefraction Exact integrating factor Unconditionally stable\nDispersion Implicit Crank-Nicolson Unconditionally stable\nAdvection Explicit Adams-Bashforth 2 CFL: Delta t  Delta x  U_max\n\nFor typical oceanographic parameters (U ≈ 0.3 m/s, dx ≈ 300m), this allows dt ≈ 20s vs dt ≈ 2s for explicit leapfrog—a 10x speedup.","category":"section"},{"location":"physics/numerical_methods/#Elliptic-Inversions","page":"Numerical Methods","title":"Elliptic Inversions","text":"","category":"section"},{"location":"physics/numerical_methods/#Tridiagonal-Systems","page":"Numerical Methods","title":"Tridiagonal Systems","text":"Both QG (q -> psi) and YBJ+ (B -> A) inversions lead to tridiagonal systems at each horizontal wavenumber (kx, ky):\n\na_k x_k-1 + b_k x_k + c_k x_k+1 = d_k","category":"section"},{"location":"physics/numerical_methods/#Thomas-Algorithm","page":"Numerical Methods","title":"Thomas Algorithm","text":"We solve these in O(N) operations using the Thomas algorithm:\n\nForward sweep:\n\nfor k = 2:nz\n    w = a[k] / b[k-1]\n    b[k] = b[k] - w * c[k-1]\n    d[k] = d[k] - w * d[k-1]\nend\n\nBack substitution:\n\nx[nz] = d[nz] / b[nz]\nfor k = nz-1:-1:1\n    x[k] = (d[k] - c[k] * x[k+1]) / b[k]\nend","category":"section"},{"location":"physics/numerical_methods/#Key-Inversions","page":"Numerical Methods","title":"Key Inversions","text":"Function Solves Physical Meaning\ninvert_q_to_psi! nabla²psi + (f²/N²)d²psi/dz² = q PV to streamfunction\ninvert_B_to_A! L⁺A = B Wave envelope to amplitude\ninvert_helmholtz! nabla²phi - lambda*phi = f General Helmholtz","category":"section"},{"location":"physics/numerical_methods/#FFT-Implementation","page":"Numerical Methods","title":"FFT Implementation","text":"","category":"section"},{"location":"physics/numerical_methods/#Serial-Mode:-FFTW","page":"Numerical Methods","title":"Serial Mode: FFTW","text":"We use FFTW with measured plans for optimal performance:\n\n# Create optimized plans\nplans = plan_transforms!(grid)\n\n# Forward FFT (physical -> spectral)\nfft_forward!(dst, src, plans)\n\n# Backward FFT (spectral -> physical)\nfft_backward!(dst, src, plans)\n\nPlan creation is expensive (~seconds) but execution is fast.","category":"section"},{"location":"physics/numerical_methods/#Parallel-Mode:-PencilFFTs","page":"Numerical Methods","title":"Parallel Mode: PencilFFTs","text":"For MPI parallel execution, we use PencilFFTs which handles distributed FFTs:\n\n# Create parallel FFT plans\nplans = QGYBJplus.plan_mpi_transforms(grid, mpi_config)\n\n# Same interface as serial\nfft_forward!(dst, src, plans)\nfft_backward!(dst, src, plans)\n\nPencilFFTs automatically handles the transposes needed for distributed FFTs.","category":"section"},{"location":"physics/numerical_methods/#2D-Pencil-Decomposition","page":"Numerical Methods","title":"2D Pencil Decomposition","text":"","category":"section"},{"location":"physics/numerical_methods/#The-Challenge","page":"Numerical Methods","title":"The Challenge","text":"The model requires two types of operations:\n\nHorizontal FFTs: Need consecutive x and y data\nVertical solves: Need all z data at each (x,y) point\n\nWith 2D decomposition, no single configuration has all data local.","category":"section"},{"location":"physics/numerical_methods/#Solution:-Dual-Pencil-Configurations","page":"Numerical Methods","title":"Solution: Dual Pencil Configurations","text":"QGYBJ+.jl uses two pencil configurations:\n\nConfiguration Local Dimension Distributed Dimensions Use\nxy-pencil x y, z Horizontal FFTs\nz-pencil z x, y Vertical operations\n\n    xy-pencil                           z-pencil\n   (x local)                          (z local)\n┌─────────────────┐               ┌─────────────────┐\n│ x: FULL         │               │ x: distributed  │\n│ y: distributed  │  <----->      │ y: distributed  │\n│ z: distributed  │  transpose    │ z: FULL         │\n└─────────────────┘               └─────────────────┘","category":"section"},{"location":"physics/numerical_methods/#Transpose-Operations","page":"Numerical Methods","title":"Transpose Operations","text":"Functions requiring vertical operations follow this pattern:\n\nfunction some_vertical_operation!(S, G; workspace=nothing)\n    # Check if 2D decomposition is active\n    need_transpose = G.decomp !== nothing && hasfield(typeof(G.decomp), :pencil_z)\n\n    if need_transpose\n        # 1. Transpose from xy-pencil to z-pencil\n        transpose_to_z_pencil!(workspace.field_z, S.field, G)\n\n        # 2. Perform vertical operation (z now fully local)\n        _vertical_operation_on_z_pencil!(workspace.result_z, workspace.field_z, ...)\n\n        # 3. Transpose result back to xy-pencil\n        transpose_to_xy_pencil!(S.result, workspace.result_z, G)\n    else\n        # Serial mode: direct vertical operation\n        _vertical_operation_direct!(S, G, ...)\n    end\nend","category":"section"},{"location":"physics/numerical_methods/#Functions-Using-This-Pattern","page":"Numerical Methods","title":"Functions Using This Pattern","text":"Function What it does Needs z local?\ninvert_q_to_psi! PV inversion Yes (tridiagonal)\ninvert_B_to_A! Wave amplitude recovery Yes (tridiagonal)\ninvert_helmholtz! General Helmholtz Yes (tridiagonal)\ncompute_vertical_velocity! Omega equation Yes (tridiagonal)\ncompute_ybj_vertical_velocity! YBJ w formula Yes (vertical derivative)\ndissipation_q_nv! Numerical dissipation Yes (vertical terms)\nsumB! Sum B over depth Yes (vertical sum)\ncompute_sigma YBJ sigma term Yes (vertical operations)\ncompute_A! Compute A from B Yes (vertical operations)\nomega_eqn_rhs! RHS of omega equation Yes (vertical derivatives)","category":"section"},{"location":"physics/numerical_methods/#Workspace-Arrays","page":"Numerical Methods","title":"Workspace Arrays","text":"To avoid repeated allocation, pre-allocate z-pencil workspace:\n\n# Initialize once\nworkspace = QGYBJplus.init_mpi_workspace(grid, mpi_config)\n\n# Contents:\n# workspace.q_z, workspace.psi_z, workspace.B_z,\n# workspace.A_z, workspace.C_z, workspace.work_z\n\n# Pass to functions\ninvert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)","category":"section"},{"location":"physics/numerical_methods/#Jacobian/Advection-Computation","page":"Numerical Methods","title":"Jacobian/Advection Computation","text":"","category":"section"},{"location":"physics/numerical_methods/#Divergence-Form-(convol_waqg)","page":"Numerical Methods","title":"Divergence Form (convol_waqg)","text":"For advection terms like J(psi q), QGYBJ+.jl uses the divergence form:\n\nJ(psi q) = fracpartial(uq)partial x + fracpartial(vq)partial y = ik_x widehatuq + ik_y widehatvq\n\nwhere u = -partialpsipartial y and v = partialpsipartial x are the geostrophic velocities.","category":"section"},{"location":"physics/numerical_methods/#Algorithm-(convol_waqg)","page":"Numerical Methods","title":"Algorithm (convol_waqg)","text":"Precompute velocities in real space: u_r, v_r\nTransform field to real space:\nfft_backward!(qr, qk, plans)\nCompute products in real space:\nuterm = u_r .* qr\nvterm = v_r .* qr\nTransform back and compute divergence:\nfft_forward!(uterm_k, uterm, plans)\nfft_forward!(vterm_k, vterm, plans)\nJ_k = im * kx .* uterm_k + im * ky .* vterm_k\nApply dealiasing:\nJ_k[.!dealias_mask] .= 0\nNormalize (for unnormalized FFT):\nJ_k ./= (nx * ny)","category":"section"},{"location":"physics/numerical_methods/#Conservation-Properties","page":"Numerical Methods","title":"Conservation Properties","text":"The pseudo-spectral advection conserves:\n\nCirculation: int J(psi q)  dA = 0\nEnergy (to machine precision in inviscid limit)\nEnstrophy (to machine precision in inviscid limit)","category":"section"},{"location":"physics/numerical_methods/#Stability-Constraints","page":"Numerical Methods","title":"Stability Constraints","text":"","category":"section"},{"location":"physics/numerical_methods/#CFL-Condition","page":"Numerical Methods","title":"CFL Condition","text":"For advection terms:\n\nDelta t  fracDelta xmaxu approx fracLNU","category":"section"},{"location":"physics/numerical_methods/#Diffusion-Stability","page":"Numerical Methods","title":"Diffusion Stability","text":"With integrating factors, there is no diffusion stability limit.\n\nWithout integrating factors, explicit diffusion requires:\n\nDelta t  fracDelta x^2p2nu\n\nFor hyperdiffusion (p=4), this is very restrictive.","category":"section"},{"location":"physics/numerical_methods/#Recommended-Time-Steps","page":"Numerical Methods","title":"Recommended Time Steps","text":"Resolution Typical dt\n64^3 0.001 - 0.01\n128^3 0.0005 - 0.005\n256^3 0.0002 - 0.002\n512^3 0.0001 - 0.001","category":"section"},{"location":"physics/numerical_methods/#Memory-Layout","page":"Numerical Methods","title":"Memory Layout","text":"","category":"section"},{"location":"physics/numerical_methods/#Array-Ordering","page":"Numerical Methods","title":"Array Ordering","text":"Julia uses column-major ordering (Fortran-style):\n\n# Fast index first for cache efficiency\nfor k = 1:nz\n    for j = 1:ny\n        for i = 1:nx\n            field[k, i, j] = ...\n        end\n    end\nend","category":"section"},{"location":"physics/numerical_methods/#Complex-Arrays","page":"Numerical Methods","title":"Complex Arrays","text":"Spectral fields are stored as Array{ComplexF64, 3}:\n\n# Spectral field dimensions\npsi_k = zeros(ComplexF64, nx, ny, nz)","category":"section"},{"location":"physics/numerical_methods/#PencilArrays-(Parallel)","page":"Numerical Methods","title":"PencilArrays (Parallel)","text":"In parallel mode, arrays are PencilArray{T,3}:\n\n# Access underlying data\ndata = parent(arr)\n\n# Local dimensions\nnx_local, ny_local, nz_local = size(data)","category":"section"},{"location":"physics/numerical_methods/#Accuracy-Verification","page":"Numerical Methods","title":"Accuracy Verification","text":"","category":"section"},{"location":"physics/numerical_methods/#Order-of-Accuracy","page":"Numerical Methods","title":"Order of Accuracy","text":"Component Spatial Order Temporal Order\nHorizontal derivatives Spectral -\nVertical derivatives 2nd -\nElliptic solvers 2nd (vertical) -\nTime stepping (Leapfrog) - 2nd\nIntegrating factors - Exact","category":"section"},{"location":"physics/numerical_methods/#Conservation-Tests","page":"Numerical Methods","title":"Conservation Tests","text":"Run with inviscid settings to verify:\n\nEnergy conservation (< 10^-10 relative change)\nEnstrophy conservation (< 10^-10 relative change)\n\n# Check energy conservation\nKE_initial = flow_kinetic_energy(state.u, state.v)\n# ... run simulation ...\nKE_final = flow_kinetic_energy(state.u, state.v)\nprintln(\"Relative change: \", abs(KE_final - KE_initial) / KE_initial)","category":"section"},{"location":"physics/numerical_methods/#Performance-Optimization","page":"Numerical Methods","title":"Performance Optimization","text":"","category":"section"},{"location":"physics/numerical_methods/#Key-Optimizations","page":"Numerical Methods","title":"Key Optimizations","text":"Pre-allocated work arrays: No allocations in time loop\nFFTW planning: Measured plans for optimal performance\nLoop fusion: @. macro for element-wise operations\nIn-place operations: Minimize memory allocation\nWorkspace reuse: Pre-allocated z-pencil arrays for transposes","category":"section"},{"location":"physics/numerical_methods/#Profiling","page":"Numerical Methods","title":"Profiling","text":"using Profile\n\n# Profile time stepping\n@profile for _ in 1:100\n    leapfrog_step!(state_np1, state_n, state_nm1, grid, params, plans;\n                   a=a_vec, dealias_mask=mask, workspace=workspace)\nend\n\nProfile.print()\n\nTypical hotspots:\n\nFFT transforms (~40-50%)\nTridiagonal solves (~20-30%)\nTranspose operations (~10-20% in parallel)\nArray operations (~10-20%)","category":"section"},{"location":"physics/numerical_methods/#Parallel-Scaling","page":"Numerical Methods","title":"Parallel Scaling","text":"Processes Expected Speedup Limiting Factor\n1-16 Near linear -\n16-64 Good Transpose overhead\n64-256 Moderate Communication\n256+ Diminishing Problem size dependent","category":"section"},{"location":"physics/numerical_methods/#References","page":"Numerical Methods","title":"References","text":"Canuto, C., et al. (2006). Spectral Methods: Fundamentals in Single Domains. Springer.\nDurran, D. R. (2010). Numerical Methods for Fluid Dynamics. Springer.\nPencilArrays.jl documentation: https://jipolanco.github.io/PencilArrays.jl/\nPencilFFTs.jl documentation: https://jipolanco.github.io/PencilFFTs.jl/","category":"section"},{"location":"guide/stratification/#stratification","page":"Stratification","title":"Stratification","text":"This page explains how to configure ocean stratification profiles in QGYBJ+.jl.","category":"section"},{"location":"guide/stratification/#Why-Stratification-Matters","page":"Stratification","title":"Why Stratification Matters","text":"The buoyancy frequency N(z) affects:\n\nWave propagation: Dispersion depends on N^2\nVertical structure: Mode shapes vary with N(z)\nRefraction: Waves bend toward regions of lower N\nEnergy flux: Vertical group velocity scales with N\n\nThe vertical coordinate is z ∈ [-Lz, 0] with z = 0 at the surface. Grid points are cell-centered at z = -Lz+dz/2 ... -dz/2. For stratification profiles we use depth d = -z (positive downward), evaluated on the unstaggered (face) grid at z = G.z - dz/2.","category":"section"},{"location":"guide/stratification/#Built-in-Stratification-Types","page":"Stratification","title":"Built-in Stratification Types","text":"QGYBJ+.jl supports two stratification modes through the default_params() function:","category":"section"},{"location":"guide/stratification/#Constant-N","page":"Stratification","title":"Constant N","text":"Uniform stratification throughout the water column (default):\n\npar = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    stratification=:constant_N,  # This is the default\n    N²=1.0                       # Buoyancy frequency squared\n)\n\nProfile:\n\nN^2(z) = N_0^2 = textconst\n\nBest for:\n\nIdealized studies\nAnalytical comparisons\nSimple mode structure","category":"section"},{"location":"guide/stratification/#Skewed-Gaussian-(Pycnocline)","page":"Stratification","title":"Skewed Gaussian (Pycnocline)","text":"Sharp pycnocline with gradual decrease below:\n\npar = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    stratification=:skewed_gaussian\n)\n\nProfile formula:\n\nN^2(d) = N_1^2 expleft(-frac(d-z_0)^2sigma^2right) left1 + texterfleft(fracalpha(d-z_0)sigmasqrt2right)right + N_0^2\n\nThe skewed Gaussian parameters in QGParams are:\n\nN₀²_sg: Background N² value\nN₁²_sg: Peak N² amplitude\nσ_sg: Width of pycnocline\nz₀_sg: Center depth of pycnocline (positive below surface)\nα_sg: Skewness parameter\n\nProfile (schematic):\n\nN² →\n│\n│    ╱╲\n│   ╱  ╲\n│  ╱    ╲____\n│ ╱           ╲____\n│╱                  ──────\n└─────────────────────────── depth d\n     ↑\n  pycnocline\n\nBest for:\n\nRealistic subtropical ocean\nStrong near-surface trapping\nWave focusing studies","category":"section"},{"location":"guide/stratification/#Setting-Up-with-Stratification-Profiles","page":"Stratification","title":"Setting Up with Stratification Profiles","text":"","category":"section"},{"location":"guide/stratification/#Using-setup*model*with_profile","page":"Stratification","title":"Using setupmodelwith_profile","text":"For non-constant stratification, use setup_model_with_profile() to get the N² profile:\n\nusing QGYBJplus\n\n# Create parameters with skewed Gaussian stratification\npar = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    stratification=:skewed_gaussian\n)\n\n# This returns the N² profile for use in physics\nG, S, plans, a_ell, N2_profile = setup_model_with_profile(par)\n\n# N2_profile is now available for vertical velocity computation, etc.","category":"section"},{"location":"guide/stratification/#Analytical-N(z)-Example-(Linear)","page":"Stratification","title":"Analytical N(z) Example (Linear)","text":"You can pass a custom analytic N(z) or N²(z) directly:\n\nusing QGYBJplus\n\na = 0.01    # s^-1\nb = -2.0e-6 # s^-1 m^-1\n@inline N(z) = a + b * z  # z is negative below the surface\n\ndomain = create_domain_config(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)\nstrat = create_stratification_config(\n    type=:analytical,\n    N_func=N\n)\n\nsim = setup_simulation(domain, strat)\n\nThis corresponds to:\n\nN(z) = a + b z\n\nUse N2_func instead if you want to specify N²(z) directly.\n\nWhen running with MPI, define N_func in the same script so each rank sees the function.","category":"section"},{"location":"guide/stratification/#Using-the-High-Level-API","page":"Stratification","title":"Using the High-Level API","text":"The QGYBJSimulation API handles stratification automatically:\n\nusing QGYBJplus\n\n# Create configuration\ndomain = create_domain_config(\n    nx=64, ny=64, nz=32,\n    Lx=500e3, Ly=500e3, Lz=4000.0\n)\n\nstrat = create_stratification_config(\n    type=:skewed_gaussian\n)\n\nmodel = create_model_config(\n    inviscid=false,\n    ybj_plus=true\n)\n\n# Setup simulation - stratification is handled internally\nsim = setup_simulation(domain, strat, model=model)","category":"section"},{"location":"guide/stratification/#Advanced:-Custom-Profiles","page":"Stratification","title":"Advanced: Custom Profiles","text":"","category":"section"},{"location":"guide/stratification/#StratificationProfile-Types","page":"Stratification","title":"StratificationProfile Types","text":"QGYBJ+.jl provides several stratification profile types:\n\n# Constant N²\nprofile = ConstantN{Float64}(1.0)  # N₀ = 1.0\n\n# Tanh profile (pycnocline-like)\nprofile = TanhProfile{Float64}(\n    0.01,    # N_upper\n    0.025,   # N_lower\n    2400.0,  # z_pycno depth (same units as Lz)\n    200.0    # width (same units as Lz)\n)\n\n# Exponential profile\nprofile = ExponentialProfile{Float64}(\n    0.02,    # N_surface\n    1200.0,  # scale_height\n    0.001    # N_deep\n)\n\n# Piecewise profile (two-layer)\nprofile = PiecewiseProfile{Float64}(\n    [0.0, 2000.0, 4000.0],  # z_interfaces (depths below surface)\n    [0.01, 0.03]            # N values in each layer\n)\n\n# Analytical profile from N(z)\nN_func = z -> 0.01 - 2e-6 * z\nprofile = AnalyticalProfile{Float64}(N_func, false)  # false => N(z), true => N²(z)","category":"section"},{"location":"guide/stratification/#Evaluating-Profiles-on-the-Grid","page":"Stratification","title":"Evaluating Profiles on the Grid","text":"using QGYBJplus\n\n# Create a profile\nprofile = TanhProfile{Float64}(0.01, 0.025, 2400.0, 200.0)\n\n# Compute N² on the model grid\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0)\nG = init_grid(par)\nN2_profile = compute_stratification_profile(profile, G)\n\n# Compute elliptic coefficient from N² profile\na_ell = a_ell_from_N2(N2_profile, par)","category":"section"},{"location":"guide/stratification/#From-Data-File","page":"Stratification","title":"From Data File","text":"Load stratification from a NetCDF file:\n\nusing QGYBJplus, NCDatasets\n\n# Read N² profile from file\nN2_profile = read_stratification_profile(\"N2_data.nc\", G)\n\n# Or read raw data for custom processing\nz_data, N2_data = read_stratification_raw(\"N2_data.nc\")\n\nz_data should be depths (positive below the surface). The model grid uses z ∈ [-Lz, 0], so file profiles are interpreted in depth coordinates.","category":"section"},{"location":"guide/stratification/#Effects-on-Dynamics","page":"Stratification","title":"Effects on Dynamics","text":"","category":"section"},{"location":"guide/stratification/#Elliptic-Coefficient","page":"Stratification","title":"Elliptic Coefficient","text":"The elliptic coefficient a = f²/N² is computed from the N² profile:\n\n# For constant N² (uses par.N²)\na_ell = a_ell_ut(par, G)\n\n# For variable N² (from profile)\na_ell = a_ell_from_N2(N2_profile, par)","category":"section"},{"location":"guide/stratification/#Deformation-Radius","page":"Stratification","title":"Deformation Radius","text":"The first baroclinic deformation radius can be computed:\n\nusing QGYBJplus: compute_deformation_radius\n\nLd = compute_deformation_radius(N2_profile, par.f₀, par.Lz)","category":"section"},{"location":"guide/stratification/#Wave-Trapping","page":"Stratification","title":"Wave Trapping","text":"Strong surface stratification traps waves near the surface:\n\nStrong N²    Weak N²\nnear surface everywhere\n\n    │           │\n  ──┴──       ──┴──\n  Wave        Wave\n  trapped     penetrates\n  above       to depth\n  pycnocline","category":"section"},{"location":"guide/stratification/#Visualization","page":"Stratification","title":"Visualization","text":"","category":"section"},{"location":"guide/stratification/#Profile-Plot","page":"Stratification","title":"Profile Plot","text":"using Plots\n\n# Get grid depth coordinates (positive downward, unstaggered levels)\ndz = G.Lz / G.nz\ndepth = -(G.z .- dz / 2)\n\n# Plot N² profile\nplot(N2_profile, depth,\n    xlabel = \"N² (s⁻²)\",\n    ylabel = \"Depth (m)\",\n    title = \"Stratification Profile\",\n    legend = false\n)","category":"section"},{"location":"guide/stratification/#Plotting-Different-Profiles","page":"Stratification","title":"Plotting Different Profiles","text":"using Plots, QGYBJplus\n\n# Create standard profiles for comparison\nprofiles = create_standard_profiles(4000.0)  # 4km domain\n\np = plot(title=\"Stratification Profiles\", xlabel=\"N²\", ylabel=\"Depth (m)\")\nfor (name, profile) in profiles\n    z_vals, N2_vals, _ = plot_stratification_profile(profile, 4000.0)\n    depth_vals = -z_vals\n    plot!(p, N2_vals, depth_vals, label=String(name))\nend\ndisplay(p)","category":"section"},{"location":"guide/stratification/#Best-Practices","page":"Stratification","title":"Best Practices","text":"","category":"section"},{"location":"guide/stratification/#Resolution-Guidelines","page":"Stratification","title":"Resolution Guidelines","text":"Profile Type Recommended n_z\nConstant N 16-32\nSmooth exponential 32-64\nSharp pycnocline 64-128\nTwo-layer 32-64\n\nSharp features need higher resolution to avoid Gibbs phenomena.","category":"section"},{"location":"guide/stratification/#Validation","page":"Stratification","title":"Validation","text":"Use validate_stratification() to check your profile:\n\nerrors, warnings = validate_stratification(N2_profile)\n\nfor err in errors\n    @error err\nend\nfor warn in warnings\n    @warn warn\nend","category":"section"},{"location":"guide/stratification/#Physical-Constraints","page":"Stratification","title":"Physical Constraints","text":"N^2  0 everywhere (stable stratification)\nN^2 should decrease with depth (typically)\nAvoid very small N^2 (causes numerical issues in inversions)\n\n# Ensure minimum N²\nN2_min = 1e-6\nN2_profile .= max.(N2_profile, N2_min)","category":"section"},{"location":"guide/stratification/#Stratification-Types-Reference","page":"Stratification","title":"Stratification Types Reference","text":"Type Symbol/Struct Parameters\nConstant :constant_N N² in default_params()\nSkewed Gaussian :skewed_gaussian N₀²_sg, N₁²_sg, σ_sg, z₀_sg, α_sg\nTanh TanhProfile N_upper, N_lower, z_pycno, width\nExponential ExponentialProfile N_surface, scale_height, N_deep\nPiecewise PiecewiseProfile z_interfaces, N_values\nFrom File FileProfile filename","category":"section"},{"location":"guide/stratification/#Related-Topics","page":"Stratification","title":"Related Topics","text":"QG Equations: How N² enters PV\nYBJ+ Wave Model: Wave dispersion with N²\nConfiguration: Setting up simulations","category":"section"},{"location":"getting_started/#getting_started","page":"Installation","title":"Installation & Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/subhk/QGYBJplus.jl\")\n\nOr develop locally:\n\ngit clone https://github.com/subhk/QGYBJplus.jl\ncd QGYBJ+.jl\njulia --project=. -e 'using Pkg; Pkg.instantiate(); Pkg.precompile()'","category":"section"},{"location":"getting_started/#MPI-Support","page":"Installation","title":"MPI Support","text":"MPI parallel packages (MPI.jl, PencilArrays.jl, PencilFFTs.jl) are included as dependencies and installed automatically.\n\nTo run MPI simulations, you need a system MPI library:\n\nmacOS: brew install open-mpi\nUbuntu: apt install libopenmpi-dev","category":"section"},{"location":"getting_started/#Quick-Example","page":"Installation","title":"Quick Example","text":"using QGYBJplus\n\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # Domain (REQUIRED)\n    nx=64, ny=64, nz=32,\n    dt=0.001, total_time=1.0\n)\n\nresult = run_simple_simulation(config)\nprintln(\"KE: \", flow_kinetic_energy(result.state.u, result.state.v))","category":"section"},{"location":"getting_started/#Core-Types","page":"Installation","title":"Core Types","text":"","category":"section"},{"location":"getting_started/#QGParams","page":"Installation","title":"QGParams","text":"params = default_params(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # REQUIRED\n    nx=64, ny=64, nz=32,\n    f₀=1.0, N²=1.0,\n    ybj_plus=true\n)\n\nUnicode: type f\\_0<tab> → f₀, \\nu<tab> → ν","category":"section"},{"location":"getting_started/#Grid-and-State","page":"Installation","title":"Grid & State","text":"grid = init_grid(params)     # Coordinates, wavenumbers\nstate = init_state(grid)     # Fields: q, B, psi, A, u, v\nplans = plan_transforms!(grid)  # FFT plans","category":"section"},{"location":"getting_started/#Code-Structure","page":"Installation","title":"Code Structure","text":"src/\n├── parameters.jl      # QGParams\n├── grid.jl            # Grid struct\n├── elliptic.jl        # q→ψ, B→A inversions\n├── timestep.jl        # Leapfrog\n├── timestep_imex.jl   # IMEX-CN (faster)\n├── simulation.jl      # High-level API\n└── parallel_mpi.jl    # MPI support","category":"section"},{"location":"getting_started/#What's-Next?","page":"Installation","title":"What's Next?","text":"Quick Start - Tutorial\nConfiguration - All parameters\nMPI Parallelization - Large-scale runs","category":"section"},{"location":"quickstart/#quickstart","page":"Quick Start","title":"Quick Start Tutorial","text":"Run your first QGYBJ+.jl simulation in 5 minutes.\n\n","category":"section"},{"location":"quickstart/#Minimal-Example","page":"Quick Start","title":"Minimal Example","text":"<div class=\"quickstart-card\">\n\nusing QGYBJplus\n\n# Configure (Lx, Ly, Lz are REQUIRED)\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # Domain size [m]\n    nx=64, ny=64, nz=32,             # Grid points\n    dt=0.001, total_time=1.0,        # Time stepping\n    output_interval=100\n)\n\n# Run\nresult = run_simple_simulation(config)\n\n# Check results\nprintln(\"Kinetic Energy: \", flow_kinetic_energy(result.state.u, result.state.v))\n\n</div>\n\n","category":"section"},{"location":"quickstart/#Step-by-Step-Breakdown","page":"Quick Start","title":"Step-by-Step Breakdown","text":"","category":"section"},{"location":"quickstart/#Step-1:-Create-Configuration","page":"Quick Start","title":"Step 1: Create Configuration","text":"config = create_simple_config(\n    Lx = 500e3,        # Domain length x [m] (REQUIRED)\n    Ly = 500e3,        # Domain length y [m] (REQUIRED)\n    Lz = 4000.0,       # Domain depth [m] (REQUIRED)\n    nx = 64, ny = 64, nz = 32,  # Grid dimensions\n    dt = 0.001,        # Time step\n    total_time = 1.0,  # Total simulation time\n)\n\nwarning: Domain size is required\nThere are no default values for Lx, Ly, Lz. Omitting them causes a MethodError.","category":"section"},{"location":"quickstart/#Step-2:-Run-Simulation","page":"Quick Start","title":"Step 2: Run Simulation","text":"result = run_simple_simulation(config)\n\nThis returns a Simulation object containing:\n\nresult.state — Final state with all fields\nresult.grid — Grid information\nresult.params — Simulation parameters","category":"section"},{"location":"quickstart/#Step-3:-Access-Results","page":"Quick Start","title":"Step 3: Access Results","text":"state = result.state\n\n# Spectral fields (complex, in Fourier space)\nstate.psi    # Streamfunction\nstate.B      # Wave envelope\nstate.A      # Wave amplitude (diagnosed from B)\nstate.C      # Vertical derivative of A\n\n# Physical fields (real, in physical space)\nstate.u      # Zonal velocity\nstate.v      # Meridional velocity\nstate.w      # Vertical velocity","category":"section"},{"location":"quickstart/#Step-4:-Compute-Diagnostics","page":"Quick Start","title":"Step 4: Compute Diagnostics","text":"# Mean flow kinetic energy\nKE = flow_kinetic_energy(state.u, state.v)\n\n# Wave energy components per YBJ+ equation (4.7)\nWKE, WPE, WCE = compute_detailed_wave_energy(state, result.grid, result.params)\n\n# Simple wave energy\nWE_B, WE_A = wave_energy(state.B, state.A)\n\n","category":"section"},{"location":"quickstart/#Common-Configuration-Options","page":"Quick Start","title":"Common Configuration Options","text":"<div class=\"feature-grid\">\n<div class=\"feature-card\">\n    <h3>Physics Options</h3>\n    <p>Control the physical model behavior</p>\n</div>\n<div class=\"feature-card\">\n    <h3>Stratification</h3>\n    <p>Choose ocean density profile</p>\n</div>\n</div>\n\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    nx=64, ny=64, nz=32,\n\n    # Physics options\n    ybj_plus = true,          # YBJ+ formulation (default)\n    linear = false,           # Set true to disable nonlinear terms\n    inviscid = true,          # Set true for no dissipation\n    no_wave_feedback = true,  # Set true for one-way coupling (eddies → waves only)\n\n    # Stratification\n    stratification_type = :constant_N,  # or :skewed_gaussian\n)\n\nOption Default Description\nybj_plus true Use YBJ+ formulation (recommended)\nlinear false Disable nonlinear advection terms\ninviscid false Disable all dissipation\nno_wave_feedback false Disable wave feedback on mean flow\nstratification_type :constant_N Ocean density profile type\n\n","category":"section"},{"location":"quickstart/#Output-Files","page":"Quick Start","title":"Output Files","text":"By default, simulations save to ./output_simple/:\n\noutput_simple/\n├── state0001.nc          # Field snapshots\n├── state0002.nc\n└── diagnostic/           # Energy time series\n    ├── wave_KE.nc\n    ├── mean_flow_KE.nc\n    └── total_energy.nc\n\n","category":"section"},{"location":"quickstart/#What's-Next?","page":"Quick Start","title":"What's Next?","text":"<div class=\"learning-path\">\n<div class=\"path-step\">\n    <div class=\"step-number\">→</div>\n    <div class=\"step-content\">\n        <strong><a href=\"../worked_example/\">Worked Example</a></strong> — Detailed step-by-step walkthrough\n    </div>\n</div>\n<div class=\"path-step\">\n    <div class=\"step-number\">→</div>\n    <div class=\"step-content\">\n        <strong><a href=\"../guide/configuration/\">Configuration Guide</a></strong> — All available parameters\n    </div>\n</div>\n<div class=\"path-step\">\n    <div class=\"step-number\">→</div>\n    <div class=\"step-content\">\n        <strong><a href=\"../advanced/parallel/\">MPI Parallelization</a></strong> — Run large-scale simulations\n    </div>\n</div>\n</div>","category":"section"},{"location":"api/particles/#api-particles","page":"Particles","title":"Particle API","text":"This page documents the particle advection API for Lagrangian tracking.","category":"section"},{"location":"api/particles/#Core-Types","page":"Particles","title":"Core Types","text":"","category":"section"},{"location":"api/particles/#Particle-Initialization-Constructors","page":"Particles","title":"Particle Initialization Constructors","text":"Simple, intuitive functions for creating particle distributions:","category":"section"},{"location":"api/particles/#Initialization-and-Advection","page":"Particles","title":"Initialization and Advection","text":"","category":"section"},{"location":"api/particles/#I/O-Functions","page":"Particles","title":"I/O Functions","text":"","category":"section"},{"location":"api/particles/#Interpolation-Methods","page":"Particles","title":"Interpolation Methods","text":"","category":"section"},{"location":"api/particles/#Parallel-Utilities","page":"Particles","title":"Parallel Utilities","text":"","category":"section"},{"location":"api/particles/#3D-Particle-Types","page":"Particles","title":"3D Particle Types","text":"","category":"section"},{"location":"api/particles/#Quick-Reference","page":"Particles","title":"Quick Reference","text":"Constructor Description Example\nparticles_in_box(z; x_max, y_max, ...) 2D box at fixed z particles_in_box(-500.0; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\nparticles_in_circle(z; ...) Circular disk particles_in_circle(-1.0; radius=0.5, n=100)\nparticles_in_grid_3d(; x_max, y_max, z_max, ...) 3D grid particles_in_grid_3d(; x_max=G.Lx, y_max=G.Ly, z_max=G.Lz, nx=10, ny=10, nz=5)\nparticles_in_layers(zs; x_max, y_max, ...) Multiple z-levels particles_in_layers([-500.0, -1000.0, -1500.0]; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\nparticles_random_3d(n; x_max, y_max, z_max, ...) Random 3D particles_random_3d(500; x_max=G.Lx, y_max=G.Ly, z_max=G.Lz)\nparticles_custom(pos; ...) Custom positions particles_custom([(1.0,1.0,-0.5), ...])\n\nNote: z is in [-Lz, 0] with z = 0 at the surface. If z_min is omitted, z_max is treated as a positive depth (e.g., z_max=G.Lz gives the full depth). Single-level distributions (e.g., particles_in_circle or particles_custom) can use z_min == z_max.","category":"section"},{"location":"api/particles/#Usage-Example","page":"Particles","title":"Usage Example","text":"using QGYBJplus\n\n# Setup model\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a = setup_model(par)\n\n# Create particle configuration (100 particles in a box at z = -2000 m)\n# NOTE: x_max, y_max are REQUIRED - use G.Lx, G.Ly from grid\npconfig = particles_in_box(-2000.0;\n    x_max=G.Lx, y_max=G.Ly,  # REQUIRED\n    nx=10, ny=10,\n    integration_method=:rk4,\n    save_interval=0.1\n)\n\n# Or use a circular distribution (no x_max/y_max needed - computed from center/radius)\npconfig = particles_in_circle(-2000.0; center=(G.Lx/2, G.Ly/2), radius=50e3, n=100)\n\n# Or multiple z-levels (x_max, y_max REQUIRED)\npconfig = particles_in_layers([-1000.0, -2000.0, -3000.0]; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\n\n# Create tracker and initialize\ntracker = ParticleTracker(pconfig, G)\ninitialize_particles!(tracker, pconfig)\n\n# Advection loop\ndt = par.dt\nfor step in 1:1000\n    compute_velocities!(S, G, plans)\n    advect_particles!(tracker, S, G, dt, step * dt)\nend\n\n# Write trajectories\nwrite_particle_trajectories(\"trajectories.nc\", tracker)","category":"section"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.ParticleConfig","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.ParticleConfig","text":"Configuration for particle initialization and advection.\n\nKey parameters:\n\nSpatial domain: xmin/max, ymin/max, z_level for initial particle placement\nParticle count: nxparticles × nyparticles \nPhysics options: useybjw (vertical velocity), use3dadvection\nTiming control: particleadvectime - when to start advecting particles\nIntegration: method (:euler, :rk2, :rk4) and interpolation scheme\nBoundaries: periodicx/y, reflectz for boundary conditions\nI/O: saveinterval and maxsave_points for trajectory output\n\nAdvanced timing control:\n\nparticleadvectime=0.0: Start advecting immediately (default)\nparticleadvectime>0.0: Keep particles stationary until this time\nUseful for letting flow field develop before particle release\nEnables study of transient vs established flow patterns\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.ParticleState","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.ParticleState","text":"Particle state including positions, global IDs, velocities, and trajectory history.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.ParticleTracker","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.ParticleTracker","text":"Main particle tracker that handles both serial and parallel execution.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.particles_in_box","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.particles_in_box","text":"particles_in_box([T=Float32], z_level; x_max, y_max, x_min=0, y_min=0, nx=10, ny=10, kwargs...)\n\nCreate 2D particle distribution at a fixed z-level. Default precision is Float32 for memory efficiency.\n\nArguments\n\nT: Optional type parameter (Float32 or Float64). Default: Float32\nz_level: The z-level (depth) for all particles\nx_max, y_max: Maximum domain bounds (REQUIRED)\nx_min, y_min: Minimum bounds (default: 0.0)\nnx, ny: Number of particles in each direction (default: 10 each)\n\nExamples\n\n# Default Float32 precision (recommended for memory efficiency)\nconfig = particles_in_box(500.0; x_max=G.Lx, y_max=G.Ly, nx=20, ny=20)\n\n# Explicit Float64 if higher precision needed\nconfig = particles_in_box(Float64, 500.0; x_max=G.Lx, y_max=G.Ly, nx=20, ny=20)\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_in_circle","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_in_circle","text":"particles_in_circle(z; center, radius, n, pattern, kwargs...)\n\nCreate particles distributed in a circular disk at a fixed z-level.\n\nArguments\n\nz: Vertical level where particles are placed\ncenter: (x, y) center of circle (default: (π, π))\nradius: Radius of the circular region (default: 1.0)\nn: Number of particles (default: 100)\npattern: Distribution pattern (default: :sunflower)\n:sunflower - Fibonacci spiral (very uniform, recommended)\n:rings - Concentric rings\n:random - Uniform random within disk\n\nExample\n\n# 100 particles in a circle at z = -π/2\nconfig = particles_in_circle(-π/2; radius=1.0, n=100)\n\n# Custom center and larger circle\nconfig = particles_in_circle(-1.0; center=(2.0, 2.0), radius=2.0, n=200)\n\n# Random distribution\nconfig = particles_in_circle(-π/4; radius=0.5, n=50, pattern=:random)\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_in_grid_3d","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_in_grid_3d","text":"particles_in_grid_3d(; x_max, y_max, z_max, nx, ny, nz, x_min=0, y_min=0, z_min=nothing, kwargs...)\n\nCreate particles uniformly distributed in a 3D rectangular grid.\n\nArguments\n\nx_max, y_max, z_max: Domain bounds (REQUIRED - use G.Lx, G.Ly, G.Lz)\nx_min, y_min: Minimum bounds (default: 0.0)\nz_min: Minimum z (default: nothing → uses full depth with z ∈ [-z_max, 0])\nnx, ny, nz: Number of particles in each direction\n\nExample\n\n# 1000 particles in a 10×10×10 3D grid\nconfig = particles_in_grid_3d(x_max=G.Lx, y_max=G.Ly, z_max=G.Lz, nx=10, ny=10, nz=10)\n\n# Custom subdomain\nconfig = particles_in_grid_3d(x_max=250e3, y_max=250e3, z_max=-500.0, z_min=-2000.0, nx=8, ny=8, nz=5)\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_in_layers","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_in_layers","text":"particles_in_layers(z_levels; x_max, y_max, nx, ny, x_min=0, y_min=0, kwargs...)\n\nCreate particles distributed in 2D grids at multiple z-levels.\n\nArguments\n\nz_levels: Vector of z-levels where particles are placed\nx_max, y_max: Domain bounds (REQUIRED - use G.Lx, G.Ly)\nx_min, y_min: Minimum bounds (default: 0.0)\nnx, ny: Number of particles per level in x and y (default: 10 each)\n\nExample\n\n# 3 layers at depths 1000m, 2000m, 3000m with 10×10 particles each\nconfig = particles_in_layers([-1000.0, -2000.0, -3000.0]; x_max=G.Lx, y_max=G.Ly, nx=10, ny=10)\n\n# Custom subdomain with 5 particles per side at each layer\nconfig = particles_in_layers([-500.0, -1000.0, -1500.0]; x_max=250e3, y_max=250e3, nx=5, ny=5)\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_random_3d","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_random_3d","text":"particles_random_3d(n; x_max, y_max, z_max, x_min=0, y_min=0, z_min=nothing, seed=1234, kwargs...)\n\nCreate randomly distributed particles in a 3D volume.\n\nArguments\n\nn: Number of particles\nx_max, y_max, z_max: Domain bounds (REQUIRED - use G.Lx, G.Ly, G.Lz)\nx_min, y_min: Minimum bounds (default: 0.0)\nz_min: Minimum z (default: nothing → uses full depth with z ∈ [-z_max, 0])\nseed: Random seed for reproducibility (default: 1234)\n\nExample\n\n# 500 random particles in the full domain\nconfig = particles_random_3d(500; x_max=G.Lx, y_max=G.Ly, z_max=G.Lz)\n\n# 1000 random particles in a subdomain\nconfig = particles_random_3d(1000; x_max=250e3, y_max=250e3, z_max=-500.0, z_min=-2000.0)\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_custom","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.particles_custom","text":"particles_custom(positions; kwargs...)\n\nCreate particles at user-specified positions.\n\nArguments\n\npositions: Vector of (x, y, z) tuples\n\nExample\n\n# 4 particles at specific locations\nconfig = particles_custom([(1.0, 1.0, 0.5), (2.0, 2.0, 1.0), (3.0, 1.5, 0.75), (1.5, 3.0, 1.25)])\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.initialize_particles!","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.initialize_particles!","text":"initialize_particles!(tracker, config)\n\nInitialize particles uniformly in specified region, handling both serial and parallel.\n\n\n\n\n\ninitialize_particles!(tracker, config3d)\n\nInitialize particles using enhanced 3D configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.advect_particles!","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.advect_particles!","text":"advect_particles!(tracker, state, grid, dt, current_time=nothing; params=nothing, N2_profile=nothing)\n\nAdvect particles using unified serial/parallel interface. Respects the particleadvectime setting - particles remain stationary until this time.\n\nParameters:\n\ntracker: ParticleTracker instance\nstate: Current fluid state\ngrid: Grid information\ndt: Time step\ncurrent_time: Current simulation time (if not provided, uses tracker's internal time)\nparams: Model parameters (QGParams). Required for YBJ vertical velocity to get correct f₀, N².\nN2profile: Optional N²(z) profile for nonuniform stratification. If not provided and `useybj_w=true`, will use constant N² from params, which may be inconsistent with the simulation's actual stratification.\n\nImportant\n\nWhen using YBJ vertical velocity (use_ybj_w=true) with variable stratification, you MUST pass the same N2_profile used in the simulation. Otherwise, compute_ybj_vertical_velocity! will re-invert B→A with constant N², giving inconsistent particle velocities.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.interpolate_velocity_at_position","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.interpolate_velocity_at_position","text":"interpolate_velocity_at_position(x, y, z, tracker)\n\nInterpolate velocity at particle position with advanced schemes and cross-domain capability.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.ParticleIO.write_particle_trajectories","page":"Particles","title":"QGYBJplus.ParticleIO.write_particle_trajectories","text":"write_particle_trajectories(filename, tracker; metadata=Dict())\n\nWrite complete particle trajectory history to NetCDF file.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.ParticleIO.read_particle_trajectories","page":"Particles","title":"QGYBJplus.ParticleIO.read_particle_trajectories","text":"read_particle_trajectories(filename) -> NamedTuple\n\nRead particle trajectory history from NetCDF file.\n\nReturns a NamedTuple with fields:\n\nx: Matrix of x positions (np × ntime)\ny: Matrix of y positions (np × ntime)\nz: Matrix of z positions (np × ntime)\ntime: Vector of time values (ntime)\nparticle_ids: Vector of particle identifiers (np)\nattributes: Dict of global attributes from the file\n\nThis is the inverse of write_particle_trajectories.\n\nExample\n\n# Write trajectories\nwrite_particle_trajectories(\"particles.nc\", tracker)\n\n# Read them back\ntraj = read_particle_trajectories(\"particles.nc\")\nprintln(\"Number of particles: \", size(traj.x, 1))\nprintln(\"Number of time steps: \", length(traj.time))\nprintln(\"Initial x positions: \", traj.x[:, 1])\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.ParticleIO.write_particle_snapshot","page":"Particles","title":"QGYBJplus.ParticleIO.write_particle_snapshot","text":"write_particle_snapshot(filename, tracker, time)\n\nWrite current particle positions to NetCDF file (single time snapshot).\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.ParticleIO.write_particle_trajectories_by_zlevel","page":"Particles","title":"QGYBJplus.ParticleIO.write_particle_trajectories_by_zlevel","text":"write_particle_trajectories_by_zlevel(base_filename, tracker;\n                                      z_tolerance=1e-6, metadata=Dict())\n\nWrite particle trajectories to separate files based on z-level.\n\nThis function groups particles by their initial z-level and saves each group to a separate NetCDF file. Useful for analyzing particles initialized at different depths independently.\n\nParameters:\n\nbasefilename: Base name for output files (e.g., \"particles\" -> \"particlesz1.23.nc\")\ntracker: ParticleTracker instance with trajectory history\nz_tolerance: Tolerance for grouping particles by z-level (default: 1e-6)\nmetadata: Additional metadata to include in all files\n\nReturns: Dictionary mapping z-levels to filenames\n\nExample:\n\n# Initialize particles at multiple z-levels\nconfig = create_layered_distribution(0.0, 2π, 0.0, 2π, [π/4, π/2, 3π/4], 4, 4)\ntracker = ParticleTracker(config, grid, parallel_config)\n\n# Run simulation...\n\n# Save each z-level to separate file\nfiles = write_particle_trajectories_by_zlevel(\"particles\", tracker)\n# Creates: particles_z0.785.nc, particles_z1.571.nc, particles_z2.356.nc\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.InterpolationSchemes.InterpolationMethod","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.InterpolationSchemes.InterpolationMethod","text":"Available interpolation methods.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.validate_particle_cfl","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.validate_particle_cfl","text":"validate_particle_cfl(tracker, max_velocity, dt)\n\nCheck if timestep satisfies CFL condition for particle advection in parallel mode.\n\nFor RK4 integration, intermediate positions can move up to dt*max_velocity from their starting position. If this exceeds the halo region, interpolation will be inaccurate.\n\nReturns true if timestep is safe, false if timestep may cause issues.\n\nWarning\n\nIf this returns false, consider:\n\nReducing dt\nIncreasing halo_width (use higher-order interpolation which has wider halos)\nUsing Euler instead of RK4 (which only evaluates at current position)\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleConfig3D","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleConfig3D","text":"Enhanced particle configuration supporting 3D distributions.\n\nDomain bounds (xmax, ymax, zmax) are REQUIRED - no defaults. Use the Grid to get domain size: `xmax = G.Lx, ymax = G.Ly, zmax = G.Lz(depth). If you passzmin, thenzmaxis treated as a coordinate (typically ≤ 0). Single-level distributions can usezmin == zmax`.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleDistribution","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleDistribution","text":"Available particle distribution patterns.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.initialize_particles_3d!","page":"Particles","title":"QGYBJplus.UnifiedParticleAdvection.EnhancedParticleConfig.initialize_particles_3d!","text":"initialize_particles_3d!(tracker, config3d)\n\nInitialize particles using 3D configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#api-physics","page":"Physics Functions","title":"Physics Functions","text":"This page documents the physics functions in QGYBJ+.jl.","category":"section"},{"location":"api/physics/#Elliptic-Inversions","page":"Physics Functions","title":"Elliptic Inversions","text":"","category":"section"},{"location":"api/physics/#Streamfunction-Inversion","page":"Physics Functions","title":"Streamfunction Inversion","text":"Solves: nabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q\n\nUsage:\n\n# Serial mode\ninvert_q_to_psi!(state, grid; a=a_ell)\n\n# Parallel mode (with workspace for 2D decomposition)\ninvert_q_to_psi!(state, grid; a=a_ell, workspace=workspace)\n# Updates state.psi from state.q","category":"section"},{"location":"api/physics/#Wave-Amplitude-Inversion","page":"Physics Functions","title":"Wave Amplitude Inversion","text":"Solves: fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright) - frack_h^24A = B\n\nUsage:\n\n# Serial mode\ninvert_B_to_A!(state, grid, params, a_ell)\n\n# Parallel mode (with workspace for 2D decomposition)\ninvert_B_to_A!(state, grid, params, a_ell; workspace=workspace)\n# Updates state.A from state.B","category":"section"},{"location":"api/physics/#Helmholtz-Solver","page":"Physics Functions","title":"Helmholtz Solver","text":"","category":"section"},{"location":"api/physics/#Nonlinear-Terms","page":"Physics Functions","title":"Nonlinear Terms","text":"","category":"section"},{"location":"api/physics/#Jacobian","page":"Physics Functions","title":"Jacobian","text":"Computes: J(a b) = fracpartial apartial xfracpartial bpartial y - fracpartial apartial yfracpartial bpartial x","category":"section"},{"location":"api/physics/#Wave-Advection-and-Refraction","page":"Physics Functions","title":"Wave Advection and Refraction","text":"The wave nonlinear terms are documented in the Time Stepping API:\n\nconvol_waqg_B! / refraction_waqg_B! / compute_qw_complex! - Complex B (YBJ+) operators\nconvol_waqg! / refraction_waqg! / compute_qw! - BR/BI-decomposed operators","category":"section"},{"location":"api/physics/#Velocity-Computation","page":"Physics Functions","title":"Velocity Computation","text":"Computes:\n\nu = -partialpsipartial y\nv = partialpsipartial x","category":"section"},{"location":"api/physics/#Vertical-Velocity","page":"Physics Functions","title":"Vertical Velocity","text":"","category":"section"},{"location":"api/physics/#Total-Velocities","page":"Physics Functions","title":"Total Velocities","text":"","category":"section"},{"location":"api/physics/#Dissipation","page":"Physics Functions","title":"Dissipation","text":"","category":"section"},{"location":"api/physics/#Vertical-Diffusion","page":"Physics Functions","title":"Vertical Diffusion","text":"Dissipation functions are documented in the Time Stepping API:\n\ndissipation_q_nv! - Applies vertical diffusion nu_z partial^2 q  partial z^2\nint_factor - Integrating factor for stiff hyperdiffusion terms","category":"section"},{"location":"api/physics/#Diagnostics-Functions","page":"Physics Functions","title":"Diagnostics Functions","text":"","category":"section"},{"location":"api/physics/#Energy","page":"Physics Functions","title":"Energy","text":"Flow Kinetic Energy:\n\nWave Energy:","category":"section"},{"location":"api/physics/#Spectral-Energy-Functions","page":"Physics Functions","title":"Spectral Energy Functions","text":"The following spectral energy functions compute energy with proper dealiasing and density weighting:","category":"section"},{"location":"api/physics/#Global-Energy-Functions-(MPI-aware)","page":"Physics Functions","title":"Global Energy Functions (MPI-aware)","text":"For parallel simulations, use these MPI-aware versions that reduce across all processes:\n\nPhysical-space energy (simple sum):\n\nSpectral energy (with dealiasing):","category":"section"},{"location":"api/physics/#Energy-Diagnostics-Manager","page":"Physics Functions","title":"Energy Diagnostics Manager","text":"The EnergyDiagnosticsManager provides automatic saving of energy time series to separate NetCDF files:\n\nOutput Files:\n\ndiagnostic/wave_KE.nc - Wave kinetic energy\ndiagnostic/wave_PE.nc - Wave potential energy\ndiagnostic/wave_CE.nc - Wave correction energy (YBJ+)\ndiagnostic/mean_flow_KE.nc - Mean flow kinetic energy\ndiagnostic/mean_flow_PE.nc - Mean flow potential energy\ndiagnostic/total_energy.nc - Summary with all energies\n\nUsage:\n\n# Automatic (created during setup_simulation)\nsim = setup_simulation(config)\nrun_simulation!(sim)  # Energies saved automatically\n\n# Manual\nmanager = EnergyDiagnosticsManager(\"output_dir\"; output_interval=1.0)\nrecord_energies!(manager, time, wke, wpe, wce, mke, mpe)\nwrite_all_energy_files!(manager)","category":"section"},{"location":"api/physics/#Omega-Equation","page":"Physics Functions","title":"Omega Equation","text":"","category":"section"},{"location":"api/physics/#Transform-Functions","page":"Physics Functions","title":"Transform Functions","text":"","category":"section"},{"location":"api/physics/#Forward-Transforms","page":"Physics Functions","title":"Forward Transforms","text":"Real space → Spectral space","category":"section"},{"location":"api/physics/#Backward-Transforms","page":"Physics Functions","title":"Backward Transforms","text":"Spectral space → Real space","category":"section"},{"location":"api/physics/#Dealiasing","page":"Physics Functions","title":"Dealiasing","text":"Creates a radial dealiasing mask using the 2/3 rule: modes with k_h^2  k_max^2 where k_max = min(n_x n_y)  3 are zeroed.","category":"section"},{"location":"api/physics/#Hyperdiffusion-Parameters","page":"Physics Functions","title":"Hyperdiffusion Parameters","text":"Helper functions for computing scale-selective hyperdiffusion coefficients:\n\n4th Order Hyperdiffusion (Biharmonic):\n\nThe model supports 4th order horizontal hyperdiffusion (∇⁴ operator) for scale-selective damping of grid-scale noise while preserving large scales:\n\n# Compute coefficient for 10-step e-folding at grid scale\nhd = compute_hyperdiff_params(\n    nx=128, ny=128, Lx=70e3, Ly=70e3, dt=10.0,\n    order=4, efold_steps=10\n)\n\n# Use in parameters\npar = default_params(\n    nx=128, ny=128, nz=64,\n    Lx=70e3, Ly=70e3, Lz=3000.0,\n    νₕ₁=hd.ν, ilap1=hd.ilap,  # 4th order hyperdiffusion\n    νₕ₂=0.0                    # Disable 2nd hyperviscosity slot\n)\n\nDamping Rate:\n\nThe damping rate at wavenumber k is:\n\n2nd order (∇²): lambda = nu_2 k^2\n4th order (∇⁴): lambda = nu_4 k^4\n8th order (∇⁸): lambda = nu_8 k^8\n\nHigher orders provide more scale-selective damping, concentrating dissipation at the smallest scales.","category":"section"},{"location":"api/physics/#YBJ-Normal-Mode-Functions","page":"Physics Functions","title":"YBJ Normal Mode Functions","text":"","category":"section"},{"location":"api/physics/#Function-Signatures-Summary","page":"Physics Functions","title":"Function Signatures Summary","text":"Function Input Output In-place\ninvert_q_to_psi! q psi Yes\ninvert_B_to_A! B A, C Yes\njacobian_spectral! a, b J(a,b) Yes\ncompute_velocities! psi u, v Yes\nflow_kinetic_energy u, v scalar No\nflow_kinetic_energy_global u, v, mpi_config scalar No\nwave_energy B, A (EB, EA) No\nwave_energy_global B, A, mpi_config (EB, EA) No","category":"section"},{"location":"api/physics/#Performance-Notes","page":"Physics Functions","title":"Performance Notes","text":"All physics functions are in-place to avoid allocations\nFFT plans are pre-computed for efficiency\nTridiagonal systems use Thomas algorithm (O(n))\nFunctions are type-stable for optimal JIT compilation","category":"section"},{"location":"api/physics/#2D-Decomposition-Notes","page":"Physics Functions","title":"2D Decomposition Notes","text":"Functions requiring vertical operations automatically detect 2D decomposition and use the appropriate method:\n\nFunction Serial Parallel (2D)\ninvert_q_to_psi! Direct solve Transpose → solve → transpose\ninvert_B_to_A! Direct solve Transpose → solve → transpose\ncompute_vertical_velocity! Direct solve Transpose → solve → transpose\ndissipation_q_nv! Direct Transpose if needed\n\nPattern:\n\nneed_transpose = G.decomp !== nothing && hasfield(typeof(G.decomp), :pencil_z)\nif need_transpose\n    _function_2d!(...)   # Uses transpose operations\nelse\n    _function_direct!(...)  # Direct vertical access\nend\n\nWorkspace requirement: Pass workspace argument for parallel mode to avoid repeated allocation of z-pencil arrays.","category":"section"},{"location":"api/physics/#QGYBJplus.Elliptic.invert_q_to_psi!","page":"Physics Functions","title":"QGYBJplus.Elliptic.invert_q_to_psi!","text":"invert_q_to_psi!(S, G; a, par=nothing, workspace=nothing)\n\nInvert spectral QGPV q(kx,ky,z) to obtain streamfunction ψ(kx,ky,z).\n\nMathematical Problem\n\nFor each horizontal wavenumber (kₓ, kᵧ), solve the vertical ODE:\n\n∂/∂z(a(z) ∂ψ/∂z) - kₕ² ψ = q\n\nwhich expands via the product rule to: a(z)∂²ψ/∂z² + a'(z)∂ψ/∂z - kₕ²ψ = q. The staggered discretization captures a'∂ψ/∂z automatically.\n\nNeumann boundary conditions ψ_z = 0 at top and bottom.\n\nArguments\n\nS::State: State struct containing q (input) and psi (output)\nG::Grid: Grid struct with wavenumbers and vertical coordinates\na::AbstractVector: Elliptic coefficient a_ell(z) = f²/N²(z), length nz\npar: Optional QGParams for density weighting (defaults to unity weights)\nworkspace: Optional z-pencil workspace arrays for 2D decomposition\n\nImplementation Details\n\nFor 2D decomposition:\n\nTranspose q from xy-pencil to z-pencil (z becomes local)\nPerform tridiagonal solve on z-pencil data\nTranspose ψ from z-pencil back to xy-pencil\n\nThe discrete system is tridiagonal with structure (for interior row k):\n\nUpper diagonal: du[k] = a[k+1]/r_stk\nDiagonal: d[k] = -(a[k+1] + a[k])/r_st[k] - kₕ² dz²\nLower diagonal: dl[k] = a[k]/r_stk\n\nwhere a[k] is at the interface below cell k (between cells k-1 and k), and rut, rst are density weights (unity for Boussinesq).\n\nFortran Correspondence\n\nThis matches psi_solver in elliptic.f90.\n\nMean Mode (kₕ=0) Handling\n\nFor the horizontal mean mode (kₓ=kᵧ=0), the equation reduces to:     ∂/∂z(a(z) ∂ψ/∂z) = q\n\nWith Neumann boundary conditions (∂ψ/∂z=0 at both boundaries), this operator is singular: the homogeneous equation has the constant function as its null space. Consequently:\n\nA solution exists only if ∫q dz = 0 (compatibility condition)\nThe solution is determined only up to an arbitrary constant\n\nThis implementation sets ψ=0 for kₕ=0 because:\n\nFor periodic domains, the mean streamfunction doesn't affect velocities (u = -∂ψ/∂y, v = ∂ψ/∂x, both zero for constant ψ)\nStandard spectral QG codes typically ignore the barotropic mean\nInitial conditions and forcing are assumed to have zero horizontal mean\n\nIf your application requires tracking vertically-varying barotropic modes, you would need to solve the singular ODE with an additional constraint (e.g., ∫ψ dz = 0) to uniquely determine the solution.\n\nExample\n\na_vec = a_ell_ut(params, G)  # Compute a_ell = f²/N²\ninvert_q_to_psi!(state, grid; a=a_vec)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Elliptic.invert_B_to_A!","page":"Physics Functions","title":"QGYBJplus.Elliptic.invert_B_to_A!","text":"invert_B_to_A!(S, G, par, a; workspace=nothing)\n\nYBJ+ wave amplitude recovery: solve for A given B = L⁺A.\n\nMathematical Problem\n\nFor each horizontal wavenumber (kₓ, kᵧ), solve the elliptic equation:\n\nL⁺A = ∂/∂z(a(z) ∂A/∂z) - (kₕ²/4) A = B\n\nwhich expands via the product rule to:\n\na(z) ∂²A/∂z² + a'(z) ∂A/∂z - (kₕ²/4) A = B\n\nwith Neumann boundary conditions A_z = 0 at top and bottom.\n\nThe staggered discretization using Si = (f/(N(zi)Δz))² at different interfaces automatically captures the a'(z)∂A/∂z term from variable stratification.\n\nArguments\n\nS::State: State containing B (input), A and C (output)\nG::Grid: Grid struct\npar: QGParams (for f0, N2 parameters)\na::AbstractVector: Elliptic coefficient a_ell(z) = f²/N²(z)\nworkspace: Optional z-pencil workspace for 2D decomposition\n\nOutput Fields\n\nS.A: Recovered wave amplitude A\nS.C: Vertical derivative C = ∂A/∂z (for wave velocity computation)\n\nMean Mode (kₕ=0) Handling\n\nFor the horizontal mean mode (kₓ=kᵧ=0), the equation reduces to:     ∂/∂z(a(z) ∂A/∂z) = B\n\nWith Neumann boundary conditions (∂A/∂z=0 at both boundaries), this operator is singular - the constant function is in its null space. To select a unique solution, we:\n\nFix a gauge (A[1]=0) to obtain a particular solution.\nRemove the vertical mean of A (adds a constant null-space mode).\n\nThis yields a well-defined, mean-zero A for kₕ=0 while preserving the original equation.\n\nFortran Correspondence\n\nThis matches A_solver_ybj_plus in elliptic.f90 (PDF Eq. 33-35).\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Elliptic.invert_helmholtz!","page":"Physics Functions","title":"QGYBJplus.Elliptic.invert_helmholtz!","text":"invert_helmholtz!(dstk, rhs, G, par; a, b=zeros, scale_kh2=1.0, bot_bc=nothing, top_bc=nothing, workspace=nothing)\n\nGeneral vertical Helmholtz inversion for each horizontal wavenumber.\n\nMathematical Problem\n\nSolve the ODE:\n\na(z) ∂²φ/∂z² + b(z) ∂φ/∂z - scale_kh2 × kₕ² φ = rhs\n\nwith Neumann boundary conditions (∂φ/∂z specified at boundaries).\n\nDiscretization (matches Fortran helmholtzdouble)\n\nUses a centered stencil where same a[k], b[k] apply to all diagonals at point k:\n\nBottom (k=1):  d = -a[1] - 0.5b[1]Δz - αkₕ²Δz², du = a[1] + 0.5b[1]Δz\nInterior:      d = -2a[k] - αkₕ²Δz², du = a[k] + 0.5b[k]Δz, dl = a[k] - 0.5b[k]Δz\nTop (k=nz):    d = -a[nz] + 0.5b[nz]Δz - αkₕ²Δz², dl = a[nz] - 0.5b[nz]Δz\n\nBoundary flux terms are added to RHS:\n\nBottom: rhs[1] += (a[1] - 0.5b[1]Δz) × Δz × bot_bc\nTop:    rhs[nz] -= (a[nz] + 0.5b[nz]Δz) × Δz × top_bc\n\nArguments\n\ndstk: Output array (nz, nx, ny) for solution φ\nrhs: Right-hand side array (nz, nx, ny)\nG::Grid: Grid struct\npar: QGParams (currently unused, kept for API consistency)\na::AbstractVector: Second derivative coefficient a(z), length nz\nb::AbstractVector: First derivative coefficient b(z), length nz (default zeros)\nscale_kh2::Real: Multiplier α for kₕ² term (default 1.0)\nbot_bc, top_bc: Optional boundary flux arrays (nx, ny) for non-zero Neumann BCs\nworkspace: Optional z-pencil workspace for 2D decomposition\n\nFortran Correspondence\n\nThis matches helmholtzdouble in elliptic.f90 exactly.\n\nNote\n\nFor 2D decomposition, boundary conditions are not yet supported and will trigger a warning.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Nonlinear.jacobian_spectral!","page":"Physics Functions","title":"QGYBJplus.Nonlinear.jacobian_spectral!","text":"jacobian_spectral!(dstk, phik, chik, G, plans; Lmask=nothing)\n\nCompute the Jacobian J(φ, χ) = ∂φ/∂x ∂χ/∂y - ∂φ/∂y ∂χ/∂x using pseudo-spectral method.\n\nnote: Usage Note\nThis function is exported for user convenience but is not used in the main time-stepping code. The main code uses convol_waqg! instead, which computes advection terms using the divergence form with precomputed velocities.\n\nMathematical Definition\n\nThe Jacobian (also called Poisson bracket) is:\n\nJ(φ, χ) = ∂φ/∂x ∂χ/∂y - ∂φ/∂y ∂χ/∂x\n\nIn vector form: J(φ, χ) = ẑ · (∇φ × ∇χ)\n\nPhysical Interpretation\n\nJ(ψ, q): Advection of PV by geostrophic flow\nJ(ψ, B): Advection of wave envelope by mean flow\nThe Jacobian conserves both integrals ∫φ and ∫χ\n\nAlgorithm\n\nCompute spectral derivatives: φ̂ₓ = ikₓφ̂, φ̂ᵧ = ikᵧφ̂\nTransform derivatives to physical space\nCompute product: J = φₓχᵧ - φᵧχₓ (pointwise)\nTransform result back to spectral space\n\nArguments\n\ndstk: Output array for Ĵ(φ, χ) in spectral space\nphik: φ̂ in spectral space (must be real field, i.e., Hermitian symmetric)\nchik: χ̂ in spectral space (must be real field, i.e., Hermitian symmetric)\nG::Grid: Grid with wavenumber arrays\nplans: FFT plans from plan_transforms!\nLmask: Optional 2/3 dealiasing mask (true = keep mode, false = zero)\n\nImportant\n\nThis function assumes φ and χ are real-valued fields in physical space. For real fields, IFFT of spectral derivatives (imkφ̂) yields real results (up to roundoff), so the physical derivatives are extracted via real().\n\nExample\n\n# Compute J(ψ, q) for real fields ψ and q\njacobian_spectral!(Jpsi_q, psi_k, q_k, grid, plans)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Operators.compute_velocities!","page":"Physics Functions","title":"QGYBJplus.Operators.compute_velocities!","text":"compute_velocities!(S, G; plans=nothing, params=nothing, compute_w=true, use_ybj_w=false, N2_profile=nothing, workspace=nothing, dealias_mask=nothing)\n\nCompute geostrophic velocities from the spectral streamfunction ψ̂.\n\nPhysical Equations\n\nHorizontal velocities from geostrophic balance:\n\nu = -∂ψ/∂y  →  û(k) = -i kᵧ ψ̂(k)\nv =  ∂ψ/∂x  →  v̂(k) =  i kₓ ψ̂(k)\n\nVertical velocity from QG omega equation:\n\n∇²w + (f²/N²) ∂²w/∂z² = (2f/N²) J(ψ_z, ∇²ψ)\n\nor YBJ formulation:\n\nw = -(f²/N²) [(∂A/∂x)_z - i(∂A/∂y)_z] + c.c.\n\nAlgorithm\n\nCompute û = -i kᵧ ψ̂ and v̂ = i kₓ ψ̂ in spectral space\nTransform to physical space via inverse FFT\nOptionally solve omega equation or use YBJ formula for w\n\nArguments\n\nS::State: State with ψ (input) and u, v, w (output)\nG::Grid: Grid with wavenumbers kx, ky\nplans: FFT plans (auto-generated if nothing)\nparams: Model parameters (for f₀, N²)\ncompute_w::Bool: If true, compute vertical velocity\nuse_ybj_w::Bool: If true, use YBJ formula instead of omega equation\nN2_profile::Vector: Optional N²(z) profile for vertical velocity computation\nworkspace: Optional pre-allocated workspace for 2D decomposition\ndealias_mask: Optional 2D dealiasing mask for omega equation RHS (quadratic term). Should be the same mask used for other nonlinear terms (typically 2/3 rule).\n\nReturns\n\nModified State with updated u, v, w fields.\n\nNote\n\nThis computes ONLY QG velocities. For Lagrangian advection including wave effects, use compute_total_velocities! instead.\n\nFortran Correspondence\n\nMatches compute_velo in derivatives.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Operators.compute_vertical_velocity!","page":"Physics Functions","title":"QGYBJplus.Operators.compute_vertical_velocity!","text":"compute_vertical_velocity!(S, G, plans, params; N2_profile=nothing, workspace=nothing, dealias_mask=nothing)\n\nSolve the QG omega equation for ageostrophic vertical velocity.\n\nPhysical Background\n\nIn quasi-geostrophic dynamics, the leading-order horizontal flow is non-divergent (∇·u_g = 0). Vertical motion arises from ageostrophic corrections that maintain thermal wind balance as the flow evolves.\n\nThe omega equation relates w to the horizontal flow:\n\nN² ∇²w + f² ∂²w/∂z² = 2f J(ψ_z, ∇²ψ)\n\nor equivalently (dividing by N²):\n\n∇²w + (f²/N²) ∂²w/∂z² = (2f/N²) J(ψ_z, ∇²ψ)\n\nwhere:\n\nLeft side: 3D Laplacian (horizontal + stratification-weighted vertical)\nRight side: Jacobian forcing from vertical shear and vorticity\nf²/N² << 1: stratification suppresses vertical motion relative to horizontal\n\nPhysical Interpretation\n\nThe RHS forcing J(ψ_z, ∇²ψ) represents:\n\nThermal wind tilting: vertical shear ψ_z interacting with vorticity ∇²ψ\nFrontogenesis/frontolysis: differential advection of temperature gradients\n\nStrong w occurs at:\n\nFronts (sharp density gradients)\nEdges of eddies (strong vorticity gradients)\n\nNumerical Method\n\nCompute RHS in spectral space via omegaeqnrhs!\nFor each horizontal wavenumber (kₓ, kᵧ):\nSet up tridiagonal system in z\nSolve using LAPACK gtsv! (O(nz) per wavenumber)\nTransform w to physical space\n\nBoundary Conditions\n\nw = 0 at z = -Lz and z = 0 (rigid lid and bottom).\n\nArguments\n\nS::State: State with ψ (input) and w (output)\nG::Grid: Grid structure\nplans: FFT plans\nparams: Model parameters (f₀)\nN2_profile::Vector: Optional N²(z) profile (default: constant N² = 1)\nworkspace: Optional pre-allocated workspace for 2D decomposition\ndealias_mask: 2D dealiasing mask for omega equation RHS. If nothing (default), a standard 2/3-rule mask is computed automatically to avoid aliasing in the quadratic Jacobian term.\n\nFortran Correspondence\n\nMatches omega equation solver in the Fortran implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Operators.compute_total_velocities!","page":"Physics Functions","title":"QGYBJplus.Operators.compute_total_velocities!","text":"compute_total_velocities!(S, G; plans=nothing, params=nothing, compute_w=true, use_ybj_w=false, N2_profile=nothing, workspace=nothing, dealias_mask=nothing, include_wave_velocity=true)\n\nCompute the TOTAL velocity field for Lagrangian particle advection.\n\nPhysical Background\n\nIn QG-YBJ+ dynamics, a particle is advected by:\n\nGeostrophic flow: uQG = -∂ψ/∂y, vQG = ∂ψ/∂x\nWave velocity: From YBJ+ equation (1.2): u + iv = e^{-ift} LA\nWave-induced Stokes drift: Second-order drift from near-inertial waves\n\nThe total velocity is:\n\nu_total = u_QG + u_wave + u_S\nv_total = v_QG + v_wave + v_S\nw_total = w_QG + w_S (from omega equation or YBJ, plus vertical Stokes drift)\n\nWave Velocity (Asselin & Young 2019, eq. 1.2)\n\nThe backrotated wave velocity is LA, where L = ∂z(f²/N²)∂z:\n\nu_wave = Re(LA)\nv_wave = Im(LA)\n\nFor YBJ+: B = L⁺A where L⁺ = L + (1/4)Δ, so LA = B - (1/4)ΔA. In spectral space: LA = B + (k_h²/4)A\n\nWave-Induced Stokes Drift\n\nFollowing Wagner & Young (2016) equations (3.16a)-(3.20), the Stokes drift uses the full Jacobian formulation:\n\nHorizontal Stokes drift (eq. 3.16a, 3.18):\n\nJ₀ = (LA)* ∂_{s*}(LA) - (f₀²/N²)(∂_{s*} A_z*) ∂_z(LA)\nu_S = Im(J₀)/f₀\nv_S = -Re(J₀)/f₀\n\nwhere ∂{s*} = (1/2)(∂x + i∂_y).\n\nVertical Stokes drift (eq. 3.19-3.20):\n\nK₀ = M*_z · M_{ss*} - M*_{s*} · M_{sz}   where M = (f₀²/N²)A_z\nw_S = -2·Im(K₀)/f₀\n\nwith Mz = az·A_z + a·A{zz}*, M{ss} = (a/4)·ΔH(Az), M{s*} = a·(A{zs})*, M{sz} = az·A{zs} + a·A{zzs}, and a = f₀²/N².\n\nUsage\n\nFor Lagrangian particle advection, always use this function rather than compute_velocities! to include wave effects.\n\nArguments\n\nS::State: State with ψ, A, B (input) and u, v, w (output)\nG::Grid: Grid structure\nplans: FFT plans\nparams: Model parameters\ncompute_w::Bool: If true, compute vertical velocity\nuse_ybj_w::Bool: If true, use YBJ formula for w\nN2_profile::Vector: Optional N²(z) profile for vertical velocity computation\nworkspace: Optional pre-allocated workspace for 2D decomposition\ndealias_mask: Optional 2D dealiasing mask for omega equation RHS\ninclude_wave_velocity::Bool: If true (default), include wave velocity Re(LA), Im(LA)\n\nReturns\n\nModified State with total velocity fields u, v, w.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.flow_kinetic_energy","page":"Physics Functions","title":"QGYBJplus.Diagnostics.flow_kinetic_energy","text":"flow_kinetic_energy(u, v) -> KE\n\nCompute domain-integrated kinetic energy of the geostrophic flow (simple version).\n\nPhysical Background\n\nThe kinetic energy of the balanced flow:\n\nKE = (1/2) ∫∫∫ (u² + v²) dx dy dz\n\nThis is a key diagnostic for:\n\nModel stability (unbounded growth indicates numerical issues)\nEnergy conservation/dissipation rate\nTurbulent cascade analysis\n\nReturns\n\nTotal kinetic energy (domain sum, not mean) in nondimensional units.\n\nNote\n\nThis is NOT normalized by volume. For energy density, divide by nx×ny×nz.\nIn MPI mode, this returns LOCAL energy. Use mpireducesum for global total.\nFor physically accurate energy with dealiasing and density weighting, use flow_kinetic_energy_spectral instead.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.wave_energy","page":"Physics Functions","title":"QGYBJplus.Diagnostics.wave_energy","text":"wave_energy(B, A) -> (E_B, E_A)\n\nCompute domain-integrated wave energy from both B and A fields (simple version).\n\nPhysical Background\n\nTwo measures of wave energy in the model:\n\nEnvelope energy E_B = Σ |B|²\nBased on the evolved wave envelope\nDirectly available from prognostic variable\nAmplitude energy E_A = Σ |A|²\nBased on the recovered wave amplitude\nMore physically meaningful for wave energy flux\n\nUse Cases\n\nMonitor total wave energy conservation/dissipation\nCompare EB and EA to verify B→A recovery\nTrack energy exchange with mean flow\n\nArguments\n\nB::Array{Complex,3}: Wave envelope (spectral or physical)\nA::Array{Complex,3}: Wave amplitude (spectral or physical)\n\nReturns\n\nTuple (EB, EA) of domain-summed squared magnitudes.\n\nNote\n\nThese are domain SUMS, not means. For energy density, divide by grid volume.\nIn MPI mode, this returns LOCAL energy. Use mpireducesum for global total.\nFor physically accurate wave energies with dealiasing and density weighting, use wave_energy_spectral instead.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.flow_kinetic_energy_spectral","page":"Physics Functions","title":"QGYBJplus.Diagnostics.flow_kinetic_energy_spectral","text":"flow_kinetic_energy_spectral(uk, vk, G, par; Lmask=nothing) -> KE\n\nCompute kinetic energy in spectral space with dealiasing and density weighting.\n\nPhysical Background (matches Fortran diagzentrum/energylinear)\n\nThe kinetic energy is computed as:\n\nKE(z) = Σₖ L(kₓ,kᵧ) × (|uₖ|² + |vₖ|²) - 0.5 × (|u₀₀|² + |v₀₀|²)\n\nThe dealiasing correction subtracts half the kh=0 mode because:\n\nWith 2/3 dealiasing: Σₖ (1/2)|u|² = Σₖ L|u|² - 0.5|u(0,0)|²\n\nThe total KE integrates over z with density weighting:\n\nKE_total = (1/nz) Σᵢ ρₛ(zᵢ) × KE(zᵢ)\n\nAlgorithm\n\nLoop over all spectral modes (kₓ, kᵧ, z) with dealiasing mask L\nAccumulate |u|² + |v|² at each level\nApply dealiasing correction: subtract half the kh=0 mode\nWeight by density ρₛ(z) and integrate (divide by nz)\n\nArguments\n\nuk, vk: Spectral velocity fields (complex)\nG::Grid: Grid structure\npar: QGParams (for density profiles)\nLmask: Optional dealiasing mask (default: all modes included)\n\nReturns\n\nTotal kinetic energy, normalized by nz, with density weighting.\n\nFortran Correspondence\n\nMatches the kinetic energy computation in diag_zentrum (diagnostics.f90:127-161) and energy_linear (diagnostics.f90:3024-3107).\n\nNote\n\nIn MPI mode, returns LOCAL energy. Use mpireducesum for global total.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.flow_potential_energy_spectral","page":"Physics Functions","title":"QGYBJplus.Diagnostics.flow_potential_energy_spectral","text":"flow_potential_energy_spectral(bk, G, par; Lmask=nothing) -> PE\n\nCompute potential energy in spectral space with dealiasing and density weighting.\n\nPhysical Background\n\nThe potential energy from buoyancy variance:\n\nPE(z) = Σₖ L(kₓ,kᵧ) × (a_ell × ρ₁/ρ₂) × |bₖ|² - 0.5 × correction\n\nwhere a_ell = f²/N² is the elliptic coefficient.\n\nFor QG: b = ψ_z, so PE represents available potential energy from isopycnal tilting.\n\nArguments\n\nbk: Spectral buoyancy field (complex)\nG::Grid: Grid structure\npar: QGParams (for f0, N2 and density profiles)\nLmask: Optional dealiasing mask\n\nReturns\n\nTotal potential energy, normalized by nz, with density weighting.\n\nFortran Correspondence\n\nMatches the potential energy computation in diag_zentrum (ps term).\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.wave_energy_spectral","page":"Physics Functions","title":"QGYBJplus.Diagnostics.wave_energy_spectral","text":"wave_energy_spectral(BR, BI, AR, AI, CR, CI, G, par; Lmask=nothing) -> (WKE, WPE, WCE)\n\nCompute physically accurate wave energies in spectral space with dealiasing.\n\nPhysical Background (matches YBJ+ paper)\n\nThree components of wave energy:\n\nWave Kinetic Energy (WKE) - per YBJ+ equation (4.7): WKE = (1/2) × Σₖ |LAₖ|²\nwhere LA is computed directly using the L operator from equation (1.3): L = ∂z(f²/N² × ∂z)\nSo LA = ∂_z(a(z) × C) where a(z) = f²/N² and C = ∂A/∂z. This is discretized as: LA[k] = (a[k]×C[k] - a[k-1]×C[k-1]) / Δz\nWave Potential Energy (WPE): WPE = Σₖ (0.5/(ρ₂×a_ell)) × kh² × (|CRₖ|² + |CIₖ|²)\nwhere C = ∂A/∂z and a_ell = f²/N². This represents the potential energy from vertical wave structure.\nWave Correction Energy (WCE): WCE = Σₖ (1/8) × (1/a_ell²) × kh⁴ × (|ARₖ|² + |AIₖ|²)\nHigher-order correction term from the YBJ+ formulation.\n\nAlgorithm\n\nLoop over all spectral modes with dealiasing mask L\nCompute LA = ∂_z(a×C) using finite differences for each (i,j) mode\nAccumulate |LA|², kh²|C|²/(ρ₂×aell), kh⁴|A|²/(8×aell²)\nApply dealiasing correction: subtract half the kh=0 mode from WKE\nIntegrate over z (sum local, divide by nz)\n\nArguments\n\nBR, BI: Real and imaginary parts of wave envelope B (spectral)\nAR, AI: Real and imaginary parts of wave amplitude A (spectral)\nCR, CI: Real and imaginary parts of C = ∂A/∂z (spectral)\nG::Grid: Grid structure\npar: QGParams (for f0, N2)\nLmask: Optional dealiasing mask\n\nReturns\n\nTuple (WKE, WPE, WCE) of wave energy components, normalized by nz.\n\nFortran Correspondence\n\nMatches wave_energy subroutine in diagnostics.f90 (lines 647-743).\n\nNote\n\nIn MPI mode, returns LOCAL energy. Use mpireducesum for global totals.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.flow_kinetic_energy_global","page":"Physics Functions","title":"QGYBJplus.Diagnostics.flow_kinetic_energy_global","text":"flow_kinetic_energy_global(u, v, mpi_config=nothing) -> KE\n\nCompute GLOBAL domain-integrated kinetic energy across all MPI processes.\n\nArguments\n\nu, v: Velocity arrays (local portion in MPI mode)\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nGlobal kinetic energy (sum across all processes).\n\nExample\n\n# Serial mode\nKE = flow_kinetic_energy_global(state.u, state.v)\n\n# MPI mode\nKE = flow_kinetic_energy_global(state.u, state.v, mpi_config)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.wave_energy_global","page":"Physics Functions","title":"QGYBJplus.Diagnostics.wave_energy_global","text":"wave_energy_global(B, A, mpi_config=nothing) -> (E_B, E_A)\n\nCompute GLOBAL wave energy across all MPI processes.\n\nArguments\n\nB, A: Wave envelope and amplitude arrays (local portion in MPI mode)\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nTuple (EB, EA) of global summed squared magnitudes.\n\nExample\n\n# Serial mode\nEB, EA = wave_energy_global(state.B, state.A)\n\n# MPI mode\nEB, EA = wave_energy_global(state.B, state.A, mpi_config)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.flow_kinetic_energy_spectral_global","page":"Physics Functions","title":"QGYBJplus.Diagnostics.flow_kinetic_energy_spectral_global","text":"flow_kinetic_energy_spectral_global(uk, vk, G, par; Lmask=nothing, mpi_config=nothing) -> KE\n\nCompute GLOBAL kinetic energy in spectral space across all MPI processes.\n\nArguments\n\nuk, vk: Spectral velocity fields (local portion in MPI mode)\nG::Grid: Grid structure\npar: QGParams\nLmask: Optional dealiasing mask\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nGlobal kinetic energy with dealiasing and density weighting.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.flow_potential_energy_spectral_global","page":"Physics Functions","title":"QGYBJplus.Diagnostics.flow_potential_energy_spectral_global","text":"flow_potential_energy_spectral_global(bk, G, par; Lmask=nothing, mpi_config=nothing) -> PE\n\nCompute GLOBAL potential energy in spectral space across all MPI processes.\n\nArguments\n\nbk: Spectral buoyancy field (local portion in MPI mode)\nG::Grid: Grid structure\npar: QGParams\nLmask: Optional dealiasing mask\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nGlobal potential energy with dealiasing and density weighting.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.wave_energy_spectral_global","page":"Physics Functions","title":"QGYBJplus.Diagnostics.wave_energy_spectral_global","text":"wave_energy_spectral_global(BR, BI, AR, AI, CR, CI, G, par; Lmask=nothing, mpi_config=nothing) -> (WKE, WPE, WCE)\n\nCompute GLOBAL wave energies in spectral space across all MPI processes.\n\nArguments\n\nBR, BI, AR, AI, CR, CI: Spectral wave fields (local portions in MPI mode)\nG::Grid: Grid structure\npar: QGParams\nLmask: Optional dealiasing mask\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nTuple (WKE, WPE, WCE) of global wave energy components.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.EnergyDiagnostics.EnergyDiagnosticsManager","page":"Physics Functions","title":"QGYBJplus.EnergyDiagnostics.EnergyDiagnosticsManager","text":"EnergyDiagnosticsManager\n\nManages separate energy diagnostic output files.\n\n\n\n\n\n","category":"type"},{"location":"api/physics/#QGYBJplus.EnergyDiagnostics.record_energies!","page":"Physics Functions","title":"QGYBJplus.EnergyDiagnostics.record_energies!","text":"record_energies!(manager, time, wave_KE, wave_PE, wave_CE, mean_flow_KE, mean_flow_PE)\n\nRecord energy values to the internal time series.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.EnergyDiagnostics.write_all_energy_files!","page":"Physics Functions","title":"QGYBJplus.EnergyDiagnostics.write_all_energy_files!","text":"write_all_energy_files!(manager::EnergyDiagnosticsManager)\n\nWrite all energy time series to their respective files.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Diagnostics.omega_eqn_rhs!","page":"Physics Functions","title":"QGYBJplus.Diagnostics.omega_eqn_rhs!","text":"omega_eqn_rhs!(rhs, psi, G, plans; Lmask=nothing, workspace=nothing)\n\nCompute the RHS forcing for the QG omega equation.\n\nPhysical Background\n\nThe QG omega equation relates vertical velocity w to the horizontal flow:\n\nN² ∇²w + f² ∂²w/∂z² = 2f J(ψ_z, ∇²ψ)\n\nor equivalently (dividing by N²):\n\n∇²w + (f²/N²) ∂²w/∂z² = (2f/N²) J(ψ_z, ∇²ψ)\n\nThis function computes 2 J(ψ_z, ∇²ψ). The solver then applies the (f/N²) scaling.\n\nPhysical Interpretation\n\nThe Jacobian J(ψ_z, ∇²ψ) represents:\n\nψ_z: Vertical shear of streamfunction (related to thermal wind/buoyancy)\n∇²ψ: Relative vorticity ζ\nJ: Cross-gradient interaction\n\nStrong RHS forcing occurs where:\n\nFronts (large ψ_z) interact with vorticity gradients\nEddies tilt isopycnals through differential advection\n\nNumerical Method\n\nVertical derivative: ψ_z via forward finite difference\nψ_z[k] = (ψ[k+1] - ψ[k]) / dz,  ψ_z[nz] = 0 (Neumann)\nSpectral derivatives:\n∂ψz/∂x = i kₓ ψz\n∂ψz/∂y = i kᵧ ψz\n∂(∇²ψ)/∂x = -i kₓ kh² ψ_avg\n∂(∇²ψ)/∂y = -i kᵧ kh² ψ_avg\nwhere ψ_avg = (ψ[k+1] + ψ[k])/2 for staggered-grid consistency\nJacobian in physical space:\nJ(ψ_z, ∇²ψ) = (∂ψ_z/∂x)(∂∇²ψ/∂y) - (∂ψ_z/∂y)(∂∇²ψ/∂x)\nTransform back: FFT to get spectral RHS\n\nArguments\n\nrhs::Array{Complex,3}: Output RHS array (modified in-place)\npsi::Array{Complex,3}: Spectral streamfunction\nG::Grid: Grid structure\nplans: FFT plans\nLmask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nReturns\n\nModified rhs array with the omega equation forcing.\n\nFortran Correspondence\n\nMatches omega_eqn_rhs computation in the Fortran implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Transforms.fft_forward!","page":"Physics Functions","title":"QGYBJplus.Transforms.fft_forward!","text":"fft_forward!(dst, src, P::Plans)\n\nCompute horizontal forward FFT (complex-to-complex) for each z-plane.\n\nAlgorithm\n\nSerial FFTW backend: Loops over z-slices and applies 2D FFT to each (x,y) plane.\n\nArguments\n\ndst: Destination array (spectral space)\nsrc: Source array (physical space)\nP::Plans: FFT plans\n\nReturns\n\nModified dst array.\n\nNote\n\nFor parallel execution with PencilArrays, the MPI support provides a separate fft_forward!(dst::PencilArray, src::PencilArray, plans::MPIPlans) method that handles distributed transforms automatically.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.Transforms.fft_backward!","page":"Physics Functions","title":"QGYBJplus.Transforms.fft_backward!","text":"fft_backward!(dst, src, P::Plans)\n\nCompute horizontal inverse FFT (complex-to-complex) for each z-plane.\n\nAlgorithm\n\nSerial FFTW backend: Loops over z-slices and applies 2D inverse FFT to each (x,y) plane. FFTW.ifft is NORMALIZED (divides by N automatically).\n\nArguments\n\ndst: Destination array (physical space, normalized)\nsrc: Source array (spectral space)\nP::Plans: FFT plans\n\nReturns\n\nModified dst array.\n\nNote\n\nFor parallel execution with PencilArrays, the MPI support provides a separate fft_backward!(dst::PencilArray, src::PencilArray, plans::MPIPlans) method that uses ldiv! for normalized inverse transforms.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.dealias_mask","page":"Physics Functions","title":"QGYBJplus.dealias_mask","text":"dealias_mask(G) -> Matrix{Bool}\n\nCompute the 2/3-rule dealiasing mask for spectral space.\n\nPhysical Background\n\nIn pseudo-spectral methods, nonlinear terms are computed by:\n\nTransform fields to physical space (inverse FFT)\nCompute products in physical space\nTransform back to spectral space (forward FFT)\n\nThe problem: A product of two fields with max wavenumber kmax produces wavenumbers up to 2×kmax. With finite resolution, these high-k components \"fold back\" (alias) onto resolved wavenumbers, causing errors.\n\nThe 2/3 Rule\n\nTo prevent aliasing from quadratic nonlinearities (e.g., u·∇q):\n\nKeep only wavenumbers |k| ≤ (2/3) × k_Nyquist\nTruncated modes: set to zero before computing nonlinear products\nResult: product wavenumbers stay within (2/3)×2 = (4/3) < k_Nyquist\n\nThis rule is exact for quadratic nonlinearities in 1D. For 2D with radial cutoff, it provides effective dealiasing.\n\nAlgorithm\n\nUses radial (isotropic) cutoff:\n\nk_max = min(nx, ny) / 3\nKeep mode (i,j) if sqrt(kx² + ky²) ≤ k_max\nMore isotropic than rectangular truncation\n\nArguments\n\nG::Grid: Grid with dimensions nx, ny\n\nReturns\n\nMatrix{Bool} of size (nx, ny):\n\ntrue = keep this wavenumber\nfalse = truncate (set to zero)\n\nUsage\n\nmask = dealias_mask(G)\nq_hat .*= mask  # Zero out aliased modes\n\nFortran Correspondence\n\nMatches LL(i,j) mask in the Fortran implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.compute_hyperdiff_coeff","page":"Physics Functions","title":"QGYBJplus.compute_hyperdiff_coeff","text":"compute_hyperdiff_coeff(; dx, dy, dt, order=4, efold_steps=10, kmax_fraction=1.0)\n\nCompute hyperdiffusion coefficient for given grid spacing and desired damping rate.\n\nMathematical Background\n\nThe n-th order hyperdiffusion operator is:     -νn ∇^n q = -νn (kₓ² + kᵧ²)^(n/2) q̂  in spectral space\n\nThe damping rate at wavenumber k is: λ = ν_n × k^n\n\nFor the grid scale (kmax = π/Δx), we want the amplitude to decay by factor e^(-1) after `efoldsteps` time steps, giving:     νn = 1 / (efoldsteps × dt × k_max^n)\n\nArguments\n\ndx, dy: Grid spacing in x and y [m]\ndt: Time step [s]\norder: Order of hyperdiffusion (4 = biharmonic, 6 = hyper-6, etc.)\nefold_steps: Number of time steps for e-folding at grid scale (default: 10)\nkmax_fraction: Fraction of Nyquist wavenumber to target (default: 1.0)\n\nReturns\n\nHyperdiffusion coefficient ν_n with units [m^n / s]\n\nExample\n\n# For 4th order (biharmonic) hyperdiffusion on a 1km grid with dt=10s\nν₄ = compute_hyperdiff_coeff(dx=1e3, dy=1e3, dt=10.0, order=4, efold_steps=5)\n\n# Use in default_params\npar = default_params(nx=128, ny=128, nz=64, Lx=128e3, Ly=128e3, Lz=3000.0,\n                     dt=10.0, nt=1000,\n                     νₕ₁=ν₄, νₕ₂=0.0, ilap1=2, ilap2=2)  # Pure 4th order\n\nNotes\n\nSmaller efold_steps → stronger damping (more dissipative)\nLarger efold_steps → weaker damping (less dissipative)\nFor stability, typically use efold_steps ∈ [5, 20]\nThe 4th order (biharmonic) is most common: order=4, ilap1=2\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.compute_hyperdiff_params","page":"Physics Functions","title":"QGYBJplus.compute_hyperdiff_params","text":"compute_hyperdiff_params(; nx, ny, Lx, Ly, dt, order=4, efold_steps=10)\n\nConvenience function to compute hyperdiffusion coefficient from grid parameters.\n\nArguments\n\nnx, ny: Grid points in x and y\nLx, Ly: Domain size in x and y [m]\ndt: Time step [s]\norder: Order of hyperdiffusion (4 = biharmonic, default)\nefold_steps: E-folding time in steps (default: 10)\n\nReturns\n\nNamed tuple (ν₄=..., ilap=...) for use with default_params\n\nExample\n\n# Compute 4th order hyperdiffusion for Asselin example\nhd = compute_hyperdiff_params(nx=128, ny=128, Lx=70e3, Ly=70e3, dt=10.0, efold_steps=5)\n\npar = default_params(nx=128, ny=128, nz=64, Lx=70e3, Ly=70e3, Lz=3000.0,\n                     dt=10.0, nt=1000,\n                     νₕ₁=hd.ν, νₕ₂=0.0, ilap1=hd.ilap, ilap2=2)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.YBJNormal.sumB!","page":"Physics Functions","title":"QGYBJplus.YBJNormal.sumB!","text":"sumB!(B, G; Lmask=nothing, workspace=nothing)\n\nRemove the vertical mean from the wave envelope B at each horizontal wavenumber.\n\nPhysical Background\n\nIn the normal YBJ formulation, the wave envelope B is related to amplitude A by:\n\nB = (∂²A/∂z²) / N²\n\nSince ∂²A/∂z² must integrate to zero (boundary conditions), B should have zero vertical mean. This function enforces that constraint.\n\nAlgorithm\n\nFor each horizontal wavenumber (kₓ, kᵧ) within the dealiasing mask:\n\nCompute vertical mean: B̄(kₓ,kᵧ) = (1/nz) Σₖ B(kₓ,kᵧ,k)\nSubtract mean: B(kₓ,kᵧ,k) ← B(kₓ,kᵧ,k) - B̄\n\nFor wavenumbers outside the mask or kh² = 0, set B = 0.\n\nArguments\n\nB::Array{Complex,3}: Wave envelope (modified in-place)\nG::Grid: Grid structure with wavenumbers\nLmask: Optional dealiasing mask (default: all modes kept)\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nReturns\n\nModified B array with zero vertical mean at each (kₓ, kᵧ).\n\nFortran Correspondence\n\nMatches sumB in derivatives.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.YBJNormal.compute_sigma","page":"Physics Functions","title":"QGYBJplus.YBJNormal.compute_sigma","text":"compute_sigma(par, G, nBRk, nBIk, rBRk, rBIk; Lmask=nothing, workspace=nothing, N2_profile=nothing) -> sigma\n\nCompute the sigma constraint for normal YBJ A recovery.\n\nPhysical Background\n\nWhen recovering A from B via vertical integration, we need to determine the vertical mean of A. The sigma parameter provides this constraint from the nonlinear forcing terms.\n\nMathematical Formula\n\nFor each horizontal wavenumber (kₓ, kᵧ):\n\nσ(kₓ,kᵧ) = Σₖ [(rBRk + 2·nBIk)/kh² + i(rBIk - 2·nBRk)/kh²]\n\nwhere:\n\nnBRk, nBIk: Real and imaginary parts of nonlinear advection term\nrBRk, rBIk: Real and imaginary parts of refraction term\nkh² = kₓ² + kᵧ²\n\nArguments\n\npar::QGParams: Model parameters\nG::Grid: Grid with wavenumbers\nnBRk, nBIk: Real/imaginary parts of advection forcing\nrBRk, rBIk: Real/imaginary parts of refraction forcing\nLmask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\nN2_profile: Optional N²(z) profile for consistent stratification physics. If not provided, uses N2_ut(par, G) based on par.stratification.\n\nReturns\n\n2D complex array sigma(nxlocal, nylocal) with the constraint values.\n\nFortran Correspondence\n\nMatches compute_sigma in derivatives.f90.\n\nNote\n\nIn MPI mode with 2D decomposition, this requires z to be fully local. Transpose operations are handled internally if needed.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJplus.YBJNormal.compute_A!","page":"Physics Functions","title":"QGYBJplus.YBJNormal.compute_A!","text":"compute_A!(A, C, BRk, BIk, sigma, par, G; Lmask=nothing, workspace=nothing, N2_profile=nothing)\n\nRecover wave amplitude A from envelope B using normal YBJ vertical integration.\n\nPhysical Background\n\nIn normal YBJ, B and A are related by:\n\nB = (∂²A/∂z²) / N²\n\nTo recover A from B, we integrate twice using the N² weight:\n\nFirst integral: ∂A/∂z = ∫ B · N² dz + c₁\nSecond integral: A = ∫∫ B · N² dz² + c₁z + c₂\n\nThe constants are determined by:\n\nBoundary condition: ∂A/∂z = 0 at top (Neumann)\nMean constraint: ∫A dz = σ (from sigma)\n\nAlgorithm\n\nFor each horizontal wavenumber (kₓ, kᵧ):\n\nStage 1: Cumulative Integration\n\nÃ[1] = 0\nÃ[k] = Ã[k-1] + (Σⱼ₌₁ᵏ⁻¹ B[j]) × N²[k-1] × dz²\n\nStage 2: Apply Sigma Constraint\n\nsumA = Σₖ Ã[k]\nadj = (σ - sumA) / nz\nA[k] = Ã[k] + adj   # Enforce ∫A = σ\n\nStage 3: Compute Vertical Derivative\n\nC[k] = (A[k+1] - A[k]) / dz   # Forward difference\nC[nz] = 0                      # Neumann BC at top\n\nArguments\n\nA::Array{Complex,3}: Output wave amplitude (modified in-place)\nC::Array{Complex,3}: Output vertical derivative A_z (modified in-place)\nBRk, BIk: Real/imaginary parts of wave envelope B\nsigma::Array{Complex,2}: Sigma constraint from compute_sigma\npar::QGParams: Model parameters\nG::Grid: Grid structure\nLmask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\nN2_profile: Optional N²(z) profile for variable stratification. If not provided, uses N2_ut(par, G).\n\nReturns\n\nTuple (A, C) with recovered amplitude and its vertical derivative.\n\nFortran Correspondence\n\nMatches compute_A in derivatives.f90.\n\nNote\n\nThis is the NORMAL YBJ recovery method. For YBJ+, use invert_B_to_A! instead, which solves the full L⁺A = B elliptic problem via tridiagonal solve.\n\n\n\n\n\n","category":"function"},{"location":"#QGYBJ.jl","page":"Home","title":"QGYBJ+.jl","text":"<div class=\"hero-section\">\n<h1>QGYBJ+.jl</h1>\n<p>A high-performance Julia model for simulating wave-eddy interactions in the ocean</p>\n</div>\n\nQGYBJ+.jl implements the Quasi-Geostrophic Young-Ben Jelloul Plus (QG-YBJ+) model for simulating the interaction between near-inertial waves and mesoscale ocean eddies.\n\n","category":"section"},{"location":"#Start-Here","page":"Home","title":"Start Here","text":"<div class=\"learning-path\">\n<div class=\"path-step\">\n    <div class=\"step-number\">1</div>\n    <div class=\"step-content\">\n        <strong><a href=\"concepts/\">Key Concepts</a></strong> — Understand what the model simulates and why it matters\n    </div>\n    <div class=\"step-time\">15 min</div>\n</div>\n<div class=\"path-step\">\n    <div class=\"step-number\">2</div>\n    <div class=\"step-content\">\n        <strong><a href=\"quickstart/\">Quick Start</a></strong> — Run your first simulation with copy-paste code\n    </div>\n    <div class=\"step-time\">5 min</div>\n</div>\n<div class=\"path-step\">\n    <div class=\"step-number\">3</div>\n    <div class=\"step-content\">\n        <strong><a href=\"worked_example/\">Worked Example</a></strong> — Build a real simulation step-by-step\n    </div>\n    <div class=\"step-time\">30 min</div>\n</div>\n</div>\n\n","category":"section"},{"location":"#What-This-Model-Does","page":"Home","title":"What This Model Does","text":"The ocean contains two important types of motion at different scales:\n\nMesoscale Eddies (~100 km scale)\n\nGiant rotating vortices lasting weeks to months\nContain ~90% of ocean kinetic energy\nMove slowly (~10 cm/s)\n\nNear-Inertial Waves (~10 km scale)\n\nWind-generated internal waves oscillating every ~17 hours\nKey driver of ocean mixing\nPropagate through the water column\n\nThese two types of motion interact strongly: eddies refract and focus waves, while waves can feed energy back into the mean flow. QGYBJ+.jl simulates this coupled system using:\n\nQuasi-geostrophic (QG) dynamics for the balanced eddy flow\nYBJ+ equations for the near-inertial wave envelope\nTwo-way coupling capturing wave-mean flow energy exchange\n\n","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"<div class=\"feature-grid\">\n<div class=\"feature-card\">\n    <h3>Spectral Methods</h3>\n    <p>Pseudo-spectral horizontal derivatives using FFTW for accuracy and speed</p>\n</div>\n<div class=\"feature-card\">\n    <h3>Flexible Time Stepping</h3>\n    <p>Choose Leapfrog (explicit) or IMEX-CN for 10x larger timesteps with waves</p>\n</div>\n<div class=\"feature-card\">\n    <h3>MPI Parallel</h3>\n    <p>2D pencil decomposition scales to thousands of cores for large domains</p>\n</div>\n<div class=\"feature-card\">\n    <h3>Particle Tracking</h3>\n    <p>Lagrangian advection with multiple interpolation schemes</p>\n</div>\n<div class=\"feature-card\">\n    <h3>Configurable Physics</h3>\n    <p>Flexible stratification profiles, dissipation, and wave feedback options</p>\n</div>\n<div class=\"feature-card\">\n    <h3>NetCDF Output</h3>\n    <p>Standard format for analysis with automatic energy diagnostics</p>\n</div>\n</div>\n\n","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"<div class=\"quickstart-card\">\n\nusing QGYBJplus\n\n# Create configuration (domain size is REQUIRED)\nconfig = create_simple_config(\n    Lx = 500e3, Ly = 500e3, Lz = 4000.0,  # 500km × 500km × 4km\n    nx = 64, ny = 64, nz = 32,\n    dt = 0.001, total_time = 1.0\n)\n\n# Run simulation\nresult = run_simple_simulation(config)\n\n# Check energy\nprintln(\"Kinetic Energy: \", flow_kinetic_energy(result.state.u, result.state.v))\n\n</div>\n\n","category":"section"},{"location":"#Documentation-Guide","page":"Home","title":"Documentation Guide","text":"","category":"section"},{"location":"#For-Beginners","page":"Home","title":"For Beginners","text":"Key Concepts — Core ideas without code\nInstallation — How to install QGYBJ+.jl\nQuick Start — Your first simulation in 5 minutes\nWorked Example — Detailed walkthrough with explanations","category":"section"},{"location":"#Physics-and-Theory","page":"Home","title":"Physics & Theory","text":"Model Overview — Physical background and equations\nQG Equations — Quasi-geostrophic dynamics\nYBJ+ Wave Model — Near-inertial wave formulation\nNumerical Methods — Algorithms and discretization","category":"section"},{"location":"#User-Guide","page":"Home","title":"User Guide","text":"Configuration — Setting up simulations\nStratification — Ocean density profiles\nI/O and Output — Saving and loading data\nDiagnostics — Energy and analysis tools","category":"section"},{"location":"#Advanced-Topics","page":"Home","title":"Advanced Topics","text":"MPI Parallelization — Running on clusters\nParticle Advection — Lagrangian tracking\nPerformance Tips — Optimization strategies","category":"section"},{"location":"#Reference","page":"Home","title":"Reference","text":"Core Types — QGParams, Grid, State\nPhysics Functions — Operators and solvers\nFull Index — Complete function listing\n\n","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/subhk/QGYBJplus.jl\")\n\nMPI parallel support (MPI.jl, PencilArrays.jl, PencilFFTs.jl) is included as a dependency and will be installed automatically.\n\nSee Installation Guide for detailed instructions.\n\n","category":"section"},{"location":"#How-Simulations-Work","page":"Home","title":"How Simulations Work","text":"The typical simulation workflow is:\n\nConfigure — Create QGParams with grid size, domain, physics options\nSetup — Initialize Grid, State, FFT plans, and elliptic coefficients\nRun — Time-step the prognostic fields (q, B) with inversions each step\nOutput — Save fields and diagnostics to NetCDF files\n\nSee Worked Example for a complete walkthrough.\n\n","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use QGYBJ+.jl in your research, please cite:\n\n@software{qgybj_jl,\n  author = {Kar, Subhajit},\n  title = {QGYBJ+.jl: A Julia Implementation of the QG-YBJ+ Model},\n  year = {2025},\n  url = {https://github.com/subhk/QGYBJplus.jl}\n}","category":"section"},{"location":"#Key-References","page":"Home","title":"Key References","text":"Asselin & Young (2019): YBJ+ formulation for penetration of near-inertial waves\nXie & Vanneste (2015): Wave feedback mechanism (qʷ term)\nYoung & Ben Jelloul (1997): Original YBJ wave envelope equation","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"Issues: GitHub Issues\nDiscussions: GitHub Discussions","category":"section"},{"location":"#License","page":"Home","title":"License","text":"QGYBJ+.jl is released under the MIT License.","category":"section"},{"location":"worked_example/#worked_example","page":"Worked Example","title":"Worked Example","text":"This comprehensive tutorial builds a complete QG-YBJ+ simulation from scratch. We'll explain every step so you understand what's happening and why.\n\nTime required: ~30 minutes\n\nWhat you'll build: A simulation of near-inertial waves interacting with ocean eddies, including:\n\nDipole vortex (anticyclone + cyclone pair)\nSurface-trapped wave initial condition\nWave refraction and energy diagnostics\nNetCDF output for visualization\n\n","category":"section"},{"location":"worked_example/#Overview","page":"Worked Example","title":"Overview","text":"We'll simulate a 500km × 500km × 4km ocean domain with:\n\nA dipole vortex (cyclone + anticyclone pair)\nSurface-trapped near-inertial waves\n5 inertial periods of evolution\n\nThe waves will refract toward the anticyclone, demonstrating the key wave-trapping phenomenon.\n\n","category":"section"},{"location":"worked_example/#Step-1:-Load-Packages-and-Set-Parameters","page":"Worked Example","title":"Step 1: Load Packages and Set Parameters","text":"using QGYBJplus\nusing Printf\n\n# ============================================================================\n#                       PHYSICAL PARAMETERS\n# ============================================================================\n\n# Domain size (realistic ocean values)\nconst Lx = 500e3    # 500 km horizontal extent\nconst Ly = 500e3    # 500 km horizontal extent\nconst Lz = 4000.0   # 4 km depth\n\n# Grid resolution\nconst nx = 128      # Grid points in x\nconst ny = 128      # Grid points in y\nconst nz = 64       # Grid points in z (vertical levels)\n\n# Physical constants\nconst f₀ = 1e-4     # Coriolis parameter [s⁻¹] (mid-latitude value)\nconst N² = 1e-5     # Buoyancy frequency squared [s⁻²]\n\n# Time stepping\nconst T_inertial = 2π / f₀           # Inertial period ≈ 17.5 hours\nconst dt = 10.0                       # Time step [s] - use IMEX for larger dt\nconst n_inertial_periods = 5          # Simulation duration\nconst nt = round(Int, n_inertial_periods * T_inertial / dt)\n\nprintln(\"Simulation setup:\")\nprintln(\"  Domain: $(Lx/1e3) km × $(Ly/1e3) km × $(Lz/1e3) km\")\nprintln(\"  Grid: $nx × $ny × $nz\")\nprintln(\"  Inertial period: $(T_inertial/3600) hours\")\nprintln(\"  Time steps: $nt ($(n_inertial_periods) inertial periods)\")\n\nWhat's happening?\n\nf₀ = 1e-4 s⁻¹ is the Coriolis parameter at ~45° latitude\nN² = 1e-5 s⁻² gives N ≈ 0.003 s⁻¹, typical for the ocean interior\nThe inertial period is 2π/f₀ ≈ 17.5 hours\n\n","category":"section"},{"location":"worked_example/#Step-2:-Create-Parameters-and-Initialize","page":"Worked Example","title":"Step 2: Create Parameters and Initialize","text":"# ============================================================================\n#                       CREATE MODEL PARAMETERS\n# ============================================================================\n\n# Note: Lx, Ly, Lz are REQUIRED - there are no defaults\npar = default_params(\n    # Grid dimensions\n    nx = nx, ny = ny, nz = nz,\n\n    # Domain size [meters]\n    Lx = Lx, Ly = Ly, Lz = Lz,\n\n    # Physics\n    f₀ = f₀,\n    N² = N²,\n    ybj_plus = true,       # Use YBJ+ formulation (includes k² correction)\n\n    # Time stepping\n    dt = dt,\n    nt = nt,\n\n    # Coupling options\n    no_wave_feedback = true,  # Disable wave feedback (qʷ) for clarity\n    fixed_flow = false,        # Let mean flow evolve\n\n    # Dissipation (hyperdiffusion)\n    νₕ₁ = 1e8,    # Biharmonic viscosity [m⁴/s]\n    ilap1 = 2,    # 4th order (∇⁴)\n)\n\nprintln(\"\\nParameters created:\")\nprintln(\"  f₀ = $(par.f₀)\")\nprintln(\"  N² = $(par.N²)\")\nprintln(\"  dt = $(par.dt) s\")\nprintln(\"  ybj_plus = $(par.ybj_plus)\")\n\nKey parameters explained:\n\nParameter Value Meaning\nybj_plus=true Use full YBJ+ Includes k²/4 correction in L⁺ operator\nno_wave_feedback=true One-way coupling Waves don't affect mean flow (simpler)\nνₕ₁, ilap1 Biharmonic Scale-selective dissipation at grid scale\n\n","category":"section"},{"location":"worked_example/#Step-3:-Setup-Grid,-State,-and-FFT-Plans","page":"Worked Example","title":"Step 3: Setup Grid, State, and FFT Plans","text":"# ============================================================================\n#                       INITIALIZE SIMULATION\n# ============================================================================\n\n# setup_model returns: Grid, State, FFT plans, elliptic coefficient\nG, S, plans, a_ell = setup_model(par)\n\n# Get dealiasing mask (2/3 rule)\nL = dealias_mask(G)\n\nprintln(\"\\nGrid initialized:\")\nprintln(\"  x range: [$(G.x[1]/1e3), $(G.x[end]/1e3)] km\")\nprintln(\"  z range: [$(G.z[1]/1e3), $(G.z[end]/1e3)] km\")\nprintln(\"  dx = $(G.dx/1e3) km, dz = $(G.dz[1]) m\")\n\nWhat did setup_model create?\n\nG (Grid): x, y, z coordinates; kx, ky wavenumbers; kh² for each mode; dx, dy, dz spacings\nS (State): q, B (prognostic, spectral); psi, A, C (diagnostic, spectral); u, v, w (velocities, real space)\nplans: FFTW plans for efficient transforms\na_ell: Coefficient array for elliptic inversions: a(z) = f₀²/N²(z)\n\n","category":"section"},{"location":"worked_example/#Step-4:-Set-Up-Initial-Conditions","page":"Worked Example","title":"Step 4: Set Up Initial Conditions","text":"","category":"section"},{"location":"worked_example/#4a:-Create-a-Dipole-Vortex","page":"Worked Example","title":"4a: Create a Dipole Vortex","text":"# ============================================================================\n#                       DIPOLE INITIAL CONDITION\n# ============================================================================\n\n# Dipole parameters\nU0 = 0.3           # Maximum velocity [m/s]\nR0 = 50e3          # Vortex radius [m]\nseparation = 150e3 # Distance between vortex centers [m]\n\n# Dipole centers (relative to domain center)\nx_center = Lx / 2\ny_center = Ly / 2\nx_pos = x_center + separation / 2   # Anticyclone (positive ψ)\nx_neg = x_center - separation / 2   # Cyclone (negative ψ)\n\n# Build streamfunction in physical space\npsi_phys = zeros(nz, nx, ny)\n\nfor k in 1:nz, j in 1:ny, i in 1:nx\n    x = G.x[i]\n    y = G.y[j]\n\n    # Distance from each vortex center\n    r_pos = sqrt((x - x_pos)^2 + (y - y_center)^2)\n    r_neg = sqrt((x - x_neg)^2 + (y - y_center)^2)\n\n    # Gaussian vortices\n    psi_anticyclone = +U0 * R0 * exp(-(r_pos/R0)^2)  # Positive ψ = anticyclone\n    psi_cyclone     = -U0 * R0 * exp(-(r_neg/R0)^2)  # Negative ψ = cyclone\n\n    psi_phys[k, i, j] = psi_anticyclone + psi_cyclone\nend\n\n# Transform to spectral space\npsi_spectral = zeros(ComplexF64, nz, nx, ny)\nfor k in 1:nz\n    psi_spectral[k, :, :] = fft(psi_phys[k, :, :])\nend\nS.psi .= psi_spectral\n\n# Compute q from ψ: q = ∇²ψ + (f²/N²)∂²ψ/∂z²\ncompute_q_from_psi!(S, G, par)\n\nprintln(\"\\nDipole vortex created:\")\nprintln(\"  Max velocity: $U0 m/s\")\nprintln(\"  Vortex radius: $(R0/1e3) km\")\nprintln(\"  Separation: $(separation/1e3) km\")\n\nPhysical meaning:\n\nAnticyclone (positive ψ): Clockwise rotation, traps waves\nCyclone (negative ψ): Counter-clockwise rotation, expels waves","category":"section"},{"location":"worked_example/#4b:-Create-Surface-Wave-Initial-Condition","page":"Worked Example","title":"4b: Create Surface Wave Initial Condition","text":"# ============================================================================\n#                       WAVE INITIAL CONDITION\n# ============================================================================\n\n# Horizontally uniform, surface-trapped wave\nA0 = 0.1           # Wave amplitude [m/s]\ndecay_depth = 100.0  # e-folding depth [m]\n\n# Build wave amplitude in physical space\nA_phys = zeros(ComplexF64, nz, nx, ny)\n\nfor k in 1:nz\n    z = G.z[k]                              # z runs from -Lz to 0\n    depth = -z                              # Depth from surface (positive)\n    vertical_structure = exp(-depth / decay_depth)\n    A_phys[k, :, :] .= A0 * vertical_structure  # Uniform horizontally\nend\n\n# Transform to spectral space\nA_spectral = zeros(ComplexF64, nz, nx, ny)\nfor k in 1:nz\n    A_spectral[k, :, :] = fft(A_phys[k, :, :])\nend\nS.A .= A_spectral\n\n# Compute B from A using L⁺ operator\n# B = L⁺(A) = ∂/∂z[(f²/N²)∂A/∂z] - (k²/4)A\n# For uniform A in x,y, this simplifies significantly\n# Here we just set B = A as initial approximation (refined by inversion)\nS.B .= S.A\n\nprintln(\"\\nWave field created:\")\nprintln(\"  Amplitude: $A0 m/s\")\nprintln(\"  Decay depth: $decay_depth m\")\nprintln(\"  Vertical structure: exp(-z/$decay_depth)\")\n\nThis mimics wind-generated near-inertial waves that are strongest near the surface and decay with depth.\n\n","category":"section"},{"location":"worked_example/#Step-5:-Run-the-Time-Stepping-Loop","page":"Worked Example","title":"Step 5: Run the Time-Stepping Loop","text":"# ============================================================================\n#                       TIME INTEGRATION\n# ============================================================================\n\n# Create state arrays for leapfrog (need 3 time levels)\nSnm1 = copy_state(S)  # n-1\nSn = copy_state(S)    # n\nSnp1 = copy_state(S)  # n+1\n\n# Initialize with projection step (Forward Euler)\nprintln(\"\\nRunning projection step...\")\nfirst_projection_step!(Sn, G, par, plans; a=a_ell, dealias_mask=L)\ncopy_state!(Snm1, Sn)\n\n# Storage for diagnostics\ntimes = Float64[]\nwave_energies = Float64[]\nflow_energies = Float64[]\n\n# Diagnostic output interval (every 0.5 inertial periods)\ndiag_interval = round(Int, 0.5 * T_inertial / dt)\n\nprintln(\"Starting main time loop...\")\nprintln(\"=\"^60)\n\nfor step in 1:nt\n    # Leapfrog step with Robert-Asselin filter\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans;\n                   a=a_ell, dealias_mask=L)\n\n    # Rotate time levels (efficient pointer swap)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\n\n    # Periodic diagnostics\n    if step % diag_interval == 0\n        current_time = step * dt\n        time_IP = current_time / T_inertial  # Time in inertial periods\n\n        # Compute energies\n        KE = flow_kinetic_energy(Sn.u, Sn.v)\n        # Wave kinetic energy per YBJ+ equation (4.7): WKE = (1/2)|LA|²\n        WKE, WPE, WCE = compute_detailed_wave_energy(Sn, G, par)\n\n        # Store for later analysis\n        push!(times, time_IP)\n        push!(wave_energies, WKE)\n        push!(flow_energies, KE)\n\n        @printf(\"  t = %.2f IP | Flow KE = %.4e | Wave KE = %.4e\\n\",\n                time_IP, KE, WKE)\n    end\nend\n\nprintln(\"=\"^60)\nprintln(\"Simulation complete!\")\n\nWhat happens each time step?\n\nInvert q → ψ and B → A\nCompute u, v from ψ\nEvaluate tendencies: J(ψ,q), J(ψ,B), refraction ζ·B, dispersion k²A\nUpdate: φ^{n+1} = φ^{n-1} + 2·dt·F^n\nRotate time levels: Snm1 ← Sn ← Snp1\n\n","category":"section"},{"location":"worked_example/#Step-6:-Analyze-Results","page":"Worked Example","title":"Step 6: Analyze Results","text":"# ============================================================================\n#                       ANALYZE RESULTS\n# ============================================================================\n\n# Get final fields\nfinal_psi = Sn.psi\nfinal_B = Sn.B\nfinal_A = Sn.A\n\n# Compute final vorticity ζ = ∇²ψ\n# In spectral space: ζ̂ = -k²·ψ̂\nzeta_spectral = zeros(ComplexF64, nz, nx, ny)\nfor k in 1:nz, j in 1:ny, i in 1:nx\n    kh2 = G.kx[i]^2 + G.ky[j]^2\n    zeta_spectral[k, i, j] = -kh2 * final_psi[k, i, j]\nend\n\n# Extract horizontal slice at mid-depth\nk_mid = nz ÷ 2\npsi_slice = slice_horizontal(Sn.psi, G, plans; k=k_mid)\nA_slice = slice_horizontal(Sn.A, G, plans; k=k_mid)\n\nprintln(\"\\nFinal state analysis:\")\nprintln(\"  ψ at z=$(G.z[k_mid]) m:\")\nprintln(\"    min = $(minimum(real.(psi_slice)))\")\nprintln(\"    max = $(maximum(real.(psi_slice)))\")\nprintln(\"  |A| at z=$(G.z[k_mid]) m:\")\nprintln(\"    min = $(minimum(abs.(A_slice)))\")\nprintln(\"    max = $(maximum(abs.(A_slice)))\")\n\n# Check wave concentration\n# Waves should be stronger in the anticyclone (positive ψ region)\nprintln(\"\\nWave refraction check:\")\nprintln(\"  If waves concentrated in anticyclone, max|A| should be\")\nprintln(\"  near max(ψ) location\")\n\n","category":"section"},{"location":"worked_example/#Step-7:-Save-Output","page":"Worked Example","title":"Step 7: Save Output","text":"# ============================================================================\n#                       SAVE OUTPUT\n# ============================================================================\n\nusing NCDatasets\n\noutput_file = \"dipole_waves.nc\"\n\nNCDataset(output_file, \"c\") do ds\n    # Define dimensions\n    defDim(ds, \"x\", nx)\n    defDim(ds, \"y\", ny)\n    defDim(ds, \"z\", nz)\n    defDim(ds, \"time\", length(times))\n\n    # Coordinate variables\n    x_var = defVar(ds, \"x\", Float64, (\"x\",))\n    y_var = defVar(ds, \"y\", Float64, (\"y\",))\n    z_var = defVar(ds, \"z\", Float64, (\"z\",))\n    t_var = defVar(ds, \"time\", Float64, (\"time\",))\n\n    x_var[:] = G.x\n    y_var[:] = G.y\n    z_var[:] = G.z\n    t_var[:] = times\n\n    # Final state (mid-depth slice)\n    psi_var = defVar(ds, \"psi_final\", Float64, (\"x\", \"y\"))\n    A_var = defVar(ds, \"A_amplitude_final\", Float64, (\"x\", \"y\"))\n\n    psi_var[:, :] = real.(psi_slice)'\n    A_var[:, :] = abs.(A_slice)'\n\n    # Time series\n    KE_var = defVar(ds, \"flow_KE\", Float64, (\"time\",))\n    WE_var = defVar(ds, \"wave_energy\", Float64, (\"time\",))\n\n    KE_var[:] = flow_energies\n    WE_var[:] = wave_energies\n\n    # Attributes\n    ds.attrib[\"description\"] = \"QG-YBJ+ dipole-wave simulation\"\n    ds.attrib[\"inertial_period_hours\"] = T_inertial / 3600\nend\n\nprintln(\"\\nOutput saved to: $output_file\")\n\n","category":"section"},{"location":"worked_example/#Complete-Script","page":"Worked Example","title":"Complete Script","text":"Here's the full script you can copy and run:\n\n# dipole_waves.jl - Complete QG-YBJ+ simulation example\n#\n# Run with: julia --project dipole_waves.jl\n\nusing QGYBJplus\nusing Printf\n\n# === Parameters ===\nconst Lx, Ly, Lz = 500e3, 500e3, 4000.0\nconst nx, ny, nz = 128, 128, 64\nconst f₀, N² = 1e-4, 1e-5\nconst T_inertial = 2π / f₀\nconst dt = 10.0\nconst nt = round(Int, 5 * T_inertial / dt)\n\n# === Create model ===\npar = default_params(nx=nx, ny=ny, nz=nz, Lx=Lx, Ly=Ly, Lz=Lz,\n                     f₀=f₀, N²=N², dt=dt, nt=nt,\n                     ybj_plus=true, no_wave_feedback=true)\nG, S, plans, a_ell = setup_model(par)\nL = dealias_mask(G)\n\n# === Initial conditions ===\n# (Add dipole and wave initialization here - see sections above)\n\n# === Time stepping ===\nSnm1, Sn, Snp1 = copy_state(S), copy_state(S), copy_state(S)\nfirst_projection_step!(Sn, G, par, plans; a=a_ell, dealias_mask=L)\ncopy_state!(Snm1, Sn)\n\nfor step in 1:nt\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a_ell, dealias_mask=L)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\nprintln(\"Done! Final KE = \", flow_kinetic_energy(Sn.u, Sn.v))\n\n","category":"section"},{"location":"worked_example/#What's-Next?","page":"Worked Example","title":"What's Next?","text":"Now that you've built a complete simulation:\n\nConfiguration Guide - Customize all parameters\nStratification - Use realistic N²(z) profiles\nMPI Parallelization - Scale to larger domains\nParticle Advection - Track Lagrangian trajectories\nPhysics Overview - Understand the equations deeply\n\n","category":"section"},{"location":"worked_example/#Common-Modifications","page":"Worked Example","title":"Common Modifications","text":"","category":"section"},{"location":"worked_example/#Use-IMEX-Time-Stepping-(10x-faster)","page":"Worked Example","title":"Use IMEX Time Stepping (10x faster)","text":"# Replace leapfrog with IMEX-CN\nimex_ws = init_imex_workspace(Sn, G)\nfirst_imex_step!(Sn, G, par, plans, imex_ws; a=a_ell, dealias_mask=L)\n\nfor step in 1:nt\n    imex_cn_step!(Snp1, Sn, G, par, plans, imex_ws; a=a_ell, dealias_mask=L)\n    parent(Sn.B) .= parent(Snp1.B)\n    parent(Sn.q) .= parent(Snp1.q)\nend","category":"section"},{"location":"worked_example/#Add-Particle-Tracking","page":"Worked Example","title":"Add Particle Tracking","text":"# Create particles at mid-depth\npconfig = particles_in_box(-2000.0; x_max=Lx, y_max=Ly, nx=20, ny=20)\ntracker = ParticleTracker(pconfig, G)\ninitialize_particles!(tracker, pconfig)\n\n# In time loop, add:\nadvect_particles!(tracker, Sn, G, dt, current_time)\n\n# After simulation:\nwrite_particle_trajectories(\"trajectories.nc\", tracker)","category":"section"},{"location":"worked_example/#Use-Realistic-Stratification","page":"Worked Example","title":"Use Realistic Stratification","text":"par = default_params(\n    Lx=Lx, Ly=Ly, Lz=Lz, nx=nx, ny=ny, nz=nz,\n    stratification = :skewed_gaussian,  # Realistic pycnocline\n    # Other parameters...\n)\nG, S, plans, a_ell, N2_profile = setup_model_with_profile(par)","category":"section"},{"location":"worked_example/#Use-an-Analytical-N(z)-Profile","page":"Worked Example","title":"Use an Analytical N(z) Profile","text":"a = 0.01    # s^-1\nb = -2.0e-6 # s^-1 m^-1\n@inline N(z) = a + b * z  # z is negative below the surface\n\ndomain = create_domain_config(nx=nx, ny=ny, nz=nz, Lx=Lx, Ly=Ly, Lz=Lz)\nstrat = create_stratification_config(type=:analytical, N_func=N)\nsim = setup_simulation(domain, strat)","category":"section"}]
}
