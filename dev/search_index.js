var documenterSearchIndex = {"docs":
[{"location":"physics/overview/#physics-overview","page":"Model Overview","title":"Model Overview","text":"This page provides an overview of the physics implemented in QGYBJ.jl. For detailed equations, see the individual sections on QG dynamics and YBJ+ waves.","category":"section"},{"location":"physics/overview/#Physical-Setting","page":"Model Overview","title":"Physical Setting","text":"","category":"section"},{"location":"physics/overview/#The-Ocean's-Two-Scale-Problem","page":"Model Overview","title":"The Ocean's Two-Scale Problem","text":"The ocean interior contains two dominant forms of variability:\n\nMesoscale eddies (balanced flow)\nHorizontal scale: ~50-200 km\nVertical scale: ~1000 m (full depth)\nTime scale: weeks to months\nEnergy: ~90% of oceanic kinetic energy\nNear-inertial waves (NIWs)\nHorizontal scale: ~10-50 km\nVertical scale: ~100-500 m\nTime scale: hours (~ inertial period)\nEnergy: significant portion of internal wave energy\n\nThese two phenomena interact:\n\nEddies refract NIWs, focusing energy in anticyclones\nNIWs can feed energy back to the balanced flow\nCombined dynamics drive mixing and energy dissipation","category":"section"},{"location":"physics/overview/#Why-QG-YBJ?","page":"Model Overview","title":"Why QG-YBJ+?","text":"The QG-YBJ+ model efficiently captures this interaction:\n\nAspect QG (Eddies) YBJ+ (Waves)\nVariables Streamfunction ψ Wave envelope B\nDynamics Advection of PV Advection + refraction\nInversion q → ψ (elliptic) B → A (elliptic)\nCoupling Wave feedback qʷ Refraction by ζ","category":"section"},{"location":"physics/overview/#Governing-Equations","page":"Model Overview","title":"Governing Equations","text":"","category":"section"},{"location":"physics/overview/#Quasi-Geostrophic-Potential-Vorticity","page":"Model Overview","title":"Quasi-Geostrophic Potential Vorticity","text":"The balanced flow evolves according to:\n\nfracpartial qpartial t + J(psi q) + J(psi q^w) = textdissipation\n\nwhere:\n\nq = nabla^2psi + fracf_0^2N^2fracpartial^2psipartial z^2 is potential vorticity\npsi is the streamfunction (u = -∂ψ/∂y, v = ∂ψ/∂x)\nq^w is the wave feedback term\nJ(ab) = fracpartial apartial xfracpartial bpartial y - fracpartial apartial yfracpartial bpartial x is the Jacobian","category":"section"},{"location":"physics/overview/#YBJ-Wave-Envelope","page":"Model Overview","title":"YBJ+ Wave Envelope","text":"The near-inertial wave envelope evolves according to:\n\nfracpartial Bpartial t + J(psi B) = -ifrack_h^22 cdot Bu cdot Ro A + frac12B times zeta + textdissipation\n\nwhere:\n\nB = L^+ A is the evolved wave envelope\nA is the actual wave amplitude (recovered via elliptic inversion)\nzeta = nabla^2psi is the relative vorticity\nL^+ is an elliptic operator relating B and A\nBu = (N_0 H  f_0 L)^2 is the Burger number\nRo = U  (f_0 L) is the Rossby number\n\nThe dispersion coefficient 1(2 cdot Bu cdot Ro) represents nondimensionalized N^2(2f_0).","category":"section"},{"location":"physics/overview/#Key-Physical-Processes","page":"Model Overview","title":"Key Physical Processes","text":"                    ┌─────────────────┐\n                    │   Wind Forcing  │\n                    └────────┬────────┘\n                             │\n                             ▼\n┌──────────────┐    ┌─────────────────┐    ┌──────────────┐\n│  Mean Flow   │◄───│  Near-Inertial  │───►│   Mixing &   │\n│   (ψ, q)     │    │   Waves (B, A)  │    │  Dissipation │\n└──────┬───────┘    └────────┬────────┘    └──────────────┘\n       │                     │\n       │    ┌────────────────┤\n       │    │                │\n       ▼    ▼                ▼\n    Advection           Refraction\n    J(ψ, q)             (1/2) B × ζ\n       │                     │\n       │    Wave Feedback    │\n       └────────qʷ───────────┘","category":"section"},{"location":"physics/overview/#Nondimensionalization","page":"Model Overview","title":"Nondimensionalization","text":"The model uses nondimensional variables scaled by:\n\nQuantity Scale Physical Value\nLength L Rossby radius (~50 km)\nDepth H Domain depth (~2000 m)\nTime 1f_0 Inertial period (~17 h at 45°N)\nVelocity U Eddy velocity (~0.1 m/s)\nStratification N_0 Reference buoyancy frequency\n\nKey nondimensional parameters:\n\nRossby number: Ro = U(f_0 L) ≈ 0.1\nBurger number: Bu = (N_0 H  f_0 L)^2 ≈ 1","category":"section"},{"location":"physics/overview/#Prognostic-vs-Diagnostic-Variables","page":"Model Overview","title":"Prognostic vs Diagnostic Variables","text":"","category":"section"},{"location":"physics/overview/#Prognostic-(Time-Stepped)","page":"Model Overview","title":"Prognostic (Time-Stepped)","text":"q: Potential vorticity (spectral)\nB: Wave envelope (spectral)","category":"section"},{"location":"physics/overview/#Diagnostic-(Computed)","page":"Model Overview","title":"Diagnostic (Computed)","text":"psi: Streamfunction (from q via elliptic inversion)\nA: Wave amplitude (from B via YBJ+ inversion)\nu v: Horizontal velocities (from ψ)\nw: Vertical velocity (from omega equation or YBJ)","category":"section"},{"location":"physics/overview/#Boundary-Conditions","page":"Model Overview","title":"Boundary Conditions","text":"","category":"section"},{"location":"physics/overview/#Horizontal","page":"Model Overview","title":"Horizontal","text":"Doubly periodic: f(x+L_x y) = f(x y+L_y) = f(x y)","category":"section"},{"location":"physics/overview/#Vertical","page":"Model Overview","title":"Vertical","text":"Rigid lid: w = 0 at z = 0 and z = H\nNo flux: fracpartialpsipartial z = 0 at boundaries (Neumann)","category":"section"},{"location":"physics/overview/#Energy-Budget","page":"Model Overview","title":"Energy Budget","text":"","category":"section"},{"location":"physics/overview/#Flow-Energy","page":"Model Overview","title":"Flow Energy","text":"E_textflow = frac12int left( u^2 + v^2 + fracf_0^2N^2left(fracpartialpsipartial zright)^2 right) dV","category":"section"},{"location":"physics/overview/#Wave-Energy","page":"Model Overview","title":"Wave Energy","text":"E_textwave = frac12int A^2  dV","category":"section"},{"location":"physics/overview/#Energy-Exchange","page":"Model Overview","title":"Energy Exchange","text":"The wave feedback term q^w mediates energy transfer between waves and flow.","category":"section"},{"location":"physics/overview/#Code-Structure","page":"Model Overview","title":"Code Structure","text":"The physics is implemented across several modules:\n\nModule Physics\nelliptic.jl q → ψ and B → A inversions\nnonlinear.jl Jacobians, refraction, wave feedback\noperators.jl Velocity computation\ntimestep.jl Time integration\ndiagnostics.jl Energy and omega equation","category":"section"},{"location":"physics/overview/#Further-Reading","page":"Model Overview","title":"Further Reading","text":"QG Equations: Detailed QG dynamics\nYBJ+ Wave Model: Wave envelope formulation\nWave-Mean Interaction: Energy exchange mechanism\nNumerical Methods: Discretization and algorithms","category":"section"},{"location":"guide/io/#io-output","page":"I/O and Output","title":"I/O and Output","text":"This page explains how to save and load simulation data in QGYBJ.jl.","category":"section"},{"location":"guide/io/#Output-Formats","page":"I/O and Output","title":"Output Formats","text":"QGYBJ.jl supports multiple output formats:\n\nFormat Extension Use Case Parallel Support\nNetCDF .nc Analysis, visualization Yes\nJLD2 .jld2 Restart files, full state Yes\nHDF5 .h5 Large datasets Yes","category":"section"},{"location":"guide/io/#NetCDF-Output","page":"I/O and Output","title":"NetCDF Output","text":"","category":"section"},{"location":"guide/io/#Basic-Setup","page":"I/O and Output","title":"Basic Setup","text":"using NCDatasets\n\n# Configure output\noutput_config = OutputConfig(\n    dir = \"output\",\n    prefix = \"qgybj\",\n    interval = 100,           # Steps between outputs\n    variables = [:psi, :B, :q],\n    format = :netcdf\n)\n\n# Initialize output file\ninit_output!(output_config, grid, params)","category":"section"},{"location":"guide/io/#Writing-Data","page":"I/O and Output","title":"Writing Data","text":"# In time loop\nfor step = 1:nsteps\n    timestep!(state, ...)\n\n    # Write at specified intervals\n    if step % output_config.interval == 0\n        write_output!(output_config, state, grid, step, time)\n    end\nend\n\n# Close file\nclose_output!(output_config)","category":"section"},{"location":"guide/io/#Output-Variables","page":"I/O and Output","title":"Output Variables","text":"Variable Description Dimensions\npsi Streamfunction (spectral) (kx, ky, z, t)\nB Wave envelope (spectral) (kx, ky, z, t)\nq Potential vorticity (spectral) (kx, ky, z, t)\nA Wave amplitude (spectral) (kx, ky, z, t)\nu, v Velocities (physical) (x, y, z, t)\nenergy Domain-integrated energy (t)","category":"section"},{"location":"guide/io/#Custom-Variables","page":"I/O and Output","title":"Custom Variables","text":"# Add custom diagnostic\nfunction my_diagnostic(state, grid)\n    return sum(abs2.(state.psi)) * grid.dx * grid.dy * grid.dz\nend\n\n# Register custom output\nadd_output_variable!(output_config, \"my_diag\", my_diagnostic;\n    dims = (\"time\",),\n    units = \"m^4/s^2\"\n)","category":"section"},{"location":"guide/io/#Reading-NetCDF-Data","page":"I/O and Output","title":"Reading NetCDF Data","text":"","category":"section"},{"location":"guide/io/#Basic-Reading","page":"I/O and Output","title":"Basic Reading","text":"using NCDatasets\n\nds = NCDataset(\"output/qgybj_0001.nc\")\n\n# Read variables\npsi = ds[\"psi\"][:]      # Full 4D array (kx, ky, z, time)\ntime = ds[\"time\"][:]    # Time coordinate\n\n# Read single snapshot\npsi_t10 = ds[\"psi\"][:, :, :, 10]\n\nclose(ds)","category":"section"},{"location":"guide/io/#Lazy-Reading","page":"I/O and Output","title":"Lazy Reading","text":"For large files, read lazily:\n\nds = NCDataset(\"output/qgybj_0001.nc\")\n\n# This doesn't load data yet\npsi_var = ds[\"psi\"]\n\n# Load only what you need\nfor t in 1:10\n    snapshot = psi_var[:, :, :, t]\n    # Process snapshot\nend\n\nclose(ds)","category":"section"},{"location":"guide/io/#Using-do-Block","page":"I/O and Output","title":"Using do Block","text":"NCDataset(\"output/qgybj_0001.nc\") do ds\n    psi = ds[\"psi\"][:]\n    # Process data\nend  # File automatically closed","category":"section"},{"location":"guide/io/#JLD2-for-Restart-Files","page":"I/O and Output","title":"JLD2 for Restart Files","text":"","category":"section"},{"location":"guide/io/#Saving-State","page":"I/O and Output","title":"Saving State","text":"using JLD2\n\n# Save full state for restart\n@save \"restart.jld2\" state grid params step time\n\n# Or more selectively\njldsave(\"restart.jld2\";\n    psi = state.psi,\n    B = state.B,\n    q = state.q,\n    step = step,\n    time = time\n)","category":"section"},{"location":"guide/io/#Loading-State","page":"I/O and Output","title":"Loading State","text":"# Load everything\n@load \"restart.jld2\" state grid params step time\n\n# Or selectively\ndata = load(\"restart.jld2\")\npsi = data[\"psi\"]\nstep = data[\"step\"]","category":"section"},{"location":"guide/io/#Restarting-Simulation","page":"I/O and Output","title":"Restarting Simulation","text":"# Load restart file\n@load \"restart.jld2\" state grid params step_start time_start\n\n# Continue simulation\nfor step = step_start+1:nsteps\n    timestep!(state, ...)\nend","category":"section"},{"location":"guide/io/#Checkpointing","page":"I/O and Output","title":"Checkpointing","text":"","category":"section"},{"location":"guide/io/#Automatic-Checkpoints","page":"I/O and Output","title":"Automatic Checkpoints","text":"config = create_simple_config(\n    # ...\n    checkpoint_interval = 1000,  # Steps between checkpoints\n    checkpoint_dir = \"checkpoints\"\n)","category":"section"},{"location":"guide/io/#Manual-Checkpointing","page":"I/O and Output","title":"Manual Checkpointing","text":"function save_checkpoint(state, grid, params, step, time)\n    filename = \"checkpoints/checkpoint_$(lpad(step, 8, '0')).jld2\"\n    @save filename state grid params step time\n    return filename\nend\n\n# In time loop\nif step % checkpoint_interval == 0\n    save_checkpoint(state, grid, params, step, time)\nend","category":"section"},{"location":"guide/io/#Checkpoint-Rotation","page":"I/O and Output","title":"Checkpoint Rotation","text":"Keep only recent checkpoints to save disk space:\n\nfunction rotate_checkpoints(dir, keep_n=3)\n    files = sort(glob(\"checkpoint_*.jld2\", dir))\n    while length(files) > keep_n\n        rm(popfirst!(files))\n    end\nend","category":"section"},{"location":"guide/io/#Diagnostics-Output","page":"I/O and Output","title":"Diagnostics Output","text":"","category":"section"},{"location":"guide/io/#Time-Series","page":"I/O and Output","title":"Time Series","text":"# Collect diagnostics during run\ndiagnostics = DiagnosticsTimeSeries()\n\nfor step = 1:nsteps\n    timestep!(state, ...)\n\n    # Compute and store diagnostics\n    record!(diagnostics, step, time,\n        KE = flow_kinetic_energy(state.u, state.v),\n        PE = flow_potential_energy(state.psi, grid),\n        WE = wave_energy(state.B, state.A)\n    )\nend\n\n# Save to file\nsave_diagnostics(\"diagnostics.csv\", diagnostics)","category":"section"},{"location":"guide/io/#Format","page":"I/O and Output","title":"Format","text":"step,time,KE,PE,WE\n0,0.0,0.0123,0.0045,0.0089\n100,0.1,0.0121,0.0044,0.0087\n...","category":"section"},{"location":"guide/io/#MPI-Parallel-I/O-with-2D-Decomposition","page":"I/O and Output","title":"MPI Parallel I/O with 2D Decomposition","text":"QGYBJ.jl provides seamless I/O support for 2D pencil decomposition. The I/O functions automatically handle distributed arrays.","category":"section"},{"location":"guide/io/#Writing-State-Files","page":"I/O and Output","title":"Writing State Files","text":"using MPI, PencilArrays, PencilFFTs, QGYBJ\n\nMPI.Init()\nmpi_config = QGYBJ.setup_mpi_environment()\n\n# Setup distributed grid and state\ngrid = QGYBJ.init_mpi_grid(params, mpi_config)\nstate = QGYBJ.init_mpi_state(grid, mpi_config)\n\n# Create output manager with parallel config\noutput_config = OutputConfig(\n    output_dir = \"output\",\n    state_file_pattern = \"state%04d.nc\",\n    psi_interval = 0.1,\n    wave_interval = 0.1\n)\nmanager = OutputManager(output_config, params, mpi_config)\n\n# Write state - automatically handles 2D decomposition\nwrite_state_file(manager, state, grid, plans, time, mpi_config)","category":"section"},{"location":"guide/io/#Reading-Initial-Conditions","page":"I/O and Output","title":"Reading Initial Conditions","text":"# Read psi - works in both serial and parallel mode\npsi = read_initial_psi(\"initial_psi.nc\", grid, plans; parallel_config=mpi_config)\n# In parallel: rank 0 reads, then scatters to all processes\n\n# Read wave field\nB = read_initial_waves(\"initial_waves.nc\", grid, plans; parallel_config=mpi_config)\n\n# Or use legacy wrappers with parallel support\nncread_psi!(state, grid, plans; path=\"psi.nc\", parallel_config=mpi_config)\nncread_la!(state, grid, plans; path=\"la.nc\", parallel_config=mpi_config)","category":"section"},{"location":"guide/io/#I/O-Strategy-for-2D-Decomposition","page":"I/O and Output","title":"I/O Strategy for 2D Decomposition","text":"QGYBJ.jl uses a gather-to-root strategy for parallel I/O:\n\n┌─────────────────────────────────────────────────────────────┐\n│                    Parallel I/O Strategy                    │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  WRITING:                                                   │\n│  ┌─────────┐   gather_to_root   ┌─────────┐   write   ┌───┐ │\n│  │ Rank 0  │ ←───────────────── │ Rank 0  │ ────────→ │.nc│ │\n│  │ Rank 1  │                    │ (full   │           └───┘ │\n│  │ Rank 2  │                    │  array) │                 │\n│  │   ...   │                    └─────────┘                 │\n│  └─────────┘                                                │\n│                                                             │\n│  READING:                                                   │\n│  ┌───┐   read    ┌─────────┐  scatter_from_root  ┌────────┐ │\n│  │.nc│ ────────→ │ Rank 0  │ ──────────────────→ │ Rank 0 │ │\n│  └───┘           │ (full   │                     │ Rank 1 │ │\n│                  │  array) │                     │ Rank 2 │ │\n│                  └─────────┘                     │   ...  │ │\n│                                                  └────────┘ │\n└─────────────────────────────────────────────────────────────┘\n\nThis approach is:\n\nSimple: No parallel NetCDF library required\nReliable: Standard serial NetCDF always works\nPortable: Works on any system","category":"section"},{"location":"guide/io/#Local-Index-Ranges-for-Manual-I/O","page":"I/O and Output","title":"Local Index Ranges for Manual I/O","text":"# Get local ranges for this process (xy-pencil)\nif grid.decomp !== nothing\n    local_range = grid.decomp.local_range_xy\n    # local_range = (1:nx_local, y_start:y_end, z_start:z_end)\nelse\n    local_range = (1:grid.nx, 1:grid.ny, 1:grid.nz)\nend\n\n# Use with NCDatasets for manual parallel writes\nNCDatasets.Dataset(\"output.nc\", \"c\"; comm=mpi_config.comm) do ds\n    ds.dim[\"x\"] = grid.nx\n    ds.dim[\"y\"] = grid.ny\n    ds.dim[\"z\"] = grid.nz\n\n    psi_var = NCDatasets.defVar(ds, \"psi\", Float64, (\"x\", \"y\", \"z\"))\n\n    # Each rank writes its portion\n    psi_var[local_range[1], local_range[2], local_range[3]] = local_psi_data\nend","category":"section"},{"location":"guide/io/#Gather/Scatter-for-I/O","page":"I/O and Output","title":"Gather/Scatter for I/O","text":"# Gather distributed array to rank 0\nglobal_psi = QGYBJ.gather_to_root(state.psi, grid, mpi_config)\n# Returns full array on rank 0, nothing on other ranks\n\n# Scatter from rank 0 to all processes\nlocal_psi = QGYBJ.scatter_from_root(global_psi, grid, mpi_config)\n# Each rank receives its local portion","category":"section"},{"location":"guide/io/#Physical-Space-Output","page":"I/O and Output","title":"Physical Space Output","text":"","category":"section"},{"location":"guide/io/#Transform-Before-Writing","page":"I/O and Output","title":"Transform Before Writing","text":"# Spectral → Physical\npsi_phys = irfft(state.psi, grid.nx)\n\n# Write physical space data\nds[\"psi_phys\"][:, :, :, t] = psi_phys","category":"section"},{"location":"guide/io/#Vorticity","page":"I/O and Output","title":"Vorticity","text":"# Compute vorticity (spectral)\nzeta_k = -grid.kh2 .* state.psi\n\n# Transform to physical\nzeta = irfft(zeta_k, grid.nx)\n\nds[\"vorticity\"][:, :, :, t] = zeta","category":"section"},{"location":"guide/io/#Output-Best-Practices","page":"I/O and Output","title":"Output Best Practices","text":"","category":"section"},{"location":"guide/io/#File-Naming","page":"I/O and Output","title":"File Naming","text":"# Include simulation info in filename\nprefix = \"qgybj_nx$(nx)_nz$(nz)\"\n\n# Timestamp outputs\ntimestamp = Dates.format(now(), \"yyyymmdd_HHMMSS\")\nfilename = \"$(prefix)_$(timestamp).nc\"","category":"section"},{"location":"guide/io/#Compression","page":"I/O and Output","title":"Compression","text":"# Enable compression for NetCDF\ndefVar(ds, \"psi\", Float64, (\"x\", \"y\", \"z\", \"time\");\n    deflatelevel = 5,  # 0-9, higher = more compression\n    chunksizes = (nx, ny, nz, 1)  # Chunk by time slice\n)","category":"section"},{"location":"guide/io/#Metadata","page":"I/O and Output","title":"Metadata","text":"# Add attributes\nds.attrib[\"title\"] = \"QGYBJ.jl simulation output\"\nds.attrib[\"history\"] = \"Created $(now())\"\nds.attrib[\"Conventions\"] = \"CF-1.8\"\n\n# Variable attributes\nds[\"psi\"].attrib[\"long_name\"] = \"Streamfunction\"\nds[\"psi\"].attrib[\"units\"] = \"m^2/s\"","category":"section"},{"location":"guide/io/#Visualization-Integration","page":"I/O and Output","title":"Visualization Integration","text":"","category":"section"},{"location":"guide/io/#Quick-Plotting","page":"I/O and Output","title":"Quick Plotting","text":"using Plots, NCDatasets\n\nNCDataset(\"output.nc\") do ds\n    psi = ds[\"psi\"][:, :, end, end]  # Surface, last time\n    heatmap(real(irfft(psi, nx)), title=\"Surface ψ\")\nend","category":"section"},{"location":"guide/io/#Animation","page":"I/O and Output","title":"Animation","text":"using Plots\n\nNCDataset(\"output.nc\") do ds\n    anim = @animate for t in 1:size(ds[\"psi\"], 4)\n        psi = ds[\"psi\"][:, :, end, t]\n        heatmap(real(irfft(psi, nx)),\n            title = \"t = $(ds[\"time\"][t])\",\n            clim = (-1, 1)\n        )\n    end\n    gif(anim, \"animation.gif\", fps=10)\nend","category":"section"},{"location":"guide/io/#API-Reference","page":"I/O and Output","title":"API Reference","text":"For I/O operations, use the following approaches:\n\nNetCDF reading: Use NCDatasets.jl directly as shown above\nInitial conditions: ncread_psi!, ncread_la! for loading spectral fields\nParallel I/O: gather_to_root, scatter_from_root for 2D decomposition\n\nSee the Grid & State API for field initialization functions.","category":"section"},{"location":"guide/diagnostics/#diagnostics","page":"Diagnostics","title":"Diagnostics","text":"This page describes diagnostic quantities and analysis tools in QGYBJ.jl.","category":"section"},{"location":"guide/diagnostics/#Energy-Diagnostics","page":"Diagnostics","title":"Energy Diagnostics","text":"","category":"section"},{"location":"guide/diagnostics/#Flow-Kinetic-Energy","page":"Diagnostics","title":"Flow Kinetic Energy","text":"The kinetic energy of the balanced flow:\n\nKE = frac12int (u^2 + v^2)  dV\n\nKE = flow_kinetic_energy(state.u, state.v, grid)","category":"section"},{"location":"guide/diagnostics/#Flow-Potential-Energy","page":"Diagnostics","title":"Flow Potential Energy","text":"Available potential energy:\n\nPE = frac12int fracf_0^2N^2left(fracpartialpsipartial zright)^2 dV\n\nPE = flow_potential_energy(state.psi, grid, params)","category":"section"},{"location":"guide/diagnostics/#Total-Flow-Energy","page":"Diagnostics","title":"Total Flow Energy","text":"E_flow = flow_total_energy(state, grid, params)\n# Equivalent to: KE + PE","category":"section"},{"location":"guide/diagnostics/#Wave-Energy","page":"Diagnostics","title":"Wave Energy","text":"E_wave = frac12int A^2  dV\n\nE_B, E_A = wave_energy(state.B, state.A, grid)\n\nnote: Note\nE_B and E_A differ because the L^+ operator is not unitary. E_A is the physical wave energy.","category":"section"},{"location":"guide/diagnostics/#Energy-Diagnostics-Output-Files","page":"Diagnostics","title":"Energy Diagnostics Output Files","text":"QGYBJ.jl automatically saves energy diagnostics to separate files in a dedicated diagnostic/ folder, following the structure used in the Fortran QG_YBJp code.","category":"section"},{"location":"guide/diagnostics/#Output-Folder-Structure","page":"Diagnostics","title":"Output Folder Structure","text":"output_dir/\n├── state0001.nc              # Field snapshots\n├── state0002.nc\n├── diagnostics_0001.nc       # Legacy combined diagnostics\n└── diagnostic/               # Separate energy files\n    ├── wave_KE.nc            # Wave kinetic energy time series\n    ├── wave_PE.nc            # Wave potential energy time series\n    ├── wave_CE.nc            # Wave correction energy (YBJ+)\n    ├── mean_flow_KE.nc       # Mean flow kinetic energy\n    ├── mean_flow_PE.nc       # Mean flow potential energy\n    └── total_energy.nc       # Summary file with all energies","category":"section"},{"location":"guide/diagnostics/#Wave-Kinetic-Energy-(WKE)","page":"Diagnostics","title":"Wave Kinetic Energy (WKE)","text":"The wave kinetic energy is computed from the wave envelope B = B_R + iB_I:\n\ntextWKE = frac12 sum_k_x k_y z left( B_R^2 + B_I^2 right) - frac12 B(k_h=0)^2\n\nwhere the second term is the dealiasing correction (2/3 rule).\n\nPhysical interpretation: WKE represents the kinetic energy contained in the near-inertial wave field, analogous to frac12(u_w^2 + v_w^2) for wave velocities.","category":"section"},{"location":"guide/diagnostics/#Wave-Potential-Energy-(WPE)","page":"Diagnostics","title":"Wave Potential Energy (WPE)","text":"The wave potential energy captures vertical wave structure through C = partial Apartial z:\n\ntextWPE = frac12 sum_k_x k_y z frack_h^22 a_ell left( C_R^2 + C_I^2 right)\n\nwhere:\n\na_ell = f_0^2  N^2 is the elliptic coefficient\nC = partial A  partial z is the vertical derivative of wave amplitude\nk_h^2 = k_x^2 + k_y^2 is the horizontal wavenumber squared\n\nPhysical interpretation: WPE represents the potential energy from wave-induced isopycnal displacements. It scales with N^2 eta^2 where eta is the vertical displacement.","category":"section"},{"location":"guide/diagnostics/#Wave-Correction-Energy-(WCE)","page":"Diagnostics","title":"Wave Correction Energy (WCE)","text":"The YBJ+ formulation includes a higher-order correction term:\n\ntextWCE = frac12 sum_k_x k_y z frack_h^48 a_ell^2 left( A_R^2 + A_I^2 right)\n\nPhysical interpretation: WCE is a higher-order correction from the YBJ+ equation that accounts for horizontal wave dispersion. It becomes important for short horizontal wavelengths.","category":"section"},{"location":"guide/diagnostics/#Mean-Flow-Kinetic-Energy","page":"Diagnostics","title":"Mean Flow Kinetic Energy","text":"The balanced flow kinetic energy is computed from the geostrophic velocities:\n\ntextKE_flow = frac12 sum_k_x k_y z left( u_k^2 + v_k^2 right) - frac12 u(k_h=0)^2\n\nwhere the velocities are derived from the streamfunction:\n\nu = -fracpartial psipartial y = -ik_y hatpsi quad v = fracpartial psipartial x = ik_x hatpsi\n\nThis gives:\n\nu^2 + v^2 = k_h^2 hatpsi^2\n\nPhysical interpretation: textKE_flow represents the kinetic energy of the large-scale quasi-geostrophic eddies and jets.","category":"section"},{"location":"guide/diagnostics/#Mean-Flow-Potential-Energy","page":"Diagnostics","title":"Mean Flow Potential Energy","text":"The available potential energy from buoyancy:\n\ntextPE_flow = frac12 sum_k_x k_y z fracf_0^2N^2 b_k^2\n\nwhere buoyancy b is related to the streamfunction via thermal wind balance:\n\nb = fracpartial psipartial z\n\nPhysical interpretation: textPE_flow represents the energy stored in tilted isopycnals (density surfaces). It can be released through baroclinic instability.","category":"section"},{"location":"guide/diagnostics/#Total-Energy-Conservation","page":"Diagnostics","title":"Total Energy Conservation","text":"In the inviscid limit, the total energy is conserved:\n\nE_total = underbracetextKE_flow + textPE_flow_textMean flow + underbracetextWKE + textWPE + textWCE_textWaves = textconst\n\nEnergy exchange between waves and mean flow occurs via:\n\nRefraction: Waves gain/lose energy from vorticity gradients\nWave feedback q^w: Waves modify the effective PV","category":"section"},{"location":"guide/diagnostics/#Using-the-EnergyDiagnosticsManager","page":"Diagnostics","title":"Using the EnergyDiagnosticsManager","text":"The energy diagnostics manager is automatically created during simulation setup:\n\n# Energy diagnostics are computed and saved automatically during simulation\nsim = setup_simulation(config)\nrun_simulation!(sim)\n\n# After simulation, files are in:\n# output_dir/diagnostic/wave_KE.nc\n# output_dir/diagnostic/wave_PE.nc\n# etc.\n\nFor manual control:\n\nusing QGYBJ\n\n# Create manager manually\nenergy_manager = EnergyDiagnosticsManager(\n    \"output_dir\";\n    output_interval=1.0  # Time between outputs\n)\n\n# Record energies at each diagnostic time\nrecord_energies!(\n    energy_manager,\n    current_time,\n    wave_KE, wave_PE, wave_CE,\n    mean_flow_KE, mean_flow_PE\n)\n\n# Write all files at end\nwrite_all_energy_files!(energy_manager)","category":"section"},{"location":"guide/diagnostics/#Reading-Energy-Output-Files","page":"Diagnostics","title":"Reading Energy Output Files","text":"using NCDatasets\n\n# Read wave KE time series\nds = NCDataset(\"output_dir/diagnostic/wave_KE.nc\", \"r\")\ntime = ds[\"time\"][:]\nwave_KE = ds[\"wave_KE\"][:]\nclose(ds)\n\n# Read total energy summary\nds = NCDataset(\"output_dir/diagnostic/total_energy.nc\", \"r\")\ntime = ds[\"time\"][:]\ntotal_wave = ds[\"total_wave_energy\"][:]\ntotal_flow = ds[\"total_flow_energy\"][:]\ntotal = ds[\"total_energy\"][:]\nclose(ds)\n\n# Plot energy evolution\nusing Plots\nplot(time, total, label=\"Total\", linewidth=2)\nplot!(time, total_flow, label=\"Mean flow\", linestyle=:dash)\nplot!(time, total_wave, label=\"Waves\", linestyle=:dot)\nxlabel!(\"Time\")\nylabel!(\"Energy\")","category":"section"},{"location":"guide/diagnostics/#Energy-Budget-Verification","page":"Diagnostics","title":"Energy Budget Verification","text":"Check energy conservation:\n\n# After simulation\nds = NCDataset(\"output_dir/diagnostic/total_energy.nc\", \"r\")\nE = ds[\"total_energy\"][:]\nclose(ds)\n\n# Relative change\ndE_rel = (E[end] - E[1]) / E[1]\nprintln(\"Relative energy change: $(dE_rel)\")\n\nif abs(dE_rel) < 1e-6\n    println(\"✓ Energy well conserved\")\nelse\n    println(\"⚠ Check time step or dissipation settings\")\nend","category":"section"},{"location":"guide/diagnostics/#Enstrophy","page":"Diagnostics","title":"Enstrophy","text":"","category":"section"},{"location":"guide/diagnostics/#Relative-Enstrophy","page":"Diagnostics","title":"Relative Enstrophy","text":"Z_zeta = frac12int zeta^2  dV\n\nwhere zeta = nabla^2psi is relative vorticity.\n\nZ_rel = relative_enstrophy(state.psi, grid)","category":"section"},{"location":"guide/diagnostics/#Potential-Enstrophy","page":"Diagnostics","title":"Potential Enstrophy","text":"Z_q = frac12int q^2  dV\n\nZ_pot = potential_enstrophy(state.q, grid)","category":"section"},{"location":"guide/diagnostics/#Spectral-Diagnostics","page":"Diagnostics","title":"Spectral Diagnostics","text":"","category":"section"},{"location":"guide/diagnostics/#Energy-Spectra","page":"Diagnostics","title":"Energy Spectra","text":"Compute 1D energy spectrum:\n\n# Horizontal wavenumber spectrum\nk, E_k = horizontal_energy_spectrum(state.psi, grid)\n\n# Plot\nusing Plots\nplot(k, E_k, xscale=:log10, yscale=:log10,\n    xlabel=\"k\", ylabel=\"E(k)\", label=\"Energy\")\nplot!(k, 0.1 .* k.^(-3), label=\"k⁻³\", linestyle=:dash)","category":"section"},{"location":"guide/diagnostics/#Vertical-Spectra","page":"Diagnostics","title":"Vertical Spectra","text":"# Vertical mode decomposition\nm, E_m = vertical_energy_spectrum(state.psi, grid, params)","category":"section"},{"location":"guide/diagnostics/#2D-Spectrum","page":"Diagnostics","title":"2D Spectrum","text":"# 2D spectrum E(kx, ky)\nE_2d = compute_2d_spectrum(state.psi, grid)\nheatmap(log10.(E_2d), xlabel=\"kx\", ylabel=\"ky\")","category":"section"},{"location":"guide/diagnostics/#Vorticity-Statistics","page":"Diagnostics","title":"Vorticity Statistics","text":"","category":"section"},{"location":"guide/diagnostics/#Vorticity-Field","page":"Diagnostics","title":"Vorticity Field","text":"# Compute vorticity\nzeta = compute_vorticity(state.psi, grid, plans)","category":"section"},{"location":"guide/diagnostics/#Statistics","page":"Diagnostics","title":"Statistics","text":"# Mean, variance, skewness, kurtosis\nstats = vorticity_statistics(zeta)\n\nprintln(\"Mean: $(stats.mean)\")\nprintln(\"Variance: $(stats.variance)\")\nprintln(\"Skewness: $(stats.skewness)\")\nprintln(\"Kurtosis: $(stats.kurtosis)\")","category":"section"},{"location":"guide/diagnostics/#PDF","page":"Diagnostics","title":"PDF","text":"# Probability density function\nbins, pdf = vorticity_pdf(zeta; nbins=100)\n\nplot(bins, pdf, xlabel=\"ζ\", ylabel=\"P(ζ)\")","category":"section"},{"location":"guide/diagnostics/#Wave-Diagnostics","page":"Diagnostics","title":"Wave Diagnostics","text":"","category":"section"},{"location":"guide/diagnostics/#Wave-Amplitude","page":"Diagnostics","title":"Wave Amplitude","text":"# |A|² field\nA2 = abs2.(state.A)\n\n# Maximum amplitude\nA_max = maximum(sqrt.(A2))\n\n# Volume-averaged amplitude\nA_rms = sqrt(mean(A2))","category":"section"},{"location":"guide/diagnostics/#Wave-Fluxes","page":"Diagnostics","title":"Wave Fluxes","text":"Energy flux in vertical:\n\n# Vertical wave energy flux\nFz = compute_wave_energy_flux_z(state.A, grid, params)","category":"section"},{"location":"guide/diagnostics/#Wave-Polarization","page":"Diagnostics","title":"Wave Polarization","text":"Horizontal wave velocity components:\n\nu_wave, v_wave = compute_wave_velocities(state.A, grid, plans)\n\n# Polarization (should be ~1 for pure inertial oscillation)\npolarization = mean(abs2.(u_wave) ./ abs2.(v_wave))","category":"section"},{"location":"guide/diagnostics/#Omega-Equation","page":"Diagnostics","title":"Omega Equation","text":"Compute ageostrophic vertical velocity:\n\n# Solve omega equation\nw = compute_omega(state.psi, grid, params, plans)\n\n# Maximum vertical velocity\nw_max = maximum(abs.(w))\n\nThe omega equation:\n\nnabla^2 w + fracN^2f_0^2fracpartial^2 wpartial z^2 = 2Jleft(fracpartialpsipartial z nabla^2psiright)","category":"section"},{"location":"guide/diagnostics/#Eddy-Identification","page":"Diagnostics","title":"Eddy Identification","text":"","category":"section"},{"location":"guide/diagnostics/#Vortex-Cores","page":"Diagnostics","title":"Vortex Cores","text":"Identify coherent vortices:\n\n# Okubo-Weiss parameter\nOW = compute_okubo_weiss(state.psi, grid, plans)\n\n# Vortex cores: OW < 0\nvortex_mask = OW .< -threshold","category":"section"},{"location":"guide/diagnostics/#Eddy-Census","page":"Diagnostics","title":"Eddy Census","text":"# Count and characterize eddies\neddies = identify_eddies(state.psi, grid;\n    threshold = 0.1,\n    min_radius = 3  # grid points\n)\n\nprintln(\"Found $(length(eddies)) eddies\")\nfor e in eddies\n    println(\"  Radius: $(e.radius), Intensity: $(e.intensity)\")\nend","category":"section"},{"location":"guide/diagnostics/#Time-Series-Analysis","page":"Diagnostics","title":"Time Series Analysis","text":"","category":"section"},{"location":"guide/diagnostics/#Recording-Diagnostics","page":"Diagnostics","title":"Recording Diagnostics","text":"# Initialize time series storage\nts = DiagnosticsTimeSeries()\n\nfor step = 1:nsteps\n    timestep!(state, ...)\n\n    # Record diagnostics\n    push!(ts.time, step * dt)\n    push!(ts.KE, flow_kinetic_energy(state.u, state.v, grid))\n    push!(ts.PE, flow_potential_energy(state.psi, grid, params))\n    push!(ts.WE, wave_energy(state.B, state.A, grid)[2])\nend","category":"section"},{"location":"guide/diagnostics/#Energy-Conservation-Check","page":"Diagnostics","title":"Energy Conservation Check","text":"# Total energy should be conserved (inviscid)\nE_total = ts.KE .+ ts.PE .+ ts.WE\n\n# Check conservation\ndE = (E_total[end] - E_total[1]) / E_total[1]\nprintln(\"Relative energy change: $dE\")\n\nif abs(dE) > 1e-6\n    @warn \"Energy not well conserved!\"\nend","category":"section"},{"location":"guide/diagnostics/#Growth-Rates","page":"Diagnostics","title":"Growth Rates","text":"# Compute growth rate from time series\nusing Statistics\n\n# Linear fit in log space\nlog_E = log.(ts.KE)\nt = ts.time\n\ngrowth_rate = (log_E[end] - log_E[1]) / (t[end] - t[1])\nprintln(\"KE growth rate: $growth_rate\")","category":"section"},{"location":"guide/diagnostics/#Budget-Analysis","page":"Diagnostics","title":"Budget Analysis","text":"","category":"section"},{"location":"guide/diagnostics/#Energy-Budget","page":"Diagnostics","title":"Energy Budget","text":"# Compute all energy budget terms\nbudget = energy_budget(state, state_old, grid, params, dt)\n\nprintln(\"dKE/dt = $(budget.dKE_dt)\")\nprintln(\"Advection: $(budget.advection)\")\nprintln(\"Dissipation: $(budget.dissipation)\")\nprintln(\"Wave feedback: $(budget.wave_feedback)\")\nprintln(\"Residual: $(budget.residual)\")","category":"section"},{"location":"guide/diagnostics/#Enstrophy-Budget","page":"Diagnostics","title":"Enstrophy Budget","text":"budget_Z = enstrophy_budget(state, grid, params)","category":"section"},{"location":"guide/diagnostics/#Spatial-Averaging","page":"Diagnostics","title":"Spatial Averaging","text":"","category":"section"},{"location":"guide/diagnostics/#Horizontal-Mean","page":"Diagnostics","title":"Horizontal Mean","text":"# Average over horizontal domain\npsi_z = horizontal_mean(state.psi, grid)  # Function of z only","category":"section"},{"location":"guide/diagnostics/#Vertical-Mean","page":"Diagnostics","title":"Vertical Mean","text":"# Depth-averaged field\npsi_xy = vertical_mean(state.psi, grid)  # Function of x, y only","category":"section"},{"location":"guide/diagnostics/#Zonal-Mean","page":"Diagnostics","title":"Zonal Mean","text":"# Average over x (zonal direction)\npsi_yz = zonal_mean(state.psi, grid)","category":"section"},{"location":"guide/diagnostics/#Correlation-Functions","page":"Diagnostics","title":"Correlation Functions","text":"","category":"section"},{"location":"guide/diagnostics/#Autocorrelation","page":"Diagnostics","title":"Autocorrelation","text":"# Spatial autocorrelation of vorticity\nlag, R = spatial_autocorrelation(zeta, grid; direction=:x)\n\n# Integral length scale\nL_int = sum(R .* diff([0; lag])) / R[1]","category":"section"},{"location":"guide/diagnostics/#Cross-Correlation","page":"Diagnostics","title":"Cross-Correlation","text":"# Correlation between wave amplitude and vorticity\nR_wave_zeta = cross_correlation(abs.(state.A), zeta, grid)","category":"section"},{"location":"guide/diagnostics/#Diagnostic-Output","page":"Diagnostics","title":"Diagnostic Output","text":"","category":"section"},{"location":"guide/diagnostics/#Comprehensive-Diagnostics","page":"Diagnostics","title":"Comprehensive Diagnostics","text":"function compute_all_diagnostics(state, grid, params, plans)\n    diag = Dict{String, Any}()\n\n    # Energy\n    diag[\"KE\"] = flow_kinetic_energy(state.u, state.v, grid)\n    diag[\"PE\"] = flow_potential_energy(state.psi, grid, params)\n    diag[\"WE_B\"], diag[\"WE_A\"] = wave_energy(state.B, state.A, grid)\n\n    # Enstrophy\n    diag[\"Z_rel\"] = relative_enstrophy(state.psi, grid)\n    diag[\"Z_pot\"] = potential_enstrophy(state.q, grid)\n\n    # Extrema\n    zeta = compute_vorticity(state.psi, grid, plans)\n    diag[\"zeta_max\"] = maximum(zeta)\n    diag[\"zeta_min\"] = minimum(zeta)\n    diag[\"A_max\"] = maximum(abs.(state.A))\n\n    return diag\nend","category":"section"},{"location":"guide/diagnostics/#Formatted-Output","page":"Diagnostics","title":"Formatted Output","text":"function print_diagnostics(diag, step, time)\n    println(\"=\" ^ 60)\n    println(\"Step: $step, Time: $(round(time, digits=4))\")\n    println(\"-\" ^ 60)\n    println(\"  KE = $(round(diag[\"KE\"], sigdigits=6))\")\n    println(\"  PE = $(round(diag[\"PE\"], sigdigits=6))\")\n    println(\"  WE = $(round(diag[\"WE_A\"], sigdigits=6))\")\n    println(\"  ζ_max = $(round(diag[\"zeta_max\"], sigdigits=4))\")\n    println(\"  |A|_max = $(round(diag[\"A_max\"], sigdigits=4))\")\n    println(\"=\" ^ 60)\nend","category":"section"},{"location":"guide/diagnostics/#API-Reference","page":"Diagnostics","title":"API Reference","text":"See the Physics API Reference for complete documentation of diagnostic functions:\n\nwave_energy - Wave energy diagnostics\nomega_eqn_rhs! - Omega equation RHS computation\n\nAdditional diagnostic utilities are available through the model interface.","category":"section"},{"location":"stratification/#Stratification","page":"-","title":"Stratification","text":"Stratification enters via N²(z) and the vertical operator coefficient a_ell_ut = 1/N². QGYBJ.jl offers several profiles.","category":"section"},{"location":"stratification/#Built‑in-Profiles","page":"-","title":"Built‑in Profiles","text":":constant_N with N0\n:skewed_gaussian (test case values from the reference Fortran)\n:tanh_profile (pycnocline‑like)\n:from_file (load N² from NetCDF)\n\nstrat = create_stratification_config(:constant_N, N0=1.0)","category":"section"},{"location":"stratification/#Using-the-Profile","page":"-","title":"Using the Profile","text":"During setup, the stratification profile is computed on the grid and used to derive a_ell_ut for the vertical inversions. The density‑like weights used by the vertical solvers default to unity (Boussinesq) for parity with the Fortran test cases, and are populated during setup_simulation.\n\nYou can override them if needed via parameter hooks:\n\npar = default_params(nx=64, ny=64, nz=32)\nrho_ut = ones(par.nz); rho_st = ones(par.nz)   # or custom profiles\npar = with_density_profiles(par; rho_ut=rho_ut, rho_st=rho_st)","category":"section"},{"location":"io/#I/O","page":"-","title":"I/O","text":"QGYBJ.jl supports optional NetCDF I/O (via NCDatasets.jl). If NCDatasets is not installed, NetCDF I/O is disabled to keep the core functionality working in restricted environments.","category":"section"},{"location":"io/#Enabling-NetCDF-I/O","page":"-","title":"Enabling NetCDF I/O","text":"julia --project=. -e 'using Pkg; Pkg.add(\"NCDatasets\")'","category":"section"},{"location":"io/#Output-Configuration","page":"-","title":"Output Configuration","text":"Set the output directory, file pattern, variables to save, and intervals via OutputConfig:\n\noutput = create_output_config(\n    output_dir = \"./my_run\",\n    state_file_pattern = \"state%04d.nc\",\n    psi_interval = 1.0,\n    wave_interval = 1.0,\n    save_psi = true,\n    save_waves = true,\n    save_velocities = true,\n    save_vertical_velocity = true,\n)\n\nFiles are written by write_state_file through the OutputManager during run_simulation! according to your intervals.","category":"section"},{"location":"io/#Reading-Initial-Conditions","page":"-","title":"Reading Initial Conditions","text":"You can initialize ψ and B (L⁺A) from NetCDF files by using InitialConditionConfig with psi_type=:from_file and/or wave_type=:from_file.\n\nLow‑level helpers (when NCDatasets is available):\n\nread_initial_psi(path) and read_initial_waves(path)\nread_stratification_profile(path)","category":"section"},{"location":"io/#Manual-I/O","page":"-","title":"Manual I/O","text":"You can access fields directly from sim.state (ψ, A/B, u/v/w) and use your own I/O libraries/formats.","category":"section"},{"location":"physics/ybj_plus/#ybj-plus","page":"YBJ+ Wave Model","title":"YBJ+ Wave Model","text":"This page describes the Young-Ben Jelloul Plus (YBJ+) formulation for near-inertial wave evolution.","category":"section"},{"location":"physics/ybj_plus/#Near-Inertial-Waves","page":"YBJ+ Wave Model","title":"Near-Inertial Waves","text":"","category":"section"},{"location":"physics/ybj_plus/#Physical-Background","page":"YBJ+ Wave Model","title":"Physical Background","text":"Near-inertial waves (NIWs) are internal gravity waves with frequencies close to the local Coriolis frequency f. They are:\n\nWind-generated: Strong winds (storms, tropical cyclones) inject NIW energy\nUbiquitous: Found throughout the world's oceans\nImportant for mixing: NIWs break and drive turbulent mixing","category":"section"},{"location":"physics/ybj_plus/#Wave-Amplitude-Representation","page":"YBJ+ Wave Model","title":"Wave Amplitude Representation","text":"The NIW velocity field is written as:\n\nmathbfu_wave = textReleft A(xyzt)  e^-if_0 t  hatmathbfz times nabla_h right + textcc\n\nwhere A is the slowly-varying complex wave amplitude.","category":"section"},{"location":"physics/ybj_plus/#The-YBJ-Equation","page":"YBJ+ Wave Model","title":"The YBJ+ Equation","text":"","category":"section"},{"location":"physics/ybj_plus/#Evolution-Equation","page":"YBJ+ Wave Model","title":"Evolution Equation","text":"The wave envelope B = L^+ A evolves according to:\n\nfracpartial Bpartial t + J(psi B) = -ifrack_h^22 cdot Bu cdot Ro A + frac12B times zeta + mathcalD_B\n\nwhere:\n\nB = L^+ A: Evolved wave envelope\nzeta = nabla^2psi: Relative vorticity\nJ(psi B): Advection by geostrophic flow\n(12)B times zeta: Refraction term (wave focusing by vorticity)\n-i k_h^2(2 cdot Bu cdot Ro) A: Dispersion (nondimensional form of -i N^2 k_h^2(2f_0) A)","category":"section"},{"location":"physics/ybj_plus/#Real/Imaginary-Decomposition","page":"YBJ+ Wave Model","title":"Real/Imaginary Decomposition","text":"Writing B = B_R + i B_I and A = A_R + i A_I, the equations become:\n\nfracpartial B_Rpartial t = -J(psi B_R) - frack_h^22 cdot Bu cdot Ro A_I + frac12 B_I times zeta - mathcalD_BR\n\nfracpartial B_Ipartial t = -J(psi B_I) + frack_h^22 cdot Bu cdot Ro A_R - frac12 B_R times zeta - mathcalD_BI","category":"section"},{"location":"physics/ybj_plus/#Physical-Terms","page":"YBJ+ Wave Model","title":"Physical Terms","text":"Term Physics Effect\nJ(psi B) Advection Waves carried by eddies\n(12)B times zeta Refraction Focusing in anticyclones\nk_h^2 A(2 cdot Bu cdot Ro) Dispersion Horizontal spreading\nmathcalD_B Dissipation Energy loss (hyperdiffusion)","category":"section"},{"location":"physics/ybj_plus/#The-L-Operator","page":"YBJ+ Wave Model","title":"The L⁺ Operator","text":"","category":"section"},{"location":"physics/ybj_plus/#Definition","page":"YBJ+ Wave Model","title":"Definition","text":"The YBJ+ operator relates B and A:\n\nB = L^+ A = fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright) - frack_h^24A","category":"section"},{"location":"physics/ybj_plus/#Inversion:-B-A","page":"YBJ+ Wave Model","title":"Inversion: B → A","text":"To recover A from B, we solve:\n\nfracpartialpartial zleft(a(z)fracpartial Apartial zright) - frack_h^24A = B\n\nwhere a(z) = f_0^2N^2(z).","category":"section"},{"location":"physics/ybj_plus/#Tridiagonal-System","page":"YBJ+ Wave Model","title":"Tridiagonal System","text":"In discretized form for each (k_x k_y):\n\na_k A_k-1 + b_k A_k + c_k A_k+1 = B_k\n\nwith:\n\na_k = a(z_k-12)Delta z^2\nc_k = a(z_k+12)Delta z^2\nb_k = -(a_k + c_k) - k_h^24","category":"section"},{"location":"physics/ybj_plus/#Boundary-Conditions","page":"YBJ+ Wave Model","title":"Boundary Conditions","text":"Neumann: fracpartial Apartial z = 0 at z = 0 H","category":"section"},{"location":"physics/ybj_plus/#Wave-Refraction","page":"YBJ+ Wave Model","title":"Wave Refraction","text":"","category":"section"},{"location":"physics/ybj_plus/#Mechanism","page":"YBJ+ Wave Model","title":"Mechanism","text":"Anticyclones (negative vorticity) trap waves:\n\nEffective frequency: f_eff = f_0 + zeta2\nIn anticyclones: zeta  0 Rightarrow f_eff  f_0\nWaves propagate toward regions of lower effective frequency","category":"section"},{"location":"physics/ybj_plus/#Mathematical-Form","page":"YBJ+ Wave Model","title":"Mathematical Form","text":"The refraction term in the YBJ+ model:\n\ntextRefraction = frac12 B times zeta = frac12 B times nabla^2psi\n\nIn terms of real/imaginary parts:\n\nr_BR = frac12 B_I times zeta contributes to partial B_Rpartial t\nr_BI = -frac12 B_R times zeta contributes to partial B_Ipartial t\n\nThis term represents focusing of wave energy by the background vorticity field.","category":"section"},{"location":"physics/ybj_plus/#Code-Implementation","page":"YBJ+ Wave Model","title":"Code Implementation","text":"# Compute refraction term: (1/2) * B × ζ where ζ = -kh²ψ\nrefraction_waqg!(rBRk, rBIk, BRk, BIk, psik, grid, plans; Lmask=L)","category":"section"},{"location":"physics/ybj_plus/#YBJ-vs-YBJ","page":"YBJ+ Wave Model","title":"YBJ vs YBJ+","text":"","category":"section"},{"location":"physics/ybj_plus/#Original-YBJ-(1997)","page":"YBJ+ Wave Model","title":"Original YBJ (1997)","text":"B = fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright)\n\nSimpler relation between B and A\nRecovery via vertical integration","category":"section"},{"location":"physics/ybj_plus/#YBJ-(Asselin-and-Young-2019)","page":"YBJ+ Wave Model","title":"YBJ+ (Asselin & Young 2019)","text":"B = fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright) - frack_h^24A\n\nIncludes horizontal wavenumber dependence\nMore accurate for high k_h modes\nRequires elliptic inversion (not just integration)","category":"section"},{"location":"physics/ybj_plus/#When-to-Use-Which","page":"YBJ+ Wave Model","title":"When to Use Which","text":"Scenario Recommendation\nLow-resolution Normal YBJ is adequate\nHigh-resolution YBJ+ more accurate\nLarge-scale waves Either works\nSmall-scale waves YBJ+ essential\n\nControl in code:\n\nparams = QGParams(; ybj_plus=true)  # Use YBJ+ (default)\nparams = QGParams(; ybj_plus=false) # Use normal YBJ","category":"section"},{"location":"physics/ybj_plus/#Dispersion-Relation","page":"YBJ+ Wave Model","title":"Dispersion Relation","text":"","category":"section"},{"location":"physics/ybj_plus/#In-the-YBJ-Framework","page":"YBJ+ Wave Model","title":"In the YBJ+ Framework","text":"The dispersion relation for NIWs:\n\nomega = f_0 + fracN^2 k_h^22f_0 m^2\n\nwhere m is the vertical wavenumber.","category":"section"},{"location":"physics/ybj_plus/#Physical-Implications","page":"YBJ+ Wave Model","title":"Physical Implications","text":"Frequency slightly above f_0\nHigher k_h → faster frequency\nLower m (longer vertical scale) → faster frequency","category":"section"},{"location":"physics/ybj_plus/#Wave-Energy","page":"YBJ+ Wave Model","title":"Wave Energy","text":"","category":"section"},{"location":"physics/ybj_plus/#Definition-2","page":"YBJ+ Wave Model","title":"Definition","text":"E_wave = frac12int A^2  dV","category":"section"},{"location":"physics/ybj_plus/#Computation","page":"YBJ+ Wave Model","title":"Computation","text":"E_B, E_A = wave_energy(state.B, state.A)\n\nnote: Note\nE_B neq E_A in general because the L⁺ operator is not unitary.","category":"section"},{"location":"physics/ybj_plus/#Implementation-Details","page":"YBJ+ Wave Model","title":"Implementation Details","text":"","category":"section"},{"location":"physics/ybj_plus/#Key-Functions","page":"YBJ+ Wave Model","title":"Key Functions","text":"The YBJ+ implementation uses these core functions:\n\ninvert_B_to_A! - Solve L⁺ operator for wave amplitude A from envelope B\nrefraction_waqg! - Compute wave refraction by vorticity\nconvol_waqg! - Compute wave advection by geostrophic flow\n\nSee the Physics API Reference for detailed documentation.","category":"section"},{"location":"physics/ybj_plus/#Code-Locations","page":"YBJ+ Wave Model","title":"Code Locations","text":"elliptic.jl: B → A inversion (invert_B_to_A!)\nnonlinear.jl: Refraction (refraction_waqg!), Advection (convol_waqg!)\nybj_normal.jl: Normal YBJ (non-plus) operators","category":"section"},{"location":"physics/ybj_plus/#References","page":"YBJ+ Wave Model","title":"References","text":"Young, W. R., & Ben Jelloul, M. (1997). Propagation of near-inertial oscillations through a geostrophic flow. J. Mar. Res., 55, 735-766.\nAsselin, O., & Young, W. R. (2019). Penetration of wind-generated near-inertial waves into a turbulent ocean. J. Phys. Oceanogr., 49, 1699-1717.","category":"section"},{"location":"diagnostics/#Diagnostics","page":"-","title":"Diagnostics","text":"The Diagnostics module provides helpers for computing derived quantities and extracting slices.","category":"section"},{"location":"diagnostics/#Examples","page":"-","title":"Examples","text":"using QGYBJ\n\n# Create parameters with domain size (REQUIRED)\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0)  # 500km × 500km × 4km\nG, S, plans, a = setup_model(par)\n\n# Invert q → ψ and compute omega‑equation RHS\ninvert_q_to_psi!(S, G; a, par=par)\nrhs = similar(S.psi)\nomega_eqn_rhs!(rhs, S.psi, G, plans)\n\n# Wave energy (domain‑sum style)\nEB, EA = wave_energy(S.B, S.A)\n\n# Slices (back to real space internally)\nsl_xy = slice_horizontal(S.psi, G, plans; k=G.nz ÷ 2)\nsl_xz = slice_vertical_xz(S.psi, G, plans; j=G.ny ÷ 2)","category":"section"},{"location":"advanced/parallel_particles/#parallel-particles","page":"Parallel Particle Algorithm","title":"Parallel Particle Algorithm","text":"This page provides detailed technical documentation of the parallel particle advection algorithm in QGYBJ.jl.","category":"section"},{"location":"advanced/parallel_particles/#Overview","page":"Parallel Particle Algorithm","title":"Overview","text":"The parallel particle algorithm enables efficient Lagrangian particle tracking on distributed-memory systems using MPI. Key features:\n\n1D domain decomposition in x-direction\nHalo exchange for cross-boundary velocity interpolation\nAutomatic particle migration between MPI ranks\nNon-blocking MPI communication for efficiency\nLoad balancing as particles redistribute","category":"section"},{"location":"advanced/parallel_particles/#Domain-Decomposition","page":"Parallel Particle Algorithm","title":"Domain Decomposition","text":"","category":"section"},{"location":"advanced/parallel_particles/#Slab-Decomposition","page":"Parallel Particle Algorithm","title":"Slab Decomposition","text":"The physical domain [0, Lx] × [0, Ly] × [0, Lz] is partitioned into slabs along the x-direction:\n\n         Physical Domain\n┌─────────────────────────────────────────────────────────────────┐\n│                                                                 │\n│   x=0                                                     x=Lx  │\n│    │                                                        │   │\n│    ▼                                                        ▼   │\n│   ┌──────────┬──────────┬──────────┬──────────┬──────────┐      │\n│   │          │          │          │          │          │      │\n│   │  Rank 0  │  Rank 1  │  Rank 2  │  Rank 3  │  Rank 4  │      │\n│   │          │          │          │          │          │      │\n│   │ x ∈ [0,  │ x ∈ [L/5,│ x ∈ [2L/5│ x ∈ [3L/5│ x ∈ [4L/5│      │\n│   │    L/5)  │   2L/5)  │   3L/5)  │   4L/5)  │    L)    │      │\n│   │          │          │          │          │          │      │\n│   └──────────┴──────────┴──────────┴──────────┴──────────┘      │\n│                                                                 │\n│   • Each rank owns a contiguous x-range                         │\n│   • Full y and z dimensions on each rank                        │\n│   • Particles \"belong\" to the rank containing their x-position  │\n└─────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Local-Domain-Calculation","page":"Parallel Particle Algorithm","title":"Local Domain Calculation","text":"function compute_local_domain(grid::Grid, rank::Int, nprocs::Int)\n    # Base points per rank\n    nx_local = grid.nx ÷ nprocs\n    remainder = grid.nx % nprocs\n\n    # Handle uneven division (first 'remainder' ranks get +1 point)\n    if rank < remainder\n        nx_local += 1\n        x_start = rank * nx_local\n    else\n        x_start = remainder * (nx_local + 1) + (rank - remainder) * nx_local\n    end\n\n    x_end = x_start + nx_local - 1\n\n    # Convert grid indices to physical coordinates\n    dx = grid.Lx / grid.nx\n    x_start_phys = x_start * dx\n    x_end_phys = (x_end + 1) * dx\n\n    return (\n        x_start = x_start_phys,\n        x_end = x_end_phys,\n        y_start = 0.0,\n        y_end = grid.Ly,\n        z_start = 0.0,\n        z_end = grid.Lz,\n        nx_local = nx_local\n    )\nend\n\nExample: 256 grid points, 4 ranks → 64 points per rank\n\nRank Grid Indices Physical Range (Lx=2π)\n0 [0, 63] [0, π/2)\n1 [64, 127] [π/2, π)\n2 [128, 191] [π, 3π/2)\n3 [192, 255] [3π/2, 2π)","category":"section"},{"location":"advanced/parallel_particles/#Halo-Exchange","page":"Parallel Particle Algorithm","title":"Halo Exchange","text":"","category":"section"},{"location":"advanced/parallel_particles/#Purpose","page":"Parallel Particle Algorithm","title":"Purpose","text":"When a particle is near a domain boundary, velocity interpolation requires data from the neighboring rank. Halo regions (ghost cells) store copies of neighbor data.","category":"section"},{"location":"advanced/parallel_particles/#Extended-Array-Structure","page":"Parallel Particle Algorithm","title":"Extended Array Structure","text":"┌────────────────────────────────────────────────────────────────────────┐\n│                    EXTENDED ARRAY LAYOUT (Rank 1)                      │\n│                                                                        │\n│   Index:   1    2   ...  hw   hw+1  ...  hw+nx  hw+nx+1 ... hw+nx+hw   │\n│           ┌────┬────┬───┬────┬─────┬───┬───────┬───────┬───┬────────┐  │\n│           │    │    │   │    │     │   │       │       │   │        │  │\n│           │ Left Halo   │ ←── Local Data ──→   │ Right Halo│        │  │\n│           │ (from R0)   │      (owned)         │ (from R2) │        │  │\n│           └────┴────┴───┴────┴─────┴───┴───────┴───────┴───┴────────┘  │\n│                                                                        │\n│   hw = halo_width (default: 2)                                         │\n│   nx = local grid points                                               │\n│                                                                        │\n│   Total extended size: nx + 2*hw                                       │\n└────────────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Communication-Pattern-(Periodic-Boundaries)","page":"Parallel Particle Algorithm","title":"Communication Pattern (Periodic Boundaries)","text":"For doubly-periodic domains, the halo exchange wraps around:\n\n┌────────────────────────────────────────────────────────────────────────┐\n│                  PERIODIC HALO EXCHANGE COMMUNICATION                  │\n│                                                                        │\n│   RANK 0                 RANK 1                 RANK 2 (last)          │\n│   ┌──────────────┐       ┌──────────────┐       ┌──────────────┐       │\n│   │ L │ Local│ R │       │ L │ Local│ R │       │ L │ Local│ R │       │\n│   │   │      │   │       │   │      │   │       │   │      │   │       │\n│   └───┴──────┴───┘       └───┴──────┴───┘       └───┴──────┴───┘       │\n│     ↑                                                      │           │\n│     └──────────────── Periodic wrap ──────────────────────┘           │\n│                                                                        │\n│   Interior Communication (same as before):                             │\n│   ═════════════════════════════════════                                │\n│   Rank 0 → Rank 1:  send_right → recv_left                             │\n│   Rank 1 → Rank 0:  send_left  → recv_right                            │\n│   Rank 1 → Rank 2:  send_right → recv_left                             │\n│   Rank 2 → Rank 1:  send_left  → recv_right                            │\n│                                                                        │\n│   Periodic Boundary Communication:                                     │\n│   ════════════════════════════════                                     │\n│   Rank 2 → Rank 0:  send_right (R2's right edge) → recv_left (R0)      │\n│   Rank 0 → Rank 2:  send_left  (R0's left edge)  → recv_right (R2)     │\n│                                                                        │\n│   After exchange:                                                      │\n│   • R0's left halo contains R2's right edge data (periodic wrap!)      │\n│   • R2's right halo contains R0's left edge data (periodic wrap!)      │\n│   • All particles can interpolate correctly near boundaries            │\n└────────────────────────────────────────────────────────────────────────┘\n\nKey: With periodic_x=true (default), rank 0's left neighbor is the last rank, and the last rank's right neighbor is rank 0. This ensures correct velocity interpolation for particles near the periodic boundaries.","category":"section"},{"location":"advanced/parallel_particles/#Implementation","page":"Parallel Particle Algorithm","title":"Implementation","text":"function exchange_velocity_halos!(halo_info, u_field, v_field, w_field)\n    # 1. Copy local data to center of extended arrays\n    copy_local_to_extended!(halo_info, u_field, v_field, w_field)\n\n    # 2. Pack boundary data into send buffers\n    pack_halo_data!(halo_info)\n    # send_left  ← our LEFT edge  (for left neighbor's RIGHT halo)\n    # send_right ← our RIGHT edge (for right neighbor's LEFT halo)\n\n    # 3. Post non-blocking receives\n    if left_neighbor >= 0\n        MPI.Irecv!(recv_left, left_neighbor, tag=0, comm)\n    end\n    if right_neighbor >= 0\n        MPI.Irecv!(recv_right, right_neighbor, tag=1, comm)\n    end\n\n    # 4. Send to neighbors (non-blocking)\n    if right_neighbor >= 0\n        MPI.Isend(send_right, right_neighbor, tag=0, comm)\n    end\n    if left_neighbor >= 0\n        MPI.Isend(send_left, left_neighbor, tag=1, comm)\n    end\n\n    # 5. Wait for receives and unpack\n    MPI.Waitall(recv_reqs)\n    unpack_halo_data!(halo_info)\n    # recv_left  → our LEFT halo region\n    # recv_right → our RIGHT halo region\n\n    # 6. Wait for sends to complete\n    MPI.Waitall(send_reqs)\nend","category":"section"},{"location":"advanced/parallel_particles/#Buffer-Layout","page":"Parallel Particle Algorithm","title":"Buffer Layout","text":"Each buffer contains packed velocity components:\n\nBuffer layout: [u₁, v₁, w₁, u₂, v₂, w₂, ..., uₙ, vₙ, wₙ]\n\nwhere n = halo_width × ny × nz\n\nTotal buffer size = 3 × halo_width × ny × nz × sizeof(T)","category":"section"},{"location":"advanced/parallel_particles/#Particle-Migration","page":"Parallel Particle Algorithm","title":"Particle Migration","text":"","category":"section"},{"location":"advanced/parallel_particles/#When-Migration-Occurs","page":"Parallel Particle Algorithm","title":"When Migration Occurs","text":"After advection, particles may have moved outside their owning rank's domain:\n\n┌────────────────────────────────────────────────────────────────────────┐\n│                     PARTICLE CROSSING BOUNDARY                         │\n│                                                                        │\n│   Before advection:                                                    │\n│   ┌───────────────────────┬───────────────────────┐                    │\n│   │       RANK 0          │       RANK 1          │                    │\n│   │                    •  │                       │                    │\n│   │                   ↗   │                       │                    │\n│   │     Particle moving   │                       │                    │\n│   │     toward boundary   │                       │                    │\n│   └───────────────────────┴───────────────────────┘                    │\n│                                                                        │\n│   After advection:                                                     │\n│   ┌───────────────────────┬───────────────────────┐                    │\n│   │       RANK 0          │       RANK 1          │                    │\n│   │                       │  •                    │                    │\n│   │                       │  ↑ Particle now in    │                    │\n│   │                       │    Rank 1's domain    │                    │\n│   └───────────────────────┴───────────────────────┘                    │\n│                                                                        │\n│   → Particle must be migrated from Rank 0 to Rank 1                    │\n└────────────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Migration-Algorithm","page":"Parallel Particle Algorithm","title":"Migration Algorithm","text":"function migrate_particles!(tracker)\n    particles = tracker.particles\n    local_domain = tracker.local_domain\n\n    # 1. Clear send buffers\n    for buf in tracker.send_buffers\n        empty!(buf)\n    end\n\n    # 2. Identify particles to keep vs migrate\n    keep_indices = Int[]\n\n    for i in 1:particles.np\n        x = particles.x[i]\n        target_rank = find_target_rank(x, tracker)\n\n        if target_rank == tracker.rank\n            # Particle stays local\n            push!(keep_indices, i)\n        else\n            # Package particle for migration: [x, y, z, u, v, w]\n            particle_data = [\n                particles.x[i], particles.y[i], particles.z[i],\n                particles.u[i], particles.v[i], particles.w[i]\n            ]\n            append!(tracker.send_buffers[target_rank + 1], particle_data)\n        end\n    end\n\n    # 3. Remove migrated particles from local arrays\n    particles.x = particles.x[keep_indices]\n    particles.y = particles.y[keep_indices]\n    # ... same for z, u, v, w\n    particles.np = length(keep_indices)\n\n    # 4. Exchange particle data via MPI\n    exchange_particles!(tracker)\n\n    # 5. Add received particles to local collection\n    add_received_particles!(tracker)\nend\n\nfunction find_target_rank(x, tracker)\n    # Handle periodic boundary\n    x_periodic = tracker.config.periodic_x ? mod(x, tracker.Lx) : x\n\n    # Determine owning rank based on x-position\n    dx_rank = tracker.Lx / tracker.nprocs\n    rank = min(tracker.nprocs - 1, floor(Int, x_periodic / dx_rank))\n\n    return rank\nend","category":"section"},{"location":"advanced/parallel_particles/#All-to-All-Communication","page":"Parallel Particle Algorithm","title":"All-to-All Communication","text":"function exchange_particles!(tracker)\n    comm = tracker.comm\n    nprocs = tracker.nprocs\n\n    # 1. Exchange particle counts (how many to send to each rank)\n    send_counts = [length(tracker.send_buffers[i]) ÷ 6 for i in 1:nprocs]\n    recv_counts = MPI.Alltoall(send_counts, comm)\n\n    # 2. Point-to-point sends/receives for particle data\n    for other_rank in 0:nprocs-1\n        if other_rank == tracker.rank\n            continue\n        end\n\n        # Send to other_rank\n        if !isempty(tracker.send_buffers[other_rank + 1])\n            MPI.Send(tracker.send_buffers[other_rank + 1], other_rank, tag=0, comm)\n        end\n\n        # Receive from other_rank\n        if recv_counts[other_rank + 1] > 0\n            n_values = recv_counts[other_rank + 1] * 6\n            recv_data = Vector{T}(undef, n_values)\n            MPI.Recv!(recv_data, other_rank, tag=0, comm)\n            tracker.recv_buffers[other_rank + 1] = recv_data\n        end\n    end\nend","category":"section"},{"location":"advanced/parallel_particles/#Complete-Parallel-Timestep","page":"Parallel Particle Algorithm","title":"Complete Parallel Timestep","text":"┌──────────────────────────────────────────────────────────────────────────────┐\n│              PARALLEL PARTICLE ADVECTION TIMESTEP                            │\n│                                                                              │\n│  ┌────────────────────────────────────────────────────────────────────────┐  │\n│  │ STEP 1: UPDATE VELOCITY FIELDS                                         │  │\n│  │                                                                        │  │\n│  │   • Compute geostrophic velocities (distributed FFT):                  │  │\n│  │       û = -i·kᵧ·ψ̂,  v̂ = i·kₓ·ψ̂                                         │  │\n│  │                                                                        │  │\n│  │   • Solve omega equation for w (tridiagonal in z):                     │  │\n│  │       ∇²w + (N²/f²)∂²w/∂z² = 2·J(ψ_z, ∇²ψ)                             │  │\n│  │                                                                        │  │\n│  │   • Add wave Stokes drift (horizontal + vertical):                     │  │\n│  │       u += 2·Re[A*·∂A/∂x],  v += 2·Re[A*·∂A/∂y],  w += 2·Re[A*·∂A/∂z]  │  │\n│  │                                                                        │  │\n│  │   • Exchange velocity halos (MPI non-blocking)                         │  │\n│  └────────────────────────────────────────────────────────────────────────┘  │ \n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 2: ADVECT PARTICLES (each rank independently)              │         │\n│  │                                                                 │         │\n│  │   For each local particle:                                      │         │\n│  │     1. Interpolate velocity at (x, y, z)                        │         │\n│  │        • Use extended arrays (halos) if near boundary           │         │\n│  │        • Trilinear/Tricubic/Quintic interpolation               │         │\n│  │                                                                 │         │\n│  │     2. Time integration:                                        │         │\n│  │        • Euler:  x_{n+1} = x_n + dt·u                           │         │\n│  │        • RK2:    Midpoint method                                │         │\n│  │        • RK4:    Classical 4th order                            │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 3: MIGRATE PARTICLES                                       │         │\n│  │                                                                 │         │\n│  │   1. Identify particles outside local domain                    │         │\n│  │   2. Pack outgoing particles into send buffers                  │         │\n│  │   3. MPI.Alltoall - exchange particle counts                    │         │\n│  │   4. MPI.Send/Recv - transfer particle data                     │         │\n│  │   5. Unpack incoming particles into local arrays                │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 4: APPLY BOUNDARY CONDITIONS                               │         │\n│  │                                                                 │         │\n│  │   Horizontal (periodic):  x = mod(x, Lx),  y = mod(y, Ly)       │         │\n│  │                                                                 │         │\n│  │   Vertical (reflective):                                        │         │\n│  │     if z < 0:   z = -z,        w = -w                           │         │\n│  │     if z > Lz:  z = 2·Lz - z,  w = -w                           │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n│                                ↓                                             │\n│  ┌─────────────────────────────────────────────────────────────────┐         │\n│  │ STEP 5: SAVE TRAJECTORIES (if save_interval reached)            │         │\n│  │                                                                 │         │\n│  │   Option A: Each rank saves local particles independently       │         │\n│  │   Option B: Gather all particles to rank 0, unified output      │         │\n│  └─────────────────────────────────────────────────────────────────┘         │\n└──────────────────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/parallel_particles/#Scalability-Analysis","page":"Parallel Particle Algorithm","title":"Scalability Analysis","text":"","category":"section"},{"location":"advanced/parallel_particles/#Communication-Costs","page":"Parallel Particle Algorithm","title":"Communication Costs","text":"Operation Data Volume Frequency\nHalo exchange O(ny × nz × halo_width × 3) per neighbor Every timestep\nMigration Alltoall O(nprocs) integers Every timestep\nMigration Send/Recv O(Np_crossing × 6) floats Every timestep","category":"section"},{"location":"advanced/parallel_particles/#Scaling-Characteristics","page":"Parallel Particle Algorithm","title":"Scaling Characteristics","text":"Strong Scaling (fixed problem size, varying ranks):\n\nVelocity computation: ~O(N/P) per rank\nParticle advection: ~O(Np/P) per rank\nCommunication: O(boundary_size) - increases relative importance\n\nWeak Scaling (fixed load per rank):\n\nIdeal scaling if particles are uniformly distributed\nLoad imbalance if particles cluster in few ranks","category":"section"},{"location":"advanced/parallel_particles/#Load-Balancing-Considerations","page":"Parallel Particle Algorithm","title":"Load Balancing Considerations","text":"Particle load can become imbalanced if:\n\nFlow concentrates particles (e.g., in eddies)\nInitial distribution is non-uniform\nSome ranks have many boundary crossings\n\nMitigation strategies:\n\nUse sufficiently many particles for statistical averaging\nInitialize particles uniformly\nMonitor particle count per rank","category":"section"},{"location":"advanced/parallel_particles/#Data-Structures","page":"Parallel Particle Algorithm","title":"Data Structures","text":"","category":"section"},{"location":"advanced/parallel_particles/#HaloInfo","page":"Parallel Particle Algorithm","title":"HaloInfo","text":"mutable struct HaloInfo{T}\n    halo_width::Int              # Ghost cell width (default: 2)\n\n    # Extended arrays with halos\n    u_extended::Array{T,3}       # Size: (nx_local + 2*hw, ny, nz)\n    v_extended::Array{T,3}\n    w_extended::Array{T,3}\n\n    # Local data position in extended arrays\n    local_start::NTuple{3,Int}   # (hw+1, 1, 1)\n    local_end::NTuple{3,Int}     # (hw+nx, ny, nz)\n\n    # Neighbor ranks (-1 if at boundary)\n    left_neighbor::Int\n    right_neighbor::Int\n\n    # Communication buffers\n    send_left::Vector{T}         # Size: 3 × hw × ny × nz\n    send_right::Vector{T}\n    recv_left::Vector{T}\n    recv_right::Vector{T}\n\n    # MPI info\n    comm::Any\n    rank::Int\n    nprocs::Int\nend","category":"section"},{"location":"advanced/parallel_particles/#ParticleTracker-(Parallel-Fields)","page":"Parallel Particle Algorithm","title":"ParticleTracker (Parallel Fields)","text":"mutable struct ParticleTracker{T}\n    # ... common fields ...\n\n    # MPI configuration\n    comm::Any                    # MPI.COMM_WORLD\n    rank::Int                    # This process's rank\n    nprocs::Int                  # Total processes\n    is_parallel::Bool            # true if nprocs > 1\n\n    # Domain decomposition\n    local_domain::NamedTuple     # (x_start, x_end, y_start, y_end, ...)\n\n    # Halo exchange\n    halo_info::HaloInfo{T}       # Extended arrays + buffers\n\n    # Migration buffers (one per rank)\n    send_buffers::Vector{Vector{T}}  # Length: nprocs\n    recv_buffers::Vector{Vector{T}}  # Length: nprocs\n\n    # I/O configuration\n    is_io_rank::Bool             # true if rank == 0\n    gather_for_io::Bool          # Gather particles to rank 0 for output\nend","category":"section"},{"location":"advanced/parallel_particles/#Usage-Example","page":"Parallel Particle Algorithm","title":"Usage Example","text":"using MPI\nusing QGYBJ\n\n# Initialize MPI\nMPI.Init()\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\nnprocs = MPI.Comm_size(comm)\n\n# Set up parallel configuration\nparallel_config = ParallelConfig(\n    use_mpi = true,\n    comm = comm,\n    n_processes = nprocs\n)\n\n# Create simulation (distributed grid and state)\nconfig = SimulationConfig(...)\nsim = setup_simulation(config; parallel_config=parallel_config)\n\n# Create particle configuration\nparticle_config = create_particle_config(\n    x_min = 0.0, x_max = 2π,\n    y_min = 0.0, y_max = 2π,\n    z_level = π,\n    nx_particles = 100,\n    ny_particles = 100,\n    integration_method = :rk4,\n    interpolation_method = TRILINEAR\n)\n\n# Create particle tracker with parallel support\ntracker = ParticleTracker(particle_config, sim.grid, parallel_config)\ninitialize_particles!(tracker, particle_config)\n\n# Main simulation loop\nfor step in 1:nsteps\n    # Advance fluid state\n    timestep!(sim)\n\n    # Advect particles (handles halo exchange + migration automatically)\n    advect_particles!(tracker, sim.state, sim.grid, dt, sim.current_time)\nend\n\n# Save trajectories (rank 0 gathers and writes, or each rank writes independently)\nif rank == 0 || !tracker.gather_for_io\n    write_particle_trajectories(\"particles_rank$(rank).nc\", tracker)\nend\n\nMPI.Finalize()","category":"section"},{"location":"advanced/parallel_particles/#Debugging-Tips","page":"Parallel Particle Algorithm","title":"Debugging Tips","text":"","category":"section"},{"location":"advanced/parallel_particles/#Check-Particle-Distribution","page":"Parallel Particle Algorithm","title":"Check Particle Distribution","text":"# Print particle count per rank\nprintln(\"Rank $rank has $(tracker.particles.np) particles\")\nMPI.Barrier(comm)","category":"section"},{"location":"advanced/parallel_particles/#Verify-Halo-Exchange","page":"Parallel Particle Algorithm","title":"Verify Halo Exchange","text":"# After halo exchange, check extended array values\nif rank == 0\n    println(\"Left halo (should be from neighbor): \", halo_info.u_extended[1:2, 1, 1])\n    println(\"Local data start: \", halo_info.u_extended[3:4, 1, 1])\nend","category":"section"},{"location":"advanced/parallel_particles/#Monitor-Migration","page":"Parallel Particle Algorithm","title":"Monitor Migration","text":"# Track particles crossing boundaries\nn_migrated = sum(length.(tracker.send_buffers)) ÷ 6\nprintln(\"Rank $rank migrating $n_migrated particles\")","category":"section"},{"location":"advanced/parallel_particles/#See-Also","page":"Parallel Particle Algorithm","title":"See Also","text":"Particle Advection - General particle documentation\nMPI Parallelization - Overall parallel architecture\nAPI Reference - Function documentation","category":"section"},{"location":"api/#api-index","page":"Full Index","title":"API Reference","text":"Complete API reference for QGYBJ.jl.","category":"section"},{"location":"api/#Quick-Links","page":"Full Index","title":"Quick Links","text":"Core Types: QGParams, Grid, State\nGrid & State: Initialization and utilities\nPhysics Functions: Inversions, operators, diagnostics\nTime Stepping: Leapfrog integration\nParticles: Lagrangian particle tracking","category":"section"},{"location":"api/#Module-Structure","page":"Full Index","title":"Module Structure","text":"QGYBJ\n├── Core Types\n│   ├── QGParams      # Model parameters\n│   ├── Grid          # Spatial grid and wavenumbers\n│   └── State         # Prognostic/diagnostic fields\n├── Physics\n│   ├── elliptic.jl   # Tridiagonal inversions\n│   ├── nonlinear.jl  # Jacobians, refraction, qw\n│   ├── operators.jl  # Velocities\n│   └── transforms.jl # FFT wrappers\n├── Time Stepping\n│   └── timestep.jl   # Leapfrog with Robert-Asselin\n├── YBJ Normal Mode\n│   └── ybj_normal.jl # sumB!, compute_sigma, compute_A!\n├── Diagnostics\n│   └── diagnostics.jl # Energy, omega equation\n├── Particles\n│   └── particles/    # Lagrangian tracking\n└── I/O\n    └── netcdf_io.jl  # NetCDF output","category":"section"},{"location":"api/#Naming-Conventions","page":"Full Index","title":"Naming Conventions","text":"Suffix Meaning Example\n! In-place modification compute_velocities!\n_spectral Operates in spectral space jacobian_spectral!\n_waqg Wave-related convol_waqg!\n_mpi MPI-enabled version init_mpi_grid","category":"section"},{"location":"api/#Main-Entry-Points","page":"Full Index","title":"Main Entry Points","text":"","category":"section"},{"location":"api/#Setup","page":"Full Index","title":"Setup","text":"# Create parameters\npar = default_params(nx=64, ny=64, nz=32)\n\n# Initialize everything at once\nG, S, plans, a = setup_model(; par)","category":"section"},{"location":"api/#Time-Stepping","page":"Full Index","title":"Time Stepping","text":"# Initial projection step\nfirst_projection_step!(S, G, par, plans; a=a, dealias_mask=L)\n\n# Leapfrog steps\nleapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a, dealias_mask=L)","category":"section"},{"location":"api/#MPI-Parallel-Mode","page":"Full Index","title":"MPI Parallel Mode","text":"using MPI, PencilArrays, PencilFFTs, QGYBJ\nMPI.Init()\nmpi_config = setup_mpi_environment()\nG = init_mpi_grid(par, mpi_config)\nS = init_mpi_state(G, mpi_config)\n\nSee individual pages for detailed API documentation.","category":"section"},{"location":"physics/qg_equations/#qg-equations","page":"QG Equations","title":"QG Equations","text":"This page details the quasi-geostrophic (QG) equations implemented in QGYBJ.jl.","category":"section"},{"location":"physics/qg_equations/#Potential-Vorticity-Evolution","page":"QG Equations","title":"Potential Vorticity Evolution","text":"The core QG equation is the conservation of potential vorticity:\n\nfracpartial qpartial t + J(psi q) = mathcalD_q + mathcalF_q\n\nwhere mathcalD_q is dissipation and mathcalF_q is forcing.","category":"section"},{"location":"physics/qg_equations/#Potential-Vorticity-Definition","page":"QG Equations","title":"Potential Vorticity Definition","text":"q = underbracenabla^2psi_textrelative vorticity + underbracefracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright)_textstretching term\n\nFor uniform stratification (N^2 = textconst):\n\nq = nabla^2psi + fracf_0^2N^2fracpartial^2psipartial z^2","category":"section"},{"location":"physics/qg_equations/#Physical-Interpretation","page":"QG Equations","title":"Physical Interpretation","text":"Term Physical Meaning\nnabla^2psi Relative vorticity zeta\n(f_0^2N^2)partial_z^2psi Vortex stretching due to vertical motion\nJ(psi q) Advection of PV by geostrophic flow","category":"section"},{"location":"physics/qg_equations/#Streamfunction-Inversion","page":"QG Equations","title":"Streamfunction Inversion","text":"Given q, we solve for psi via the elliptic equation:\n\nnabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q","category":"section"},{"location":"physics/qg_equations/#Spectral-Representation","page":"QG Equations","title":"Spectral Representation","text":"In spectral space (horizontal) with vertical finite differences:\n\n-k_h^2 hatpsi + fracpartialpartial zleft(a(z)fracpartialhatpsipartial zright) = hatq\n\nwhere:\n\nk_h^2 = k_x^2 + k_y^2 (horizontal wavenumber squared)\na(z) = f_0^2N^2(z) (stretching coefficient)","category":"section"},{"location":"physics/qg_equations/#Tridiagonal-System","page":"QG Equations","title":"Tridiagonal System","text":"For each horizontal wavenumber (k_x k_y), the vertical discretization gives:\n\na_k hatpsi_k-1 + b_k hatpsi_k + c_k hatpsi_k+1 = hatq_k\n\nThis is solved efficiently with the Thomas algorithm in O(nz) operations.","category":"section"},{"location":"physics/qg_equations/#Boundary-Conditions","page":"QG Equations","title":"Boundary Conditions","text":"Top and Bottom: fracpartialpsipartial z = 0 (no buoyancy flux)\n\nIn the code:\n\n# Called for each time step\ninvert_q_to_psi!(state, grid, params, a_ell)","category":"section"},{"location":"physics/qg_equations/#Velocity-Fields","page":"QG Equations","title":"Velocity Fields","text":"","category":"section"},{"location":"physics/qg_equations/#Geostrophic-Velocities","page":"QG Equations","title":"Geostrophic Velocities","text":"From geostrophic balance:\n\nu = -fracpartialpsipartial y quad v = fracpartialpsipartial x\n\nIn spectral space:\n\nhatu = -ik_yhatpsi quad hatv = ik_xhatpsi","category":"section"},{"location":"physics/qg_equations/#Vertical-Velocity","page":"QG Equations","title":"Vertical Velocity","text":"The QG omega equation gives the ageostrophic vertical velocity:\n\nnabla^2 w + fracN^2f_0^2fracpartial^2 wpartial z^2 = 2Jleft(fracpartialpsipartial z nabla^2psiright)\n\nThe RHS represents frontogenesis/frontolysis forcing.","category":"section"},{"location":"physics/qg_equations/#Jacobian-Operator","page":"QG Equations","title":"Jacobian Operator","text":"The Jacobian J(a b) is computed pseudo-spectrally:\n\nJ(a b) = fracpartial apartial xfracpartial bpartial y - fracpartial apartial yfracpartial bpartial x","category":"section"},{"location":"physics/qg_equations/#Algorithm","page":"QG Equations","title":"Algorithm","text":"Compute partial apartial x, partial apartial y in spectral space\nTransform to physical space\nMultiply in physical space\nTransform back to spectral space\nApply dealiasing (2/3 rule)","category":"section"},{"location":"physics/qg_equations/#Conservation-Properties","page":"QG Equations","title":"Conservation Properties","text":"The Jacobian satisfies:\n\nint J(a b)  dA = 0 (integral vanishes)\nJ(a a) = 0 (anti-symmetry)\n\nThese ensure energy and enstrophy conservation in the inviscid limit.","category":"section"},{"location":"physics/qg_equations/#Dissipation","page":"QG Equations","title":"Dissipation","text":"","category":"section"},{"location":"physics/qg_equations/#Hyperdiffusion","page":"QG Equations","title":"Hyperdiffusion","text":"The model uses scale-selective hyperdiffusion:\n\nmathcalD_q = -nu_h1(-nabla^2)^p_1 q - nu_h2(-nabla^2)^p_2 q - nu_zfracpartial^2 qpartial z^2\n\nwhere:\n\nnu_h1 p_1: Large-scale dissipation (drag)\nnu_h2 p_2: Small-scale dissipation (hyperviscosity)\nnu_z: Vertical diffusion","category":"section"},{"location":"physics/qg_equations/#Integrating-Factor-Method","page":"QG Equations","title":"Integrating Factor Method","text":"To handle stiff diffusion, we use integrating factors:\n\ntildeq = q cdot e^nu k^2p Delta t\n\nThis allows larger time steps while maintaining stability.","category":"section"},{"location":"physics/qg_equations/#Wave-Feedback","page":"QG Equations","title":"Wave Feedback","text":"When waves are present, the QG equation includes a feedback term through a modified effective PV.","category":"section"},{"location":"physics/qg_equations/#The-Wave-Feedback-Mechanism","page":"QG Equations","title":"The Wave Feedback Mechanism","text":"The wave-induced PV q^w is computed from the wave envelope B:\n\nq^w = fraci2 J(B^* B) - frac14 nabla_h^2 B^2\n\nwhere B = B_R + i B_I is the complex wave envelope with units of velocity (m/s).\n\nnote: Dimensional Equations\nThe model solves dimensional equations where B has actual velocity amplitude. No additional scaling factors are needed.","category":"section"},{"location":"physics/qg_equations/#Effective-PV-for-Inversion","page":"QG Equations","title":"Effective PV for Inversion","text":"The streamfunction is obtained by inverting the effective PV:\n\nq^* = q - q^w\n\nnabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q^*\n\nThis means the wave feedback modifies the inversion rather than appearing as an explicit advection term.\n\nSee Wave-Mean Interaction for detailed formulas and implementation.","category":"section"},{"location":"physics/qg_equations/#Implementation","page":"QG Equations","title":"Implementation","text":"","category":"section"},{"location":"physics/qg_equations/#Key-Functions","page":"QG Equations","title":"Key Functions","text":"The QG equation implementation uses these core functions:\n\ninvert_q_to_psi! - Solve elliptic equation for streamfunction\njacobian_spectral! - Compute Jacobian pseudo-spectrally\ncompute_velocities! - Get (u, v) from streamfunction\n\nSee the Physics API Reference for detailed documentation.","category":"section"},{"location":"physics/qg_equations/#Code-Location","page":"QG Equations","title":"Code Location","text":"elliptic.jl: Streamfunction inversion (invert_q_to_psi!)\nnonlinear.jl: Jacobian computation (jacobian_spectral!)\noperators.jl: Velocity computation (compute_velocities!)","category":"section"},{"location":"physics/qg_equations/#References","page":"QG Equations","title":"References","text":"Vallis, G. K. (2017). Atmospheric and Oceanic Fluid Dynamics. Cambridge University Press.\nPedlosky, J. (1987). Geophysical Fluid Dynamics. Springer.","category":"section"},{"location":"advanced/particles/#particles","page":"Particle Advection","title":"Particle Advection","text":"This page describes Lagrangian particle tracking in QGYBJ.jl, including the physics, numerical algorithms, and parallel implementation.","category":"section"},{"location":"advanced/particles/#Overview","page":"Particle Advection","title":"Overview","text":"Particle tracking allows you to:\n\nFollow fluid parcels as they move with the flow\nCompute Lagrangian statistics (dispersion, diffusivity)\nTrack tracer concentrations along trajectories\nStudy mixing and transport in QG-YBJ+ dynamics","category":"section"},{"location":"advanced/particles/#Physics-of-Particle-Advection","page":"Particle Advection","title":"Physics of Particle Advection","text":"","category":"section"},{"location":"advanced/particles/#Total-Velocity-Field","page":"Particle Advection","title":"Total Velocity Field","text":"In QG-YBJ+ dynamics, particles are advected by the total velocity field consisting of:\n\n1. Geostrophic Flow (from streamfunction ψ):\n\nu_QG = -fracpartial psipartial y quad v_QG = fracpartial psipartial x\n\n2. Wave-Induced Stokes Drift (from wave amplitude A):\n\nHorizontal Stokes Drift:\n\nu_wave = 2textReleftA^* fracpartial Apartial xright = fracpartial A^2partial x\n\nv_wave = 2textReleftA^* fracpartial Apartial yright = fracpartial A^2partial y\n\nVertical Stokes Drift:\n\nw_wave = 2textReleftA^* fracpartial Apartial zright = fracpartial A^2partial z\n\nThe vertical derivative ∂A/∂z is computed by invert_B_to_A! and stored in S.C.\n\n3. QG Vertical Velocity (from omega equation):\n\nnabla^2 w_QG + fracN^2f^2fracpartial^2 w_QGpartial z^2 = 2J(psi_z nabla^2psi)\n\n4. YBJ Vertical Velocity (alternative wave-induced formulation):\n\nw_YBJ = -fracf^2N^2leftleft(fracpartial Apartial xright)_z - ileft(fracpartial Apartial yright)_zright + textcc\n\nThis is controlled by the use_ybj_w option. When use_ybj_w=true, this wave-induced vertical velocity is used instead of solving the QG omega equation.","category":"section"},{"location":"advanced/particles/#Total-Velocity","page":"Particle Advection","title":"Total Velocity","text":"The complete velocity used for particle advection is:\n\nmathbfu_total = (u_QG + u_wave v_QG + v_wave w + w_wave)\n\nwhere w is either w_QG (from omega equation) or w_YBJ (wave-induced) depending on the use_ybj_w setting.\n\nThis includes both horizontal and vertical Stokes drift, ensuring particles are correctly advected by the full wave-induced velocity field.","category":"section"},{"location":"advanced/particles/#Quick-Start","page":"Particle Advection","title":"Quick Start","text":"","category":"section"},{"location":"advanced/particles/#Basic-Setup","page":"Particle Advection","title":"Basic Setup","text":"using QGYBJ\n\n# Create simulation configuration\nconfig = SimulationConfig(\n    domain = DomainConfig(nx=128, ny=128, nz=64),\n    # ... other settings\n)\n\n# Set up simulation\nsim = setup_simulation(config)\n\n# Create particle configuration (100 particles in a box at z = π/2)\nparticle_config = particles_in_box(π/2;\n    nx=10, ny=10,\n    integration_method=:rk4,\n    interpolation_method=TRILINEAR,\n    save_interval=0.1\n)\n\n# Create particle tracker\ntracker = ParticleTracker(particle_config, sim.grid)\ninitialize_particles!(tracker, particle_config)\n\n# Advect particles during simulation\nfor step in 1:nsteps\n    timestep!(sim)\n    advect_particles!(tracker, sim.state, sim.grid, dt, sim.current_time)\nend\n\n# Save trajectories\nwrite_particle_trajectories(\"particles.nc\", tracker)","category":"section"},{"location":"advanced/particles/#Time-Integration-Methods","page":"Particle Advection","title":"Time Integration Methods","text":"Three integration schemes are available:","category":"section"},{"location":"advanced/particles/#Euler-Method-(1st-order)","page":"Particle Advection","title":"Euler Method (1st order)","text":"mathbfx_n+1 = mathbfx_n + Delta t cdot mathbfu(mathbfx_n t_n)\n\nconfig = particles_in_box(π/2; integration_method=:euler)","category":"section"},{"location":"advanced/particles/#RK2-Midpoint-Method-(2nd-order)","page":"Particle Advection","title":"RK2 Midpoint Method (2nd order)","text":"beginaligned\nmathbfk_1 = mathbfu(mathbfx_n t_n) \nmathbfx_mid = mathbfx_n + fracDelta t2 mathbfk_1 \nmathbfk_2 = mathbfu(mathbfx_mid t_n + fracDelta t2) \nmathbfx_n+1 = mathbfx_n + Delta t cdot mathbfk_2\nendaligned\n\nconfig = particles_in_box(π/2; integration_method=:rk2)","category":"section"},{"location":"advanced/particles/#RK4-Classical-Method-(4th-order)","page":"Particle Advection","title":"RK4 Classical Method (4th order)","text":"beginaligned\nmathbfk_1 = mathbfu(mathbfx_n t_n) \nmathbfk_2 = mathbfu(mathbfx_n + fracDelta t2mathbfk_1 t_n + fracDelta t2) \nmathbfk_3 = mathbfu(mathbfx_n + fracDelta t2mathbfk_2 t_n + fracDelta t2) \nmathbfk_4 = mathbfu(mathbfx_n + Delta tmathbfk_3 t_n + Delta t) \nmathbfx_n+1 = mathbfx_n + fracDelta t6(mathbfk_1 + 2mathbfk_2 + 2mathbfk_3 + mathbfk_4)\nendaligned\n\nconfig = particles_in_box(π/2; integration_method=:rk4)\n\nMethod Order Velocity Evaluations/Step Recommended Use\n:euler 1 1 Quick tests, large dt\n:rk2 2 2 Balance of speed/accuracy\n:rk4 4 4 High accuracy studies","category":"section"},{"location":"advanced/particles/#Interpolation-Methods","page":"Particle Advection","title":"Interpolation Methods","text":"Velocity must be interpolated from the grid to particle positions.","category":"section"},{"location":"advanced/particles/#Trilinear-(Default)","page":"Particle Advection","title":"Trilinear (Default)","text":"Stencil: 2×2×2 = 8 points\nOrder: O(h²)\nSmoothness: C⁰ continuous\n\nconfig = particles_in_box(π/2; interpolation_method=TRILINEAR)","category":"section"},{"location":"advanced/particles/#Tricubic","page":"Particle Advection","title":"Tricubic","text":"Stencil: 4×4×4 = 64 points (Catmull-Rom splines)\nOrder: O(h⁴)\nSmoothness: C¹ continuous\n\nconfig = particles_in_box(π/2; interpolation_method=TRICUBIC)","category":"section"},{"location":"advanced/particles/#Quintic","page":"Particle Advection","title":"Quintic","text":"Stencil: 6×6×6 = 216 points (B-splines)\nOrder: O(h⁶)\nSmoothness: C⁴ continuous\n\nconfig = particles_in_box(π/2; interpolation_method=QUINTIC)","category":"section"},{"location":"advanced/particles/#Adaptive","page":"Particle Advection","title":"Adaptive","text":"Automatically selects trilinear or tricubic based on local field smoothness.\n\nconfig = particles_in_box(π/2; interpolation_method=ADAPTIVE)\n\nMethod Points Error Best For\nTRILINEAR 8 O(h²) Speed, rough fields\nTRICUBIC 64 O(h⁴) Accuracy, smooth fields\nQUINTIC 216 O(h⁶) Highest accuracy\nADAPTIVE 8-64 Variable Mixed conditions","category":"section"},{"location":"advanced/particles/#Particle-Initialization","page":"Particle Advection","title":"Particle Initialization","text":"QGYBJ.jl provides simple, intuitive constructors for initializing particles:\n\nConstructor Description\nparticles_in_box(z; ...) Uniform grid in a 2D rectangular box at fixed z\nparticles_in_circle(z; ...) Circular disk at fixed z (sunflower/rings/random)\nparticles_in_grid_3d(; ...) Uniform 3D rectangular grid\nparticles_in_layers(z_levels; ...) Multiple 2D grids at different z-levels\nparticles_random_3d(n; ...) Random distribution in 3D volume\nparticles_custom(positions; ...) User-specified positions","category":"section"},{"location":"advanced/particles/#Particles-in-a-Box-(2D-at-fixed-z)","page":"Particle Advection","title":"Particles in a Box (2D at fixed z)","text":"# 100 particles (10×10) in a box at z = π/2\nconfig = particles_in_box(π/2; nx=10, ny=10)\n\n# Custom domain\nconfig = particles_in_box(π/2;\n    x_min=π/4, x_max=7π/4,\n    y_min=π/4, y_max=7π/4,\n    nx=20, ny=20              # 400 particles\n)","category":"section"},{"location":"advanced/particles/#Particles-in-a-Circle-(2D-at-fixed-z)","page":"Particle Advection","title":"Particles in a Circle (2D at fixed z)","text":"# 100 particles in a circle of radius 1.0 at z = π/2\nconfig = particles_in_circle(π/2; radius=1.0, n=100)\n\n# Custom center and pattern\nconfig = particles_in_circle(1.0;\n    center=(2.0, 2.0),        # Circle center\n    radius=1.5,\n    n=200,\n    pattern=:sunflower        # :sunflower, :rings, or :random\n)\n\nAvailable patterns:\n\n:sunflower - Fibonacci spiral (very uniform, recommended)\n:rings - Concentric rings\n:random - Uniform random within disk","category":"section"},{"location":"advanced/particles/#Particles-in-a-3D-Grid","page":"Particle Advection","title":"Particles in a 3D Grid","text":"# 500 particles in a 10×10×5 grid\nconfig = particles_in_grid_3d(; nx=10, ny=10, nz=5)\n\n# Custom domain\nconfig = particles_in_grid_3d(;\n    x_min=0, x_max=π,\n    z_min=0.5, z_max=2.5,\n    nx=8, ny=8, nz=4\n)","category":"section"},{"location":"advanced/particles/#Particles-in-Layers-(multiple-z-levels)","page":"Particle Advection","title":"Particles in Layers (multiple z-levels)","text":"# 300 particles at 3 z-levels (10×10 per level)\nconfig = particles_in_layers([π/4, π/2, 3π/4]; nx=10, ny=10)\n\n# Custom horizontal domain\nconfig = particles_in_layers([0.5, 1.0, 1.5, 2.0];\n    x_min=0, x_max=π,\n    nx=5, ny=5\n)","category":"section"},{"location":"advanced/particles/#Random-3D-Distribution","page":"Particle Advection","title":"Random 3D Distribution","text":"# 500 random particles in default domain\nconfig = particles_random_3d(500)\n\n# Custom domain with seed\nconfig = particles_random_3d(1000;\n    x_min=0, x_max=π,\n    z_min=0.5, z_max=2.5,\n    seed=42\n)","category":"section"},{"location":"advanced/particles/#Custom-Positions","page":"Particle Advection","title":"Custom Positions","text":"# Particles at specific (x, y, z) locations\nconfig = particles_custom([\n    (1.0, 1.0, 0.5),\n    (2.0, 2.0, 1.0),\n    (3.0, 1.5, 0.75),\n    (1.5, 3.0, 1.25)\n])","category":"section"},{"location":"advanced/particles/#Boundary-Conditions","page":"Particle Advection","title":"Boundary Conditions","text":"","category":"section"},{"location":"advanced/particles/#Horizontal-(Periodic)","page":"Particle Advection","title":"Horizontal (Periodic)","text":"Particles wrap around domain edges:\n\nx_new = mod(x, Lx)\ny_new = mod(y, Ly)","category":"section"},{"location":"advanced/particles/#Vertical-(Reflective)","page":"Particle Advection","title":"Vertical (Reflective)","text":"Particles bounce off top and bottom:\n\nif z < 0\n    z = -z\n    w = -w  # Reverse vertical velocity\nelseif z > Lz\n    z = 2*Lz - z\n    w = -w\nend\n\nConfigure via:\n\nconfig = particles_in_box(π/2;\n    periodic_x=true,\n    periodic_y=true,\n    reflect_z=true      # Reflective vertical BCs\n)","category":"section"},{"location":"advanced/particles/#Delayed-Particle-Release","page":"Particle Advection","title":"Delayed Particle Release","text":"Start advecting particles after the flow has developed:\n\nconfig = particles_in_box(π/2; particle_advec_time=1.0)  # Start at t=1.0\n\nParticles remain stationary until current_time >= particle_advec_time.","category":"section"},{"location":"advanced/particles/#Trajectory-Output","page":"Particle Advection","title":"Trajectory Output","text":"","category":"section"},{"location":"advanced/particles/#Save-Interval","page":"Particle Advection","title":"Save Interval","text":"Control how often positions are recorded:\n\nconfig = particles_in_box(π/2;\n    save_interval=0.1,       # Save every 0.1 time units\n    max_save_points=1000     # Max points per file\n)","category":"section"},{"location":"advanced/particles/#Automatic-File-Splitting","page":"Particle Advection","title":"Automatic File Splitting","text":"For long simulations:\n\ntracker = ParticleTracker(config, grid)\nenable_auto_file_splitting!(tracker, \"long_run\", max_points_per_file=500)\n\n# Files created: long_run.nc, long_run_part1.nc, long_run_part2.nc, ...","category":"section"},{"location":"advanced/particles/#Writing-Trajectories","page":"Particle Advection","title":"Writing Trajectories","text":"# Standard output\nwrite_particle_trajectories(\"particles.nc\", tracker)\n\n# With metadata\nwrite_particle_trajectories(\"particles.nc\", tracker;\n    metadata = Dict(\"experiment\" => \"test1\", \"description\" => \"...\")\n)\n\n# By z-level (for layered distributions)\nwrite_particle_trajectories_by_zlevel(\"particles\", tracker)\n# Creates: particles_z0.nc, particles_z1.nc, ...","category":"section"},{"location":"advanced/particles/#Parallel-Algorithm","page":"Particle Advection","title":"Parallel Algorithm","text":"When running with MPI, particle advection uses domain decomposition.","category":"section"},{"location":"advanced/particles/#Domain-Decomposition","page":"Particle Advection","title":"Domain Decomposition","text":"The domain is split in the x-direction across MPI ranks:\n\n┌─────────────────────────────────────────────────────┐\n│           Domain: [0, Lx] × [0, Ly] × [0, Lz]       │\n│                                                     │\n│   ┌──────────┬──────────┬──────────┬──────────┐     │\n│   │  Rank 0  │  Rank 1  │  Rank 2  │  Rank 3  │     │\n│   │x∈[0,Lx/4)│x∈[Lx/4,  │x∈[Lx/2,  │x∈[3Lx/4, │     │\n│   │          │   Lx/2)  │  3Lx/4)  │   Lx)    │     │\n│   └──────────┴──────────┴──────────┴──────────┘     │\n│                                                     │\n│   Each rank owns particles within its x-range       │\n└─────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/particles/#Halo-Exchange","page":"Particle Advection","title":"Halo Exchange","text":"For interpolation near domain boundaries, velocity data is exchanged between neighbors:\n\n┌─────────────────────────────────────────────────────────────┐\n│                     HALO EXCHANGE                           │\n│                                                             │\n│   Rank 0                        Rank 1                      │\n│   ┌─────────────────┐          ┌─────────────────┐          │\n│   │ Local │  Right  │          │ Left  │ Local   │          │\n│   │ Data  │  Halo   │  ←────→  │ Halo  │ Data    │          │\n│   │       │ (ghost) │          │(ghost)│         │          │\n│   └───────┴─────────┘          └───────┴─────────┘          │\n│                                                             │\n│   • Rank 0 sends RIGHT edge → Rank 1's LEFT halo            │\n│   • Rank 1 sends LEFT edge  → Rank 0's RIGHT halo           │\n│                                                             │\n│   Halo width = 2 cells (enough for trilinear/tricubic)      │\n└─────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/particles/#Particle-Migration","page":"Particle Advection","title":"Particle Migration","text":"When particles cross domain boundaries, they are transferred:\n\n┌─────────────────────────────────────────────────────────────┐\n│                   PARTICLE MIGRATION                        │\n│                                                             │\n│   1. After advection, check each particle's position        │\n│   2. If x outside local domain → pack into send buffer      │\n│   3. MPI.Alltoall to exchange particle counts               │\n│   4. MPI.Send/Recv to transfer particle data                │\n│   5. Unpack received particles into local collection        │\n│                                                             │\n│   Particle data transferred: [x, y, z, u, v, w]             │\n└─────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/particles/#Parallel-Timestep-Workflow","page":"Particle Advection","title":"Parallel Timestep Workflow","text":"┌───────────────────────────────────────────────────────────────┐\n│                  PARALLEL ADVECTION TIMESTEP                  │\n│                                                               │\n│  1. UPDATE VELOCITY FIELDS                                    │\n│     • Compute QG velocities (distributed FFT)                 │\n│     • Solve omega equation (tridiagonal in z)                 │\n│     • Add wave Stokes drift                                   │\n│     • Exchange velocity halos (MPI)                           │\n│                              ↓                                │\n│  2. ADVECT PARTICLES (each rank processes local particles)    │\n│     • Interpolate velocity (use halo for boundary particles)  │\n│     • Time integration (Euler/RK2/RK4)                        │\n│                              ↓                                │\n│  3. MIGRATE PARTICLES                                         │\n│     • Identify particles that left local domain               │\n│     • Exchange particle data between ranks (MPI)              │\n│                              ↓                                │\n│  4. APPLY BOUNDARY CONDITIONS                                 │\n│     • Periodic wrap in x, y                                   │\n│     • Reflective bounce in z                                  │\n│                              ↓                                │\n│  5. SAVE TRAJECTORIES (if save_interval reached)              │\n│     • Each rank saves local particles, or                     │\n│     • Gather to rank 0 for unified output                     │\n└───────────────────────────────────────────────────────────────┘","category":"section"},{"location":"advanced/particles/#Using-Parallel-Particles","page":"Particle Advection","title":"Using Parallel Particles","text":"using MPI\nusing QGYBJ\n\nMPI.Init()\n\n# Set up parallel configuration\nparallel_config = setup_parallel_environment()\n\n# Create particle tracker with parallel support\ntracker = ParticleTracker(particle_config, grid, parallel_config)\ninitialize_particles!(tracker, particle_config)\n\n# Advection automatically handles:\n# - Halo exchange for boundary interpolation\n# - Particle migration between ranks\nfor step in 1:nsteps\n    timestep!(sim)\n    advect_particles!(tracker, sim.state, sim.grid, dt, sim.current_time)\nend\n\nMPI.Finalize()","category":"section"},{"location":"advanced/particles/#Key-Data-Structures","page":"Particle Advection","title":"Key Data Structures","text":"","category":"section"},{"location":"advanced/particles/#ParticleConfig","page":"Particle Advection","title":"ParticleConfig","text":"struct ParticleConfig{T}\n    # Spatial domain\n    x_min, x_max, y_min, y_max::T\n    z_level::T\n\n    # Particle count\n    nx_particles, ny_particles::Int\n\n    # Physics\n    use_ybj_w::Bool           # YBJ vs QG vertical velocity\n    use_3d_advection::Bool    # Include vertical advection\n\n    # Timing\n    particle_advec_time::T    # Delayed start time\n\n    # Numerics\n    integration_method::Symbol        # :euler, :rk2, :rk4\n    interpolation_method::InterpolationMethod  # TRILINEAR, etc.\n\n    # Boundaries\n    periodic_x, periodic_y::Bool\n    reflect_z::Bool\n\n    # I/O\n    save_interval::T\n    max_save_points::Int\nend","category":"section"},{"location":"advanced/particles/#ParticleTracker","page":"Particle Advection","title":"ParticleTracker","text":"mutable struct ParticleTracker{T}\n    config::ParticleConfig{T}\n    particles::ParticleState{T}   # x, y, z, u, v, w arrays\n\n    # Grid info\n    nx, ny, nz::Int\n    Lx, Ly, Lz, dx, dy, dz::T\n\n    # Velocity workspace\n    u_field, v_field, w_field::Array{T,3}\n\n    # MPI info (for parallel)\n    comm, rank, nprocs\n    local_domain::NamedTuple\n    halo_info::HaloInfo{T}\n    send_buffers, recv_buffers::Vector{Vector{T}}\n\n    # I/O\n    save_counter::Int\n    last_save_time::T\nend","category":"section"},{"location":"advanced/particles/#Performance-Considerations","page":"Particle Advection","title":"Performance Considerations","text":"Aspect Serial Parallel\nVelocity computation O(N) O(N/P) per rank\nInterpolation O(Np × stencil) O(Np/P × stencil)\nHalo exchange N/A O(ny × nz × halo_width)\nMigration N/A O(Np_crossing)\n\nTips:\n\nUse TRILINEAR for speed, TRICUBIC for accuracy\nRK4 costs 4× more than Euler but is much more accurate\nHalo exchange overhead is small for typical particle counts\nMigration cost depends on flow strength near boundaries","category":"section"},{"location":"advanced/particles/#Visualization","page":"Particle Advection","title":"Visualization","text":"","category":"section"},{"location":"advanced/particles/#Plot-Particle-Positions","page":"Particle Advection","title":"Plot Particle Positions","text":"using Plots\n\n# 2D scatter plot\nscatter(tracker.particles.x, tracker.particles.y,\n    markersize=2, alpha=0.6,\n    xlabel=\"x\", ylabel=\"y\",\n    title=\"Particle Distribution\"\n)","category":"section"},{"location":"advanced/particles/#Plot-Trajectories","page":"Particle Advection","title":"Plot Trajectories","text":"# Load saved trajectories\nusing NCDatasets\nds = NCDataset(\"particles.nc\")\nx_hist = ds[\"x\"][:]  # (np, ntime)\ny_hist = ds[\"y\"][:]\nclose(ds)\n\n# Plot first 50 particle tracks\np = plot(legend=false)\nfor i in 1:50\n    plot!(p, x_hist[i,:], y_hist[i,:], alpha=0.3)\nend\ndisplay(p)","category":"section"},{"location":"advanced/particles/#Animation","page":"Particle Advection","title":"Animation","text":"anim = @animate for t in 1:10:size(x_hist, 2)\n    scatter(x_hist[:,t], y_hist[:,t],\n        markersize=2, xlim=(0,2π), ylim=(0,2π),\n        title=\"t = $(t)\")\nend\ngif(anim, \"particles.gif\", fps=20)","category":"section"},{"location":"advanced/particles/#API-Reference","page":"Particle Advection","title":"API Reference","text":"See the Particle API Reference for complete documentation of:\n\nTypes:\n\nParticleConfig - Configuration options\nParticleState - Particle positions and velocities\nParticleTracker - Main tracking object\n\nInitialization Constructors:\n\nparticles_in_box - 2D box at fixed z-level\nparticles_in_circle - Circular disk at fixed z-level\nparticles_in_grid_3d - Uniform 3D grid\nparticles_in_layers - Multiple z-levels\nparticles_random_3d - Random 3D distribution\nparticles_custom - User-specified positions\n\nCore Functions:\n\ninitialize_particles! - Initialize particle positions\nadvect_particles! - Advect particles one timestep\ninterpolate_velocity_at_position - Velocity interpolation\nwrite_particle_trajectories - Save to NetCDF","category":"section"},{"location":"api/timestepping/#api-timestepping","page":"Time Stepping","title":"Time Stepping","text":"This page documents the time integration functions.","category":"section"},{"location":"api/timestepping/#Main-Time-Stepping-Scheme","page":"Time Stepping","title":"Main Time Stepping Scheme","text":"QGYBJ.jl uses a Leapfrog scheme with Robert-Asselin filter for time integration. This provides second-order accuracy while maintaining stability through computational mode damping.","category":"section"},{"location":"api/timestepping/#Overview","page":"Time Stepping","title":"Overview","text":"The time stepping consists of two functions:\n\nfirst_projection_step! - Forward Euler initialization\nleapfrog_step! - Main leapfrog integration with Robert-Asselin filter","category":"section"},{"location":"api/timestepping/#Forward-Euler-Projection-Step","page":"Time Stepping","title":"Forward Euler Projection Step","text":"Purpose: Initialize the leapfrog scheme by providing values at times n and n-1.\n\nAlgorithm:\n\nCompute tendencies at time n (advection, refraction, diffusion)\nApply physics switches (linear, inviscid, etc.)\nForward Euler update with integrating factors\nWave feedback (optional)\nDiagnostic inversions (q → ψ → u, v)\n\nUsage:\n\n# Serial mode\nfirst_projection_step!(state, grid, params, plans; a=a_ell, dealias_mask=L)\n\n# Parallel mode (2D decomposition)\nfirst_projection_step!(state, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)","category":"section"},{"location":"api/timestepping/#Leapfrog-Step-with-Robert-Asselin-Filter","page":"Time Stepping","title":"Leapfrog Step with Robert-Asselin Filter","text":"The Leapfrog scheme:\n\nphi^n+1 = phi^n-1 + 2Delta t times F^n\n\nRobert-Asselin filter (damps computational mode):\n\ntildephi^n = phi^n + gamma(phi^n-1 - 2phi^n + phi^n+1)\n\nWith integrating factor for hyperdiffusion:\n\nphi^n+1 = phi^n-1 times e^-2lambdaDelta t + 2Delta t times F^n times e^-lambdaDelta t\n\nUsage:\n\n# Serial mode\nleapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L)\n\n# Parallel mode (2D decomposition)\nleapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)\n\n# Time level rotation after each step\nSnm1, Sn, Snp1 = Sn, Snp1, Snm1","category":"section"},{"location":"api/timestepping/#Forward-Euler-Update","page":"Time Stepping","title":"Forward Euler Update","text":"Used for the first (projection) step:\n\nphi^n+1 = leftphi^n - Delta t times Fright times e^-lambdaDelta t\n\nThe integrating factor e^{-λΔt} handles hyperdiffusion exactly.","category":"section"},{"location":"api/timestepping/#Tendency-Computation","page":"Time Stepping","title":"Tendency Computation","text":"Each time step computes the following tendencies:\n\nQG Potential Vorticity:\n\nF_q = -J(psi q) + nu_z fracpartial^2 qpartial z^2\n\nWave Envelope (real/imaginary parts):\n\nF_BR = -J(psi BR) - frack_h^22A_I + frac12BI times zeta\n\nF_BI = -J(psi BI) + frack_h^22A_R - frac12BR times zeta","category":"section"},{"location":"api/timestepping/#Nonlinear-Terms","page":"Time Stepping","title":"Nonlinear Terms","text":"Advection: convol_waqg! computes J(ψ, q), J(ψ, BR), J(ψ, BI)\n\nRefraction: refraction_waqg! computes B × ζ where ζ = ∇²ψ","category":"section"},{"location":"api/timestepping/#Vertical-Diffusion","page":"Time Stepping","title":"Vertical Diffusion","text":"Computes νz ∂²q/∂z² using the tridiagonal solver. Automatically handles 2D decomposition transposes.","category":"section"},{"location":"api/timestepping/#Integrating-Factors","page":"Time Stepping","title":"Integrating Factors","text":"","category":"section"},{"location":"api/timestepping/#Purpose","page":"Time Stepping","title":"Purpose","text":"For stiff hyperdiffusion terms, we use an integrating factor approach:\n\ntildephi = phi times e^nu k^2p t\n\nThis allows exact treatment of the linear diffusion while using explicit time stepping.","category":"section"},{"location":"api/timestepping/#Function","page":"Time Stepping","title":"Function","text":"Usage:\n\n# Compute factor for a spectral mode\nIf = int_factor(kx, ky, params; waves=false)   # For mean flow (q)\nIfw = int_factor(kx, ky, params; waves=true)   # For waves (B)\n\n# Apply in time stepping\nq_new = q_old * exp(-2*If) - 2*dt * tendency * exp(-If)   # Leapfrog\nq_new = q_old * exp(-If) - dt * tendency                    # Euler","category":"section"},{"location":"api/timestepping/#Complete-Simulation-Loop","page":"Time Stepping","title":"Complete Simulation Loop","text":"","category":"section"},{"location":"api/timestepping/#Setup-and-Run","page":"Time Stepping","title":"Setup and Run","text":"using QGYBJ\n\n# Initialize\nparams = default_params(nx=64, ny=64, nz=32)\ngrid = init_grid(params)\nplans = plan_transforms!(grid)\na_ell = a_ell_ut(params, grid)\nL = dealias_mask(params, grid)\n\n# Create three state arrays for leapfrog\nSnm1 = init_state(grid)  # n-1\nSn = init_state(grid)    # n\nSnp1 = init_state(grid)  # n+1\n\n# Initialize with random fields\ninit_random_psi!(Sn, grid, params, plans; a=a_ell)\n\n# Projection step (Forward Euler initialization)\nfirst_projection_step!(Sn, grid, params, plans; a=a_ell, dealias_mask=L)\n\n# Copy for n-1 state\ncopy_state!(Snm1, Sn)\n\n# Main time loop\nfor iter in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L)\n\n    # Rotate time levels\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend","category":"section"},{"location":"api/timestepping/#Parallel-Mode-(2D-Decomposition)","page":"Time Stepping","title":"Parallel Mode (2D Decomposition)","text":"using MPI, PencilArrays, PencilFFTs, QGYBJ\n\nMPI.Init()\nmpi_config = QGYBJ.setup_mpi_environment()\n\n# Initialize with MPI\nparams = default_params(nx=256, ny=256, nz=128)\ngrid = QGYBJ.init_mpi_grid(params, mpi_config)\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\n\na_ell = a_ell_ut(params, grid)\nL = dealias_mask(params, grid)\n\n# Create states\nSnm1 = QGYBJ.init_mpi_state(grid, mpi_config)\nSn = QGYBJ.init_mpi_state(grid, mpi_config)\nSnp1 = QGYBJ.init_mpi_state(grid, mpi_config)\n\n# Initialize\ninit_random_psi!(Sn, grid, params, plans; a=a_ell)\nfirst_projection_step!(Sn, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)\ncopy_state!(Snm1, Sn)\n\n# Main loop with workspace for 2D decomposition\nfor iter in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans;\n                   a=a_ell, dealias_mask=L, workspace=workspace)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\nMPI.Finalize()","category":"section"},{"location":"api/timestepping/#CFL-Condition","page":"Time Stepping","title":"CFL Condition","text":"","category":"section"},{"location":"api/timestepping/#Stability-Constraint","page":"Time Stepping","title":"Stability Constraint","text":"function compute_cfl(state, grid, dt)\n    u_max = maximum(abs.(state.u))\n    v_max = maximum(abs.(state.v))\n    return dt * max(u_max/grid.dx, v_max/grid.dy)\nend\n\nFor stability, CFL < 1 is required. Recommended: CFL ≈ 0.5.","category":"section"},{"location":"api/timestepping/#Adaptive-Time-Stepping","page":"Time Stepping","title":"Adaptive Time Stepping","text":"function adaptive_dt(state, grid; cfl_target=0.5, dt_max=0.01)\n    u_max = maximum(abs.(state.u)) + 1e-10  # Avoid division by zero\n    v_max = maximum(abs.(state.v)) + 1e-10\n\n    dt = cfl_target * min(grid.dx/u_max, grid.dy/v_max)\n    return min(dt, dt_max)\nend","category":"section"},{"location":"api/timestepping/#Robert-Asselin-Filter-Parameter","page":"Time Stepping","title":"Robert-Asselin Filter Parameter","text":"The filter coefficient γ (γ in QGParams) controls damping of the computational mode:\n\nToo large (γ > 0.01): Excessive damping, accuracy loss\nToo small (γ < 0.0001): Computational mode growth\nRecommended: γ ≈ 0.001 (default)\n\nparams = default_params(nx=64, ny=64, nz=32; γ=0.001)\n\nNote: Type \\gamma<tab> in the Julia REPL to enter γ.","category":"section"},{"location":"api/timestepping/#Time-Level-Management","page":"Time Stepping","title":"Time Level Management","text":"The leapfrog scheme requires three time levels:\n\nVariable Description Usage\nSnm1 State at n-1 Input, receives filtered n values\nSn State at n Input (unchanged)\nSnp1 State at n+1 Output\n\nAfter each step, rotate the pointers:\n\nSnm1, Sn, Snp1 = Sn, Snp1, Snm1\n\nThis avoids data copying by just swapping references.","category":"section"},{"location":"api/timestepping/#Physics-Switches","page":"Time Stepping","title":"Physics Switches","text":"The time stepping respects these QGParams switches:\n\nSwitch Effect\nlinear Zero nonlinear advection J(ψ, q), J(ψ, B)\ninviscid Zero vertical diffusion νz ∂²q/∂z²\npassive_scalar Waves as passive tracers (no dispersion/refraction)\nno_dispersion Zero wave dispersion (A = 0)\nfixed_flow Mean flow doesn't evolve (q unchanged)\nno_wave_feedback No qʷ feedback term","category":"section"},{"location":"api/timestepping/#Performance","page":"Time Stepping","title":"Performance","text":"","category":"section"},{"location":"api/timestepping/#Timing-Breakdown","page":"Time Stepping","title":"Timing Breakdown","text":"Typical distribution: | Component | Fraction | |:–––––|:––––-| | FFTs | 40-50% | | Elliptic solves | 20-30% | | Array operations | 15-25% | | Transpose operations (2D) | 5-10% |","category":"section"},{"location":"api/timestepping/#2D-Decomposition-Notes","page":"Time Stepping","title":"2D Decomposition Notes","text":"When using 2D decomposition:\n\nPass workspace argument to avoid repeated allocation\nVertical operations (inversions, diffusion) use automatic transposes\nThe workspace contains pre-allocated z-pencil arrays\n\n# Pre-allocate workspace (once)\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\n\n# Reuse for all steps\nfor step in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans;\n                   a=a, dealias_mask=L, workspace=workspace)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend","category":"section"},{"location":"api/timestepping/#API-Summary","page":"Time Stepping","title":"API Summary","text":"All time stepping functions documented above:\n\nfirst_projection_step! - Forward Euler initialization step\nleapfrog_step! - Main leapfrog integration with Robert-Asselin filter\nconvol_waqg! - Nonlinear advection computation\nrefraction_waqg! - Wave refraction term\ndissipation_q_nv! - Vertical diffusion\nint_factor - Integrating factor for hyperdiffusion\ncompute_qw! - Wave feedback term (see Physics API)","category":"section"},{"location":"api/timestepping/#QGYBJ.first_projection_step!","page":"Time Stepping","title":"QGYBJ.first_projection_step!","text":"first_projection_step!(S, G, par, plans; a, dealias_mask=nothing, workspace=nothing, N2_profile=nothing)\n\nForward Euler initialization step for the leapfrog time stepper.\n\nPurpose\n\nThe leapfrog scheme requires values at two time levels (n and n-1). This function takes the initial state and advances it by one Forward Euler step, providing the needed second time level.\n\nAlgorithm\n\nCompute tendencies at time n:\nAdvection of q and B by geostrophic flow\nWave refraction by vorticity\nVertical diffusion\nApply physics switches:\nlinear: Zero nonlinear advection\ninviscid: Zero dissipation\npassive_scalar: Zero dispersion and refraction\nfixed_flow: Mean flow doesn't evolve\nForward Euler update: For each spectral mode:\nq^(n+1) = [q^n - dt × tendency_q + dt × diffusion] × exp(-λ_q × dt)\nB^(n+1) = [B^n - dt × tendency_B] × exp(-λ_B × dt)\nwhere λ is the hyperdiffusion factor.\nWave feedback (optional):\nq* = q - qʷ\nDiagnostic inversions:\nq → ψ (elliptic inversion)\nB → A, C (YBJ+ inversion)\nψ → u, v (velocity computation)\n\nArguments\n\nS::State: State to advance (modified in place)\nG::Grid: Grid struct\npar::QGParams: Model parameters\nplans: FFT plans\na: Elliptic coefficient array a_ell(z) = f²/N²\ndealias_mask: Optional 2/3 dealiasing mask (nx × ny)\nworkspace: Optional pre-allocated workspace for 2D decomposition\nN2_profile: Optional N²(z) profile for vertical velocity computation\n\nReturns\n\nModified state S at time n+1.\n\nFortran Correspondence\n\nThis matches the projection step in main_waqg.f90.\n\nExample\n\n# Initialize and run projection step\nstate = init_state(grid)\ninit_random_psi!(state, grid)\na = a_ell_ut(params, grid)\nL = dealias_mask(grid)\nfirst_projection_step!(state, grid, params, plans; a=a, dealias_mask=L)\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJ.leapfrog_step!","page":"Time Stepping","title":"QGYBJ.leapfrog_step!","text":"leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a, dealias_mask=nothing, workspace=nothing, N2_profile=nothing)\n\nAdvance the solution by one leapfrog time step with Robert-Asselin filtering.\n\nAlgorithm\n\n1. Compute tendencies at time n:\n\nF_q^n = J(ψ^n, q^n) - νz∂²q^(n-1)/∂z²\nF_B^n = J(ψ^n, B^n) + dispersion + refraction\n\n2. Leapfrog update with integrating factors: For each spectral mode (k):\n\nq^(n+1) = q^(n-1) × e^(-2λdt) + 2dt × [-J(ψ,q)^n + diff^n] × e^(-λdt)\nB^(n+1) = B^(n-1) × e^(-2λdt) + 2dt × [-J(ψ,B)^n + dispersion + refraction] × e^(-λdt)\n\nNote: All tendencies are evaluated at time n and scaled by e^(-λdt) for second-order accuracy.\n\n3. Robert-Asselin filter:\n\nq̃^n = q^n + γ(q^(n-1) - 2q^n + q^(n+1))\nB̃^n = B^n + γ(B^(n-1) - 2B^n + B^(n+1))\n\nThe filtered values are stored in Sn (which becomes Snm1 after rotation).\n\n4. Wave feedback (if enabled):\n\nq*^(n+1) = q^(n+1) - qʷ^(n+1)\n\n5. Diagnostic inversions:\n\nq^(n+1) → ψ^(n+1)\nB^(n+1) → A^(n+1), C^(n+1)\nψ^(n+1) → u^(n+1), v^(n+1)\n\nArguments\n\nSnp1::State: State at time n+1 (output)\nSn::State: State at time n (input, filter applied to Snm1)\nSnm1::State: State at time n-1 (input, receives filtered values)\nG::Grid: Grid struct\npar::QGParams: Model parameters\nplans: FFT plans\na: Elliptic coefficient array\ndealias_mask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\nN2_profile: Optional N²(z) profile for vertical velocity computation\n\nReturns\n\nModified Snp1 with solution at time n+1.\n\nTime Level Management\n\nAfter this call:\n\nSnp1 contains fields at n+1\nSn contains filtered fields at n (becomes new n-1 after rotation)\nSnm1 is unchanged (will be overwritten after rotation)\n\nTypical loop structure:\n\nfor iter in 1:nsteps\n    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a)\n    # Rotate: Snm1 ← Sn, Sn ← Snp1\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\nFortran Correspondence\n\nThis matches the main leapfrog loop in main_waqg.f90.\n\nExample\n\n# After projection step, run leapfrog\nfor iter in 1:1000\n    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a, dealias_mask=L)\n    Snm1, Sn, Snp1 = Sn, Snp1, Snm1\nend\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJ.Nonlinear.convol_waqg!","page":"Time Stepping","title":"QGYBJ.Nonlinear.convol_waqg!","text":"convol_waqg!(nqk, nBRk, nBIk, u, v, qk, BRk, BIk, G, plans; Lmask=nothing)\n\nCompute advection terms in divergence form, matching Fortran convol_waqg.\n\nMathematical Form\n\nUses the divergence form of the Jacobian:\n\nJ(ψ, q) = ∂(uq)/∂x + ∂(vq)/∂y\n\nwhere u, v are the geostrophic velocities (in real space).\n\nOutput\n\nnqk:  Ĵ(ψ, q) - advection of QGPV\nnBRk: Ĵ(ψ, BR) - advection of wave real part\nnBIk: Ĵ(ψ, BI) - advection of wave imaginary part\n\nArguments\n\nnqk, nBRk, nBIk: Output arrays (spectral)\nu, v: Real-space velocity arrays (precomputed)\nqk, BRk, BIk: Input fields (spectral)\nG::Grid: Grid struct\nplans: FFT plans\nLmask: Dealiasing mask (true = keep mode, false = zero)\n\nAlgorithm\n\nFor each field χ ∈ {q, BR, BI}:\n\nTransform χ̂ → χ (inverse FFT)\nCompute uχ and vχ (pointwise in real space)\nTransform back: (ûχ), (v̂χ)\nCompute divergence: ikₓ(ûχ) + ikᵧ(v̂χ)\nApply dealiasing mask\n\nFortran Correspondence\n\nThis matches convol_waqg in derivatives.f90.\n\nNote\n\nThe velocities u, v should be precomputed and passed in real space.\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJ.Nonlinear.refraction_waqg!","page":"Time Stepping","title":"QGYBJ.Nonlinear.refraction_waqg!","text":"refraction_waqg!(rBRk, rBIk, BRk, BIk, psik, G, plans; Lmask=nothing)\n\nCompute wave refraction term: B × ζ where ζ = ∇²ψ is relative vorticity.\n\nPhysical Interpretation\n\nNear-inertial waves are refracted by vorticity gradients:\n\nAnticyclones (ζ < 0): Wave focusing, amplitude increase\nCyclones (ζ > 0): Wave defocusing, amplitude decrease\n\nThis is the \"wave capture\" mechanism that traps NIWs in anticyclonic eddies.\n\nMathematical Form\n\nrefraction = B × ζ\n\nwhere ζ = ∇²ψ = -kₕ²ψ̂ in spectral space.\n\nOutput\n\nrBRk: Real part of refraction term (spectral)\nrBIk: Imaginary part of refraction term (spectral)\n\nAlgorithm\n\nCompute ζ̂ = -kₕ²ψ̂ (spectral)\nTransform ζ̂, B̂R, B̂I to real space\nCompute products: rBR = ζ × BR, rBI = ζ × BI\nTransform back and apply dealiasing\n\nFortran Correspondence\n\nThis matches refraction_waqg in derivatives.f90.\n\nExample\n\nrefraction_waqg!(rBR, rBI, BR, BI, psi, grid, plans; Lmask=L)\n# rBR, rBI now contain the refraction tendencies\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJ.Nonlinear.dissipation_q_nv!","page":"Time Stepping","title":"QGYBJ.Nonlinear.dissipation_q_nv!","text":"dissipation_q_nv!(dqk, qok, par, G; workspace=nothing)\n\nCompute vertical diffusion of q with Neumann boundary conditions.\n\nMathematical Form\n\nD = νz ∂²q/∂z²\n\nwith ∂q/∂z = 0 at z = 0 and z = H.\n\nDiscretization\n\nInterior points (1 < k < nz):     D[k] = νz (q[k+1] - 2q[k] + q[k-1]) / dz²\n\nBoundary points (Neumann):     D[1]  = νz (q[2] - q[1]) / dz²     D[nz] = νz (q[nz-1] - q[nz]) / dz²\n\nArguments\n\ndqk: Output array for diffusion term\nqok: Input q field at time n-1 (for leapfrog)\npar: QGParams (for nuz coefficient)\nG::Grid: Grid struct\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nNote\n\nThis operates on spectral q but the vertical derivative is in physical space, so the operation is the same for each (kx, ky) mode.\n\nFortran Correspondence\n\nThis matches dissipation_q_nv in derivatives.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/timestepping/#QGYBJ.Nonlinear.int_factor","page":"Time Stepping","title":"QGYBJ.Nonlinear.int_factor","text":"int_factor(kx, ky, par; waves=false)\n\nCompute hyperdiffusion integrating factor for given wavenumber.\n\nMathematical Background\n\nThe hyperdiffusion operator is:\n\nD = -ν₁(-∇²)^n₁ - ν₂(-∇²)^n₂\n\nIn spectral space, this becomes multiplication by:\n\nλ = ν₁|k|^(2n₁) + ν₂|k|^(2n₂)\n\nThe integrating factor for one time step is: exp(-λ×dt)\n\nFor efficiency, we return just λ×dt (the exponent).\n\nArguments\n\nkx, ky: Horizontal wavenumber components\npar: QGParams (contains ν₁, ν₂, n₁, n₂)\nwaves::Bool: If true, use wave hyperdiffusion (nuh1w, ilap1w, etc.)\n\nReturns\n\nλ×dt = dt × [ν₁(kx² + ky²)^n₁ + ν₂(kx² + ky²)^n₂] = dt × [ν₁ kₕ^(2n₁) + ν₂ kₕ^(2n₂)]\n\nNote: Uses isotropic form (kx² + ky²)^n for proper damping of diagonal modes.\n\nUsage in Time Stepping\n\n# After computing tendency\nfactor = exp(-int_factor(kx, ky, par))\nq_new = factor * q_tendency\n\nFortran Correspondence\n\nThis matches the integrating factor computation in the main loop of main_waqg.f90.\n\nExample\n\n# Get integrating factor for wavenumber (3, 4)\nlambda_dt = int_factor(3.0, 4.0, params)\nfactor = exp(-lambda_dt)  # Multiply solution by this\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#configuration","page":"Configuration","title":"Configuration","text":"This page explains how to configure QGYBJ.jl simulations.","category":"section"},{"location":"guide/configuration/#Configuration-Approaches","page":"Configuration","title":"Configuration Approaches","text":"QGYBJ.jl offers two ways to configure simulations:\n\nSimple API: Use create_simple_config() for quick setup\nFull Control: Create QGParams and Grid directly via default_params()\n\nwarning: Different Defaults Between APIs\nThe two APIs have different default settings for physics flags:Flag create_simple_config() default_params()\ninviscid true (no dissipation) false (with dissipation)\nno_wave_feedback false (two-way coupling) true (one-way coupling)Simple API defaults are designed for idealized/educational runs. Full Control API defaults match the Fortran code for production runs.To get production-like settings with the simple API, explicitly set:config = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    inviscid=false,           # Enable dissipation\n    no_wave_feedback=true     # One-way wave-flow coupling\n)","category":"section"},{"location":"guide/configuration/#Simple-Configuration","page":"Configuration","title":"Simple Configuration","text":"","category":"section"},{"location":"guide/configuration/#Basic-Usage","page":"Configuration","title":"Basic Usage","text":"config = create_simple_config(\n    # Required: Grid size\n    nx = 128,\n    ny = 128,\n    nz = 64,\n\n    # Required: Time stepping\n    dt = 0.001,\n    total_time = 10.0,\n\n    # Optional: Output\n    output_interval = 100,\n    output_dir = \"output\"\n)","category":"section"},{"location":"guide/configuration/#All-Options","page":"Configuration","title":"All Options","text":"config = create_simple_config(\n    # Grid dimensions\n    nx = 128,                    # Points in x\n    ny = 128,                    # Points in y\n    nz = 64,                     # Points in z\n\n    # Domain size (nondimensional)\n    Lx = 2π,                     # Domain length in x\n    Ly = 2π,                     # Domain length in y\n    H = 1.0,                     # Domain depth\n\n    # Time stepping\n    dt = 0.001,                  # Time step\n    total_time = 10.0,           # Total simulation time\n\n    # Stratification\n    stratification_type = :exponential,  # See Stratification section\n    N0 = 1.0,                    # Reference buoyancy frequency\n    pycnocline_depth = 0.1,      # Pycnocline depth (for some types)\n\n    # Physics flags\n    inviscid = false,            # Disable all dissipation\n    linear = false,              # Disable nonlinear terms\n    no_wave_feedback = false,    # Disable wave feedback on flow\n    ybj_plus = true,             # Use YBJ+ (vs normal YBJ)\n\n    # Dissipation parameters (hyperviscosity)\n    νₕ₁ = 0.01,                  # First hyperviscosity (flow)\n    ilap1 = 2,                   # Laplacian power for νₕ₁\n    νₕ₂ = 10.0,                  # Second hyperviscosity (flow)\n    ilap2 = 6,                   # Laplacian power for νₕ₂\n    νz = 0.0,                    # Vertical diffusion\n\n    # Output\n    output_interval = 100,       # Steps between output\n    output_dir = \"output\",       # Output directory\n\n    # Initial conditions (optional)\n    init_psi = nothing,          # Initial streamfunction\n    init_B = nothing,            # Initial wave envelope\n)","category":"section"},{"location":"guide/configuration/#Full-Configuration","page":"Configuration","title":"Full Configuration","text":"For complete control, create components separately:","category":"section"},{"location":"guide/configuration/#Step-1:-Create-Parameters","page":"Configuration","title":"Step 1: Create Parameters","text":"params = default_params(;\n    # Physical parameters\n    f₀ = 1.0,                    # Coriolis parameter (type: f\\_0<tab>)\n    N² = 1.0,                    # Buoyancy frequency squared (type: N\\^2<tab>)\n\n    # Model options\n    ybj_plus = true,\n    no_feedback = false,\n    inviscid = false,\n    linear = false,\n\n    # Dissipation (hyperviscosity)\n    νₕ₁ = 0.01,                  # First hyperviscosity (type: \\nu\\_h\\_1<tab>)\n    ilap1 = 2,                   # Power for νₕ₁ (biharmonic)\n    νₕ₂ = 10.0,                  # Second hyperviscosity\n    ilap2 = 6,                   # Power for νₕ₂ (hyper-6)\n    νz = 0.0,                    # Vertical diffusion (type: \\nu\\_z<tab>)\n)","category":"section"},{"location":"guide/configuration/#Step-2:-Create-Grid","page":"Configuration","title":"Step 2: Create Grid","text":"grid = Grid(\n    nx = 128,\n    ny = 128,\n    nz = 64,\n    Lx = 2π,\n    Ly = 2π,\n    H = 1.0\n)","category":"section"},{"location":"guide/configuration/#Step-3:-Set-Up-Stratification","page":"Configuration","title":"Step 3: Set Up Stratification","text":"# Option A: Constant N²\nsetup_stratification!(grid, params, :constant_N)\n\n# Option B: Exponential profile\nsetup_stratification!(grid, params, :exponential; depth_scale=0.1)\n\n# Option C: Custom profile\nN2_custom = [compute_N2(z) for z in grid.z]\nset_stratification!(grid, N2_custom)","category":"section"},{"location":"guide/configuration/#Step-4:-Initialize-State","page":"Configuration","title":"Step 4: Initialize State","text":"# Create state with allocated arrays\nstate = create_state(grid)\n\n# Set initial conditions\ninitialize_random_flow!(state, grid; energy_level=1.0)\ninitialize_random_waves!(state, grid; amplitude=0.1)","category":"section"},{"location":"guide/configuration/#Step-5:-Run","page":"Configuration","title":"Step 5: Run","text":"# Create work arrays and plans\nwork = create_work_arrays(grid)\nplans = plan_transforms!(grid)\na_ell = setup_elliptic_matrices(grid, params)\n\n# Time loop\nfor step = 1:nsteps\n    timestep!(state, grid, params, work, plans, a_ell, dt)\nend","category":"section"},{"location":"guide/configuration/#Parameter-Reference","page":"Configuration","title":"Parameter Reference","text":"","category":"section"},{"location":"guide/configuration/#Physical-Parameters","page":"Configuration","title":"Physical Parameters","text":"Parameter Type Default Description\nf₀ Float64 1.0 Coriolis parameter\nN² Float64 1.0 Buoyancy frequency squared\nγ Float64 1e-3 Robert-Asselin filter coefficient\n\nNote: Type Unicode characters in Julia REPL using \\ + name + <tab>, e.g., f\\_0<tab> → f₀","category":"section"},{"location":"guide/configuration/#Model-Flags","page":"Configuration","title":"Model Flags","text":"Flag Type Default Effect\nybj_plus Bool true Use YBJ+ formulation\nno_feedback Bool false Disable wave → flow feedback\ninviscid Bool false Disable all dissipation\nlinear Bool false Disable nonlinear terms\nno_advection_psi Bool false Disable ψ advection of PV\nno_advection_B Bool false Disable ψ advection of B\nno_refraction Bool false Disable wave refraction\nno_dispersion Bool false Disable wave dispersion","category":"section"},{"location":"guide/configuration/#Dissipation-Parameters","page":"Configuration","title":"Dissipation Parameters","text":"The model uses two hyperdiffusion operators: ν₁(-∇²)^ilap1 + ν₂(-∇²)^ilap2\n\nParameter Type Default Description\nνₕ₁ Float64 0.01 First hyperviscosity coefficient (flow)\nilap1 Int 2 Laplacian power for νₕ₁ (2=biharmonic)\nνₕ₂ Float64 10.0 Second hyperviscosity coefficient (flow)\nilap2 Int 6 Laplacian power for νₕ₂ (hyper-6)\nνₕ₁ʷ Float64 0.0 First hyperviscosity coefficient (waves)\nνₕ₂ʷ Float64 10.0 Second hyperviscosity coefficient (waves)\nνz Float64 0.0 Vertical diffusivity","category":"section"},{"location":"guide/configuration/#Grid-Parameters","page":"Configuration","title":"Grid Parameters","text":"Parameter Type Default Description\nnx, ny Int - Horizontal grid points\nnz Int - Vertical grid points\nLx, Ly Float64 2π Horizontal domain size\nH Float64 1.0 Vertical domain depth","category":"section"},{"location":"guide/configuration/#Configuration-Validation","page":"Configuration","title":"Configuration Validation","text":"The package validates configurations on creation:\n\n# This will error if invalid\nconfig = create_simple_config(\n    nx = 65,  # Error: must be power of 2 for FFT efficiency\n    ny = 64,\n    nz = 32,\n    dt = 0.001,\n    total_time = 1.0\n)\n\nCommon validation checks:\n\nGrid dimensions must be positive integers\ndt must be positive\ntotal_time must be greater than dt\nDissipation coefficients must be non-negative","category":"section"},{"location":"guide/configuration/#Saving-and-Loading-Configurations","page":"Configuration","title":"Saving and Loading Configurations","text":"","category":"section"},{"location":"guide/configuration/#Save-Configuration","page":"Configuration","title":"Save Configuration","text":"using JLD2\n\n# Save all parameters\n@save \"config.jld2\" params grid","category":"section"},{"location":"guide/configuration/#Load-Configuration","page":"Configuration","title":"Load Configuration","text":"@load \"config.jld2\" params grid","category":"section"},{"location":"guide/configuration/#TOML-Format","page":"Configuration","title":"TOML Format","text":"For human-readable configs:\n\nusing TOML\n\nconfig_dict = Dict(\n    \"grid\" => Dict(\"nx\" => 128, \"ny\" => 128, \"nz\" => 64),\n    \"physics\" => Dict(\"ybj_plus\" => true),\n    \"time\" => Dict(\"dt\" => 0.001, \"total\" => 10.0)\n)\n\nopen(\"config.toml\", \"w\") do io\n    TOML.print(io, config_dict)\nend","category":"section"},{"location":"guide/configuration/#Examples","page":"Configuration","title":"Examples","text":"","category":"section"},{"location":"guide/configuration/#Minimal-QG-Only-Run","page":"Configuration","title":"Minimal QG-Only Run","text":"config = create_simple_config(\n    nx=64, ny=64, nz=32,\n    dt=0.01, total_time=100.0,\n    init_B = zeros(ComplexF64, 33, 64, 32)  # No waves\n)","category":"section"},{"location":"guide/configuration/#High-Resolution-Wave-Eddy","page":"Configuration","title":"High-Resolution Wave-Eddy","text":"config = create_simple_config(\n    nx=512, ny=512, nz=128,\n    dt=0.0001, total_time=1.0,\n    nu_h2=1e-12, p2=8,  # Very selective dissipation\n    output_interval=1000\n)","category":"section"},{"location":"guide/configuration/#Linear-Wave-Propagation","page":"Configuration","title":"Linear Wave Propagation","text":"config = create_simple_config(\n    nx=128, ny=128, nz=64,\n    dt=0.001, total_time=10.0,\n    linear=true,         # No nonlinear terms\n    inviscid=true,       # No dissipation\n    no_wave_feedback=true  # One-way coupling only\n)","category":"section"},{"location":"guide/configuration/#Next-Steps","page":"Configuration","title":"Next Steps","text":"Stratification: Configure density profiles\nInitial Conditions: Set up initial fields\nRunning Simulations: Execute and monitor runs","category":"section"},{"location":"guide/initial_conditions/#initial-conditions","page":"Initial Conditions","title":"Initial Conditions","text":"This page describes how to set up initial conditions for QGYBJ.jl simulations.","category":"section"},{"location":"guide/initial_conditions/#Overview","page":"Initial Conditions","title":"Overview","text":"Initial conditions must be specified for:\n\nPotential vorticity q (or streamfunction psi)\nWave envelope B (or wave amplitude A)","category":"section"},{"location":"guide/initial_conditions/#Random-Initialization","page":"Initial Conditions","title":"Random Initialization","text":"","category":"section"},{"location":"guide/initial_conditions/#Random-Flow","page":"Initial Conditions","title":"Random Flow","text":"# Random streamfunction with specified energy level\ninitialize_random_flow!(state, grid;\n    energy_level = 1.0,\n    seed = 42\n)\n\nThe random flow is band-limited to resolved wavenumbers with a specified spectral slope.","category":"section"},{"location":"guide/initial_conditions/#Random-Waves","page":"Initial Conditions","title":"Random Waves","text":"# Random wave field\ninitialize_random_waves!(state, grid;\n    amplitude = 0.1,\n    vertical_mode = 1,  # Dominant vertical mode\n    seed = 123\n)","category":"section"},{"location":"guide/initial_conditions/#Coherent-Structures","page":"Initial Conditions","title":"Coherent Structures","text":"","category":"section"},{"location":"guide/initial_conditions/#Single-Vortex","page":"Initial Conditions","title":"Single Vortex","text":"# Gaussian vortex at domain center\ninitialize_vortex!(state, grid;\n    x0 = π,\n    y0 = π,\n    radius = 0.5,\n    intensity = 1.0,\n    sign = :cyclone  # or :anticyclone\n)","category":"section"},{"location":"guide/initial_conditions/#Vortex-Pair","page":"Initial Conditions","title":"Vortex Pair","text":"# Dipole (vortex pair)\ninitialize_dipole!(state, grid;\n    separation = 1.0,\n    intensity = 1.0,\n    angle = 0.0  # Orientation\n)","category":"section"},{"location":"guide/initial_conditions/#Jet","page":"Initial Conditions","title":"Jet","text":"# Zonal jet with specified profile\ninitialize_jet!(state, grid;\n    jet_width = 0.5,\n    jet_intensity = 1.0,\n    y_center = π\n)","category":"section"},{"location":"guide/initial_conditions/#Wave-Packets","page":"Initial Conditions","title":"Wave Packets","text":"","category":"section"},{"location":"guide/initial_conditions/#Plane-Wave","page":"Initial Conditions","title":"Plane Wave","text":"# Plane wave with specified wavenumber\ninitialize_plane_wave!(state, grid;\n    kx = 4,\n    ky = 0,\n    amplitude = 0.1,\n    vertical_mode = 1\n)","category":"section"},{"location":"guide/initial_conditions/#Gaussian-Packet","page":"Initial Conditions","title":"Gaussian Packet","text":"# Localized wave packet\ninitialize_wave_packet!(state, grid;\n    x0 = π,\n    y0 = π,\n    sigma_x = 0.5,\n    sigma_y = 0.5,\n    k0 = 4,     # Central wavenumber\n    amplitude = 0.1\n)","category":"section"},{"location":"guide/initial_conditions/#From-Spectra","page":"Initial Conditions","title":"From Spectra","text":"","category":"section"},{"location":"guide/initial_conditions/#Prescribed-Energy-Spectrum","page":"Initial Conditions","title":"Prescribed Energy Spectrum","text":"# Initialize with E(k) ~ k^(-3)\ninitialize_from_spectrum!(state, grid;\n    spectrum_type = :power_law,\n    exponent = -3,\n    energy_level = 1.0\n)","category":"section"},{"location":"guide/initial_conditions/#Realistic-Spectrum","page":"Initial Conditions","title":"Realistic Spectrum","text":"# ECCO-like spectrum\ninitialize_from_spectrum!(state, grid;\n    spectrum_type = :ECCO,\n    energy_level = 1.0\n)","category":"section"},{"location":"guide/initial_conditions/#From-Data","page":"Initial Conditions","title":"From Data","text":"","category":"section"},{"location":"guide/initial_conditions/#From-NetCDF","page":"Initial Conditions","title":"From NetCDF","text":"using NCDatasets\n\n# Load from file\nNCDataset(\"initial_conditions.nc\") do ds\n    psi_init = ds[\"psi\"][:]\n    B_init = ds[\"B\"][:]\nend\n\n# Set state\nstate.psi .= psi_init\nstate.B .= B_init\n\n# Compute derived quantities\ninvert_q_to_psi!(state, grid, params, a_ell)\ncompute_velocities!(state, grid, plans)","category":"section"},{"location":"guide/initial_conditions/#Interpolation-from-Different-Grid","page":"Initial Conditions","title":"Interpolation from Different Grid","text":"# Interpolate from coarse to fine grid\npsi_fine = interpolate_field(psi_coarse, grid_coarse, grid_fine)\nstate.psi .= psi_fine","category":"section"},{"location":"guide/initial_conditions/#Spin-Up","page":"Initial Conditions","title":"Spin-Up","text":"For realistic simulations, start with random initialization and spin up:\n\n# Initialize randomly\ninitialize_random_flow!(state, grid; energy_level=0.1)\n\n# Spin-up phase (develop turbulence)\nfor step = 1:spinup_steps\n    timestep!(state, grid, params, work, plans, a_ell, dt)\nend\n\n# Now add waves\ninitialize_random_waves!(state, grid; amplitude=0.1)\n\n# Production run\nfor step = 1:nsteps\n    timestep!(...)\nend","category":"section"},{"location":"guide/initial_conditions/#Verification","page":"Initial Conditions","title":"Verification","text":"","category":"section"},{"location":"guide/initial_conditions/#Check-Initial-Energy","page":"Initial Conditions","title":"Check Initial Energy","text":"KE = flow_kinetic_energy(state.u, state.v, grid)\nWE = wave_energy(state.B, state.A, grid)[2]\n\nprintln(\"Initial KE: $KE\")\nprintln(\"Initial WE: $WE\")","category":"section"},{"location":"guide/initial_conditions/#Visualize","page":"Initial Conditions","title":"Visualize","text":"using Plots\n\n# Surface vorticity\nzeta = compute_vorticity(state.psi, grid, plans)\nheatmap(zeta[:, :, end], title=\"Initial Surface Vorticity\")\n\n# Wave amplitude\nA2 = abs2.(state.A)\nheatmap(A2[:, :, end], title=\"Initial Wave Intensity\")","category":"section"},{"location":"guide/initial_conditions/#API-Reference","page":"Initial Conditions","title":"API Reference","text":"Initial conditions can be set using:\n\ninit_random_psi! - Initialize random streamfunction field\nDirect assignment to state.q, state.B in spectral space\nReading from NetCDF files using ncread_psi!, ncread_la!\n\nSee the Grid & State API for state initialization functions.","category":"section"},{"location":"api/#API-Reference","page":"-","title":"API Reference","text":"This section provides comprehensive API documentation for QGYBJ.jl.","category":"section"},{"location":"api/#Quick-Navigation","page":"-","title":"Quick Navigation","text":"Core Types: QGParams, Grid, State\nGrid & State: Initialization and utilities\nPhysics Functions: Inversions, operators, diagnostics\nTime Stepping: Leapfrog integration\nParticles: Lagrangian particle tracking\nFull Index: Complete function reference\n\nSee the individual pages for detailed documentation of each component.","category":"section"},{"location":"simulation/#Simulation","page":"-","title":"Simulation","text":"","category":"section"},{"location":"simulation/#High‑Level-API","page":"-","title":"High‑Level API","text":"using QGYBJ\n\nconfig = create_simple_config(dt=1e-3, total_time=2.0)\nsim = setup_simulation(config)\nrun_simulation!(sim)\n\nThe QGYBJSimulation object holds:\n\nparams::QGParams, grid::Grid, state::State\nplans (FFTs), output_manager, stratification_profile, N2_profile\ncurrent_time, time_step, and diagnostics","category":"section"},{"location":"simulation/#Time-Stepping","page":"-","title":"Time Stepping","text":"The time stepper performs:\n\nFirst step: projection method (first_projection_step!)\nMain loop: leapfrog with Robert–Asselin filter (leapfrog_step!)\n\nFlags that affect integration (in QGParams):\n\nybj_plus::Bool selects YBJ+ vs. normal YBJ recovery\nno_wave_feedback::Bool disables q^w feedback on mean flow\nfixed_flow::Bool freezes mean flow (q does not evolve)\nlinear, inviscid, no_dispersion, passive_scalar","category":"section"},{"location":"simulation/#Velocities-and-Diagnostics","page":"-","title":"Velocities and Diagnostics","text":"compute_velocities! computes QG u, v and optionally w (QG omega or YBJ vertical velocity)\ncompute_total_velocities! adds wave‑induced velocities (Stokes‑like)\nDiagnostics (module Diagnostics) include wave energy, slices, and the RHS of the omega equation.","category":"section"},{"location":"api/types/#api-types","page":"Core Types","title":"Core Types","text":"This page documents the core data types in QGYBJ.jl.","category":"section"},{"location":"api/types/#QGParams","page":"Core Types","title":"QGParams","text":"The main parameter structure containing all simulation settings.","category":"section"},{"location":"api/types/#Fields","page":"Core Types","title":"Fields","text":"Field Type Description\nnx, ny, nz Int Grid dimensions\nLx, Ly, Lz Float64 Domain sizes (REQUIRED)\ndt Float64 Time step\nnt Int Number of time steps\nf₀ Float64 Coriolis parameter\nN² Float64 Buoyancy frequency squared\nγ Float64 Robert-Asselin filter coefficient\nybj_plus Bool Use YBJ+ formulation\nno_feedback Bool Master switch: disable all wave-mean coupling\nno_wave_feedback Bool Disable wave feedback on mean flow\ninviscid Bool Disable all dissipation\nlinear Bool Disable nonlinear terms\nνₕ₁ Float64 First hyperviscosity coefficient (flow)\nilap1 Int Laplacian power for νₕ₁\nνₕ₂ Float64 Second hyperviscosity coefficient (flow)\nilap2 Int Laplacian power for νₕ₂\nνₕ₁ʷ Float64 First hyperviscosity coefficient (waves)\nνₕ₂ʷ Float64 Second hyperviscosity coefficient (waves)\nνz Float64 Vertical diffusivity\n\nNote: Type Unicode characters using \\ + name + <tab> in Julia REPL (e.g., f\\_0<tab> → f₀)","category":"section"},{"location":"api/types/#Constructors","page":"Core Types","title":"Constructors","text":"# Domain size is REQUIRED (no defaults)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0)  # 500km × 500km × 4km\n\n# Custom parameters with domain size\nparams = default_params(;\n    Lx = 500e3, Ly = 500e3, Lz = 4000.0,  # Domain size (REQUIRED)\n    nx = 128, ny = 128, nz = 64,           # Grid dimensions\n    f₀ = 1.0,\n    N² = 1.0,\n    ybj_plus = true,\n    νₕ₂ = 10.0,\n    ilap2 = 6\n)","category":"section"},{"location":"api/types/#Example","page":"Core Types","title":"Example","text":"# High-resolution parameters (domain size REQUIRED)\nparams = default_params(;\n    Lx = 500e3, Ly = 500e3, Lz = 4000.0,\n    nx = 256, ny = 256, nz = 128,\n    ybj_plus = true,\n    no_feedback = false,\n    νₕ₂ = 1e-12,\n    ilap2 = 8\n)","category":"section"},{"location":"api/types/#Grid","page":"Core Types","title":"Grid","text":"The computational grid structure.","category":"section"},{"location":"api/types/#Fields-2","page":"Core Types","title":"Fields","text":"Field Type Description\nnx, ny, nz Int Grid dimensions\nLx, Ly, Lz Float64 Domain sizes\ndx, dy, dz Float64 Grid spacings\nx, y, z Vector{Float64} Coordinate arrays\nkx, ky Vector{Float64} Wavenumber arrays\nkh2 Array{Float64,2} Horizontal wavenumber squared","category":"section"},{"location":"api/types/#Constructors-2","page":"Core Types","title":"Constructors","text":"# Initialize grid from parameters (recommended)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\ngrid = init_grid(params)","category":"section"},{"location":"api/types/#Grid-Utilities","page":"Core Types","title":"Grid Utilities","text":"# Get wavenumbers at local indices (works with MPI)\nkx = get_kx(grid, i)   # Get kx at local index i\nky = get_ky(grid, j)   # Get ky at local index j\nkh2 = get_kh2(grid, i, j)  # Get horizontal wavenumber squared","category":"section"},{"location":"api/types/#State","page":"Core Types","title":"State","text":"The simulation state containing all prognostic and diagnostic fields.","category":"section"},{"location":"api/types/#Fields-3","page":"Core Types","title":"Fields","text":"Field Type Description\nq Array{ComplexF64,3} Potential vorticity (spectral)\nq_old Array{ComplexF64,3} Previous PV for leapfrog\npsi Array{ComplexF64,3} Streamfunction (spectral)\nB Array{ComplexF64,3} Wave envelope (spectral)\nB_old Array{ComplexF64,3} Previous wave envelope for leapfrog\nA Array{ComplexF64,3} Wave amplitude (spectral)\nC Array{ComplexF64,3} Vertical derivative dA/dz\nu Array{Float64,3} Zonal velocity (physical)\nv Array{Float64,3} Meridional velocity (physical)\nw Array{Float64,3} Vertical velocity (physical)","category":"section"},{"location":"api/types/#Constructors-3","page":"Core Types","title":"Constructors","text":"# Create empty state from grid\nstate = init_state(grid)","category":"section"},{"location":"api/types/#Accessing-Fields","page":"Core Types","title":"Accessing Fields","text":"# Spectral fields (complex)\npsi_k = state.psi  # size (nx÷2+1, ny, nz)\n\n# Physical fields (real)\nu = state.u        # size (nx, ny, nz)\nv = state.v        # size (nx, ny, nz)","category":"section"},{"location":"api/types/#FFT-Plans","page":"Core Types","title":"FFT Plans","text":"FFTW plan structures for efficient transforms.","category":"section"},{"location":"api/types/#Creating-Plans","page":"Core Types","title":"Creating Plans","text":"# Standard plans\nplans = plan_transforms!(grid)\n\n# With optimization\nplans = plan_transforms!(grid; flags=FFTW.MEASURE)\n\n# With threading\nFFTW.set_num_threads(8)\nplans = plan_transforms!(grid)","category":"section"},{"location":"api/types/#Using-Transforms","page":"Core Types","title":"Using Transforms","text":"# Forward transform: Physical → Spectral\nfft_forward!(dst, src, plans)\n\n# Backward transform: Spectral → Physical\nfft_backward!(dst, src, plans)","category":"section"},{"location":"api/types/#Setup-Model","page":"Core Types","title":"Setup Model","text":"The setup_model function is the recommended way to initialize all components:\n\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, nx=64, ny=64, nz=32)\nG, S, plans, a_ell = setup_model(par)\n\nThis returns:\n\nG: Grid structure\nS: State structure\nplans: FFT plans\na_ell: Elliptic coefficient array for PV inversion\n\nFor non-constant stratification, use:\n\npar = default_params(Lx=500e3, Ly=500e3, Lz=4000.0, stratification=:skewed_gaussian)\nG, S, plans, a_ell, N2_profile = setup_model_with_profile(par)","category":"section"},{"location":"api/types/#Type-Hierarchy","page":"Core Types","title":"Type Hierarchy","text":"QGParams{T}     - Model parameters\n\nGrid            - Spatial grid and wavenumbers\n\nState           - Prognostic and diagnostic fields","category":"section"},{"location":"api/types/#Type-Stability","page":"Core Types","title":"Type Stability","text":"All core types are fully type-stable:\n\nusing Test\n@inferred init_state(grid)\n@inferred leapfrog_step!(state, grid, params, plans, a_ell)","category":"section"},{"location":"api/types/#Serialization","page":"Core Types","title":"Serialization","text":"Types support JLD2 serialization:\n\nusing JLD2\n\n# Save\n@save \"simulation.jld2\" grid params state\n\n# Load\n@load \"simulation.jld2\" grid params state","category":"section"},{"location":"api/types/#QGYBJ.QGParams","page":"Core Types","title":"QGYBJ.QGParams","text":"QGParams{T}\n\nContainer for all physical and numerical parameters of the QG-YBJ+ model.\n\nDomain Parameters\n\nnx, ny, nz: Grid resolution in x, y, z directions\nLx, Ly, Lz: Domain size in x, y, z in meters (REQUIRED - no default)\n\nTime Stepping\n\ndt: Time step size\nnt: Total number of time steps\n\nPhysical Parameters\n\nf₀: Coriolis parameter (typically 1.0 for nondimensional)\nN²: Buoyancy frequency squared (default 1.0)\nW2F: DEPRECATED - no longer used (kept for backward compatibility)\nγ: Robert-Asselin filter coefficient (typically 10⁻³)\nlinear_vert_structure: Legacy Fortran flag (0 or 1), typically 0\n\nViscosity/Hyperviscosity\n\nThe model uses two hyperdiffusion operators for stability:\n\nνₕ, νᵥ: Legacy generic viscosity coefficients (prefer specific coefficients below)\nνₕ₁, ilap1: First hyperviscosity coefficient and Laplacian power for mean flow\nνₕ₂, ilap2: Second hyperviscosity coefficient and Laplacian power for mean flow\nνₕ₁ʷ, ilap1w: First hyperviscosity for waves\nνₕ₂ʷ, ilap2w: Second hyperviscosity for waves\nνz: Vertical diffusion coefficient\n\nThe hyperdiffusion term is: ν₁(-∇²)^ilap1 + ν₂(-∇²)^ilap2\n\nPhysics Switches\n\nThese boolean flags control different physics modes:\n\ninviscid: If true, disable all dissipation\nlinear: If true, disable nonlinear advection terms\nno_dispersion: If true, disable wave dispersion (A=0)\npassive_scalar: If true, waves are passive (no dispersion, no refraction)\nybj_plus: If true, use YBJ+ formulation; if false, use normal YBJ\nno_feedback: If true, disable ALL wave-mean flow coupling (master switch)\nfixed_flow: If true, mean flow doesn't evolve (ψ constant in time)\nno_wave_feedback: If true, disable qʷ term specifically (waves don't modify PV)\n\nNote: Wave feedback is enabled only when BOTH no_feedback=false AND no_wave_feedback=false.\n\nStratification Parameters (Skewed Gaussian profile)\n\nFor the skewed Gaussian N²(z) profile:     N²(z) = N₁² exp(-(z-z₀)²/σ²) [1 + erf(α(z-z₀)/(σ√2))] + N₀²\n\nN₀²_sg: Background N² (N₀²)\nN₁²_sg: Peak N² amplitude (N₁²)\nσ_sg: Width parameter (σ)\nz₀_sg: Center depth (z₀)\nα_sg: Skewness parameter (α)\n\nExample\n\npar = default_params(nx=128, ny=128, nz=64, Lx=500e3, Ly=500e3, Lz=4000.0, dt=0.001, nt=10000)\n\nSee also: default_params, with_density_profiles\n\n\n\n\n\n","category":"type"},{"location":"api/types/#QGYBJ.Grid","page":"Core Types","title":"QGYBJ.Grid","text":"Grid{T, AT}\n\nNumerical grid and spectral metadata for the QG-YBJ+ model.\n\nType Parameters\n\nT: Floating point type (typically Float64)\nAT: Array type for 2D arrays (Array{T,2} or PencilArray{T,2})\n\nFields\n\nGrid Dimensions\n\nnx, ny, nz::Int: Number of grid points in x, y, z directions\nLx, Ly, Lz::T: Domain size in x, y, z in meters (REQUIRED - no default)\ndx, dy::T: Grid spacing in x, y (computed as Lx/nx, Ly/ny)\n\nVertical Grid\n\nz::Vector{T}: Unstaggered vertical levels, length nz\ndz::Vector{T}: Layer thicknesses between levels, length nz-1 (or length 1 containing Lz when nz=1)\n\nSpectral Wavenumbers\n\nkx::Vector{T}: x-wavenumbers following FFTW convention, length nx\nky::Vector{T}: y-wavenumbers following FFTW convention, length ny\nkh2::AT: Horizontal wavenumber squared kx² + ky², size (nx, ny)\n\nParallel Decomposition\n\ndecomp::Any: PencilArrays decomposition (nothing for serial)\n\nWavenumber Convention\n\nFor a domain of size L with n points:\n\nk[i] = (2π/L) × m  where m = i-1        for i ≤ n/2\n                          m = i-1-n      for i > n/2\n\nExample\n\npar = default_params(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)\nG = init_grid(par)\n# G.kx[1] = 0 (mean mode)\n# G.kx[33] = -32 × (2π/Lx) (most negative wavenumber)\n\nSee also: init_grid, State\n\n\n\n\n\n","category":"type"},{"location":"api/types/#QGYBJ.State","page":"Core Types","title":"QGYBJ.State","text":"State{T, RT, CT}\n\nContainer for all prognostic and diagnostic fields in the QG-YBJ+ model.\n\nType Parameters\n\nT: Floating point type (Float64)\nRT: Real array type (Array{T,3} or PencilArray{T,3})\nCT: Complex array type (Array{Complex{T},3} or PencilArray{Complex{T},3})\n\nPrognostic Fields (evolved in time)\n\nq::CT: QG potential vorticity in spectral space\nB::CT: YBJ+ wave envelope B = L⁺A in spectral space\n\nDiagnostic Fields (computed from prognostic)\n\npsi::CT: Streamfunction ψ (from q via elliptic inversion)\nA::CT: Wave amplitude (from B via YBJ+ inversion)\nC::CT: Vertical derivative C = ∂A/∂z (for wave velocities)\n\nVelocity Fields (real space)\n\nu::RT: Zonal velocity u = -∂ψ/∂y\nv::RT: Meridional velocity v = ∂ψ/∂x\nw::RT: Vertical velocity (from omega equation or YBJ)\n\nArray Dimensions\n\nAll arrays have shape (nx, ny, nz).\n\nSpectral fields (q, psi, A, B, C): Complex arrays\nReal-space fields (u, v, w): Real arrays\n\nPhysical Interpretation\n\nThe prognostic variables are:\n\nq: Quasi-geostrophic potential vorticity\nRelated to ψ by: q = ∇²ψ + (f²/N²)∂²ψ/∂z²\nB: YBJ+ wave envelope\nRelated to wave amplitude A by: B = L⁺A\nL⁺ is an elliptic operator involving ∂²/∂z² and kh²\n\nExample\n\nG = init_grid(par)\nS = init_state(G)\n\n# Access fields\nq_spectral = S.q          # Complex (nx, ny, nz)\nu_realspace = S.u         # Real (nx, ny, nz)\n\nSee also: init_state, Grid\n\n\n\n\n\n","category":"type"},{"location":"physics/wave_mean/#wave-mean","page":"Wave-Mean Interaction","title":"Wave-Mean Interaction","text":"This page describes the two-way coupling between near-inertial waves and the balanced mean flow.","category":"section"},{"location":"physics/wave_mean/#Physical-Motivation","page":"Wave-Mean Interaction","title":"Physical Motivation","text":"","category":"section"},{"location":"physics/wave_mean/#Why-Waves-Affect-the-Mean-Flow","page":"Wave-Mean Interaction","title":"Why Waves Affect the Mean Flow","text":"Near-inertial waves carry momentum and energy. When they:\n\nBreak or dissipate\nRefract through vorticity gradients\nInteract nonlinearly with the flow\n\n...they can transfer energy and momentum to the balanced circulation.","category":"section"},{"location":"physics/wave_mean/#Observational-Evidence","page":"Wave-Mean Interaction","title":"Observational Evidence","text":"Anticyclones contain enhanced NIW energy (chimney effect)\nWave dissipation correlates with mixing in anticyclones\nWaves can energize the mesoscale eddy field","category":"section"},{"location":"physics/wave_mean/#The-Wave-Feedback-Term","page":"Wave-Mean Interaction","title":"The Wave Feedback Term","text":"","category":"section"},{"location":"physics/wave_mean/#Definition","page":"Wave-Mean Interaction","title":"Definition","text":"Following Xie & Vanneste (2015), the wave-induced potential vorticity is:\n\nq^w = fraci2 J(B^* B) - frac14 nabla_h^2 B^2\n\nwhere B is the complex wave envelope with units of velocity (m/s).\n\nnote: Dimensional Equations\nThe model solves dimensional equations where B has actual velocity amplitude. No additional scaling factors (like W2F) are needed.","category":"section"},{"location":"physics/wave_mean/#Decomposition-in-Real/Imaginary-Parts","page":"Wave-Mean Interaction","title":"Decomposition in Real/Imaginary Parts","text":"Writing B = B_R + i B_I, the Jacobian term becomes:\n\nfraci2 J(B^* B) = fracpartial B_Rpartial y fracpartial B_Ipartial x - fracpartial B_Rpartial x fracpartial B_Ipartial y\n\nAnd the wave intensity:\n\nB^2 = B_R^2 + B_I^2\n\nSo the complete formula in spectral space is:\n\nq^w = left( fracpartial B_Rpartial y fracpartial B_Ipartial x - fracpartial B_Rpartial x fracpartial B_Ipartial y right) + frack_h^24 (B_R^2 + B_I^2)\n\nNote: In spectral space, nabla_h^2 to -k_h^2, so -frac14nabla_h^2B^2 to +frack_h^24B^2.","category":"section"},{"location":"physics/wave_mean/#How-It-Enters-the-QG-Equation","page":"Wave-Mean Interaction","title":"How It Enters the QG Equation","text":"The wave feedback modifies the effective PV used for streamfunction inversion:\n\nq^* = q - q^w\n\nThen psi is computed from q^* via the elliptic inversion:\n\nnabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q^*","category":"section"},{"location":"physics/wave_mean/#Physical-Interpretation","page":"Wave-Mean Interaction","title":"Physical Interpretation","text":"Term Meaning\nJ(B^* B) Jacobian of complex wave field (wave momentum flux)\nnabla_h^2B^2 Horizontal curvature of wave energy density\n\nThe wave feedback represents:\n\nRadiation stress from wave momentum flux\nForm drag from wave-induced pressure fluctuations","category":"section"},{"location":"physics/wave_mean/#Energy-Exchange","page":"Wave-Mean Interaction","title":"Energy Exchange","text":"","category":"section"},{"location":"physics/wave_mean/#Wave-to-Flow-Transfer","page":"Wave-Mean Interaction","title":"Wave-to-Flow Transfer","text":"Energy flows from waves to mean flow when:\n\nmathcalE_w to f = -int psi cdot J(psi q^w)  dV\n\nThis can be positive or negative:\n\nPositive: Waves energize the flow\nNegative: Flow energizes waves (less common)","category":"section"},{"location":"physics/wave_mean/#Conservation","page":"Wave-Mean Interaction","title":"Conservation","text":"In the inviscid limit, total energy is conserved:\n\nfracddt(E_flow + E_wave) = 0\n\nThe wave feedback term merely redistributes energy.","category":"section"},{"location":"physics/wave_mean/#Refraction-Mechanism","page":"Wave-Mean Interaction","title":"Refraction Mechanism","text":"","category":"section"},{"location":"physics/wave_mean/#How-Eddies-Focus-Waves","page":"Wave-Mean Interaction","title":"How Eddies Focus Waves","text":"Anticyclones (negative vorticity) trap waves:\n\nEffective frequency is reduced: f_eff = f_0 + zeta2\nWaves propagate toward lower effective frequency\nEnergy accumulates in anticyclone cores","category":"section"},{"location":"physics/wave_mean/#The-Chimney-Effect","page":"Wave-Mean Interaction","title":"The Chimney Effect","text":"         Wind Forcing\n              ↓\n    ┌─────────────────────┐\n    │   Surface Layer     │\n    └─────────┬───────────┘\n              │\n    ┌─────────┼───────────┐\n    │    ↙    ↓    ↘      │  ← Waves spread horizontally\n    │   ↙     ↓     ↘     │\n    └──↙──────┼──────↘────┘\n       ↘      ↓      ↙\n        ↘     ↓     ↙\n         ↘    ↓    ↙        ← Anticyclone focuses waves\n    ┌─────────┼───────────┐\n    │         ↓           │\n    │    Anticyclone      │  ← Enhanced dissipation\n    │      (ζ < 0)        │\n    └─────────────────────┘\n\nWaves are funneled into anticyclones, enhancing deep mixing.","category":"section"},{"location":"physics/wave_mean/#Implementation","page":"Wave-Mean Interaction","title":"Implementation","text":"","category":"section"},{"location":"physics/wave_mean/#Computing-Wave-Feedback","page":"Wave-Mean Interaction","title":"Computing Wave Feedback","text":"# In nonlinear.jl: compute_qw!\nfunction compute_qw!(qwk, BRk, BIk, par, G, plans; Lmask=nothing)\n    # 1. Compute derivatives of BR and BI\n    # BRx = ∂BR/∂x, BRy = ∂BR/∂y, etc.\n    BRxk = im * kx .* BRk\n    BRyk = im * ky .* BRk\n    BIxk = im * kx .* BIk\n    BIyk = im * ky .* BIk\n\n    # 2. Transform to real space\n    # ...\n\n    # 3. Compute Jacobian term: BRy*BIx - BRx*BIy\n    qwr = BRyr .* BIxr - BRxr .* BIyr\n\n    # 4. Compute |B|² = BR² + BI²\n    mag2 = BRr.^2 + BIr.^2\n\n    # 5. Assemble in spectral space\n    # qw = J_term + (1/4)*kh²*|B|²  (note: -∇² → +kh² in spectral)\n    qwk = (fft(qwr) + 0.25 * kh2 .* fft(mag2)) / norm\n\n    # Note: No additional scaling needed - B has dimensional velocity units (m/s)\nend","category":"section"},{"location":"physics/wave_mean/#Usage-in-Time-Stepping","page":"Wave-Mean Interaction","title":"Usage in Time Stepping","text":"The wave feedback enters via q* = q - qw:\n\n# After computing q at new time step\nif wave_feedback_enabled\n    compute_qw!(qwk, BRk, BIk, par, G, plans; Lmask=L)\n    q_arr .-= qwk_arr  # q* = q - qw\nend\n\n# Then invert q* to get ψ\ninvert_q_to_psi!(state, grid; a=a_vec)","category":"section"},{"location":"physics/wave_mean/#Enabling/Disabling","page":"Wave-Mean Interaction","title":"Enabling/Disabling","text":"# With wave feedback (default)\nparams = default_params(; no_feedback=false, no_wave_feedback=false)\n\n# Without wave feedback\nparams = default_params(; no_feedback=true)\n# or\nparams = default_params(; no_wave_feedback=true)\n\nDisabling is useful for:\n\nStudying one-way wave-flow interaction\nIsolating wave dynamics from flow effects\nComputational efficiency when feedback is weak","category":"section"},{"location":"physics/wave_mean/#Scaling-Analysis","page":"Wave-Mean Interaction","title":"Scaling Analysis","text":"","category":"section"},{"location":"physics/wave_mean/#When-is-Feedback-Important?","page":"Wave-Mean Interaction","title":"When is Feedback Important?","text":"The feedback strength scales as:\n\nfracq^wq sim left(fracA_0Uright)^2 cdot left(fracL_wLright)^2\n\nwhere:\n\nA_0U: Wave-to-flow velocity ratio\nL_wL: Wave-to-eddy length ratio\n\nFeedback matters when:\n\nStrong wind forcing (large A_0)\nCompact wave packets (small L_w)\nWeak background flow (small U)","category":"section"},{"location":"physics/wave_mean/#Typical-Values","page":"Wave-Mean Interaction","title":"Typical Values","text":"Scenario Wave Feedback\nWeak winds, strong eddies Negligible\nStorm forcing Moderate (1-10%)\nTropical cyclone Strong (10-50%)","category":"section"},{"location":"physics/wave_mean/#Coupled-Dynamics","page":"Wave-Mean Interaction","title":"Coupled Dynamics","text":"","category":"section"},{"location":"physics/wave_mean/#Feedback-Loop","page":"Wave-Mean Interaction","title":"Feedback Loop","text":"┌──────────────┐         ┌──────────────┐\n│              │         │              │\n│   Eddies     │◄────────│    Waves     │\n│   (ψ, q)     │         │   (A, B)     │\n│              │         │              │\n└──────┬───────┘         └──────┬───────┘\n       │                        │\n       │ Refraction             │ Feedback\n       │ ∂ζ/∂t                  │ qw\n       │                        │\n       ▼                        ▼\n┌──────────────────────────────────────┐\n│                                      │\n│       Wave-Mean Energy Exchange      │\n│                                      │\n└──────────────────────────────────────┘","category":"section"},{"location":"physics/wave_mean/#Equilibration","page":"Wave-Mean Interaction","title":"Equilibration","text":"The coupled system can reach statistical equilibrium where:\n\nWave generation (wind) balances dissipation\nEnergy flux from waves to flow balances eddy dissipation\nNet energy is constant on average","category":"section"},{"location":"physics/wave_mean/#Diagnostics","page":"Wave-Mean Interaction","title":"Diagnostics","text":"","category":"section"},{"location":"physics/wave_mean/#Monitoring-Energy-Exchange","page":"Wave-Mean Interaction","title":"Monitoring Energy Exchange","text":"# Compute wave feedback contribution\nqw = compute_wave_pv(state.A, grid)\n\n# Energy exchange rate\nexchange_rate = compute_energy_exchange(state.psi, qw, grid, plans)","category":"section"},{"location":"physics/wave_mean/#Typical-Analysis","page":"Wave-Mean Interaction","title":"Typical Analysis","text":"Track E_flow and E_wave over time\nCompute their time derivatives\nCompare with wave feedback term to verify energy conservation","category":"section"},{"location":"physics/wave_mean/#Complete-Energy-Budget","page":"Wave-Mean Interaction","title":"Complete Energy Budget","text":"","category":"section"},{"location":"physics/wave_mean/#Energy-Components","page":"Wave-Mean Interaction","title":"Energy Components","text":"The total energy of the QG-YBJ+ system consists of five components:\n\nE_total = underbraceE_KE^flow + E_PE^flow_textMean flow energy + underbraceE_KE^wave + E_PE^wave + E_CE^wave_textWave energy","category":"section"},{"location":"physics/wave_mean/#Mean-Flow-Kinetic-Energy","page":"Wave-Mean Interaction","title":"Mean Flow Kinetic Energy","text":"E_KE^flow = frac12 int int int (u^2 + v^2)  dx dy dz\n\nIn spectral space with dealiasing:\n\nE_KE^flow = frac12 sum_k_x k_y z L(k_x k_y) cdot k_h^2 hatpsi^2 - frac12hatpsi(k_h=0)^2\n\nwhere L(k_x k_y) is the dealiasing mask (2/3 rule) and the second term corrects for the zero-wavenumber mode.","category":"section"},{"location":"physics/wave_mean/#Mean-Flow-Potential-Energy","page":"Wave-Mean Interaction","title":"Mean Flow Potential Energy","text":"E_PE^flow = frac12 int int int fracf_0^2N^2 left(fracpartial psipartial zright)^2 dx dy dz\n\nIn spectral space:\n\nE_PE^flow = frac12 sum_k_x k_y z fracf_0^2N^2(z) hatb^2\n\nwhere b = partialpsipartial z is the buoyancy from thermal wind balance.","category":"section"},{"location":"physics/wave_mean/#Wave-Kinetic-Energy","page":"Wave-Mean Interaction","title":"Wave Kinetic Energy","text":"E_KE^wave = frac12 int int int B^2  dx dy dz\n\nIn spectral space with B = B_R + iB_I:\n\nE_KE^wave = frac12 sum_k_x k_y z (hatB_R^2 + hatB_I^2) - frac12hatB(k_h=0)^2","category":"section"},{"location":"physics/wave_mean/#Wave-Potential-Energy","page":"Wave-Mean Interaction","title":"Wave Potential Energy","text":"From the YBJ+ formulation, the wave potential energy involves C = partial Apartial z:\n\nE_PE^wave = frac12 int int int fracN^22f_0^2 k_h^2 C^2  dx dy dz\n\nIn spectral space:\n\nE_PE^wave = frac12 sum_k_x k_y z frack_h^22 a_ell (hatC_R^2 + hatC_I^2)\n\nwhere a_ell = f_0^2N^2 is the elliptic coefficient.","category":"section"},{"location":"physics/wave_mean/#Wave-Correction-Energy-(YBJ)","page":"Wave-Mean Interaction","title":"Wave Correction Energy (YBJ+)","text":"The YBJ+ equation introduces a higher-order correction:\n\nE_CE^wave = frac18 int int int fracN^4f_0^4 k_h^4 A^2  dx dy dz\n\nIn spectral space:\n\nE_CE^wave = frac12 sum_k_x k_y z frack_h^48 a_ell^2 (hatA_R^2 + hatA_I^2)\n\nThis term accounts for horizontal wave dispersion and becomes significant at small scales.","category":"section"},{"location":"physics/wave_mean/#Energy-Conservation-Theorem","page":"Wave-Mean Interaction","title":"Energy Conservation Theorem","text":"Theorem: In the inviscid limit (no dissipation), the total energy is conserved:\n\nfracdE_totaldt = 0\n\nProof sketch:\n\nThe QG PV equation conserves mean flow energy in the absence of wave feedback\nThe YBJ+ equation conserves wave energy in the absence of mean flow\nThe wave feedback term q^w transfers energy between waves and flow without dissipation\nThe refraction term frac12B cdot zeta exchanges energy via wave-vorticity interaction","category":"section"},{"location":"physics/wave_mean/#Energy-Transfer-Pathways","page":"Wave-Mean Interaction","title":"Energy Transfer Pathways","text":"                    Wind Forcing\n                         │\n                         ▼\n    ┌────────────────────────────────────────┐\n    │           Wave Energy                  │\n    │   E_KE^wave + E_PE^wave + E_CE^wave    │\n    └────────────────┬───────────────────────┘\n                     │\n           Refraction │ Wave Feedback\n           (B·ζ term) │ (q^w term)\n                     │\n                     ▼\n    ┌────────────────────────────────────────┐\n    │         Mean Flow Energy               │\n    │        E_KE^flow + E_PE^flow           │\n    └────────────────┬───────────────────────┘\n                     │\n                     ▼\n              Viscous Dissipation","category":"section"},{"location":"physics/wave_mean/#Energy-Exchange-Rate","page":"Wave-Mean Interaction","title":"Energy Exchange Rate","text":"The rate of energy transfer from waves to mean flow is:\n\nmathcalP_w to f = -int psi cdot J(psi q^w)  dV\n\nThis can be computed diagnostically:\n\n# Compute energy exchange rate\nqw = compute_qw(state, grid, params, plans)\nP_exchange = -sum(psi .* jacobian(psi, qw, grid, plans))","category":"section"},{"location":"physics/wave_mean/#Energy-Scales","page":"Wave-Mean Interaction","title":"Energy Scales","text":"Using the characteristic scales:\n\nVelocity: U (mean flow), U_w (waves)\nLength: L (horizontal), H (vertical)\nTime: 1f_0\n\nThe energy ratio scales as:\n\nfracE^waveE^flow sim left(fracU_wUright)^2\n\nTypical oceanic values for wave-to-flow energy ratio:\n\nGulf Stream region: sim 10^-2 to 10^-1\nOpen ocean: sim 10^-3\nAfter storm: sim 1","category":"section"},{"location":"physics/wave_mean/#Diagnostic-Implementation","page":"Wave-Mean Interaction","title":"Diagnostic Implementation","text":"Energy diagnostics are automatically saved to separate files:\n\n# Output files in diagnostic/ folder:\n# - wave_KE.nc: E_KE^wave time series\n# - wave_PE.nc: E_PE^wave time series\n# - wave_CE.nc: E_CE^wave time series\n# - mean_flow_KE.nc: E_KE^flow time series\n# - mean_flow_PE.nc: E_PE^flow time series\n# - total_energy.nc: All energies + totals\n\n# Verify conservation\nds = NCDataset(\"output/diagnostic/total_energy.nc\")\nE_total = ds[\"total_energy\"][:]\ndE = (E_total[end] - E_total[1]) / E_total[1]\n# Should be < 10^-6 for inviscid runs\n\nSee Diagnostics Guide for detailed usage.","category":"section"},{"location":"physics/wave_mean/#References","page":"Wave-Mean Interaction","title":"References","text":"Xie, J.-H., & Vanneste, J. (2015). A generalised-Lagrangian-mean model of the interactions between near-inertial waves and mean flow. J. Fluid Mech., 774, 143-169.\nWagner, G. L., & Young, W. R. (2016). A three-component model for the coupled evolution of near-inertial waves, quasi-geostrophic flow and the near-inertial second harmonic. J. Fluid Mech., 802, 806-837.\nAsselin, O., & Young, W. R. (2019). An improved model of near-inertial wave dynamics. J. Fluid Mech., 876, 428-448.","category":"section"},{"location":"advanced/performance/#performance","page":"Performance Tips","title":"Performance Tips","text":"This page provides guidance for optimizing QGYBJ.jl performance.","category":"section"},{"location":"advanced/performance/#Quick-Performance-Wins","page":"Performance Tips","title":"Quick Performance Wins","text":"","category":"section"},{"location":"advanced/performance/#1.-Use-FFTW-Wisdom","page":"Performance Tips","title":"1. Use FFTW Wisdom","text":"Pre-compute optimal FFT plans:\n\nusing FFTW\n\n# Measure FFT plans (slower startup, faster runtime)\nFFTW.set_num_threads(Threads.nthreads())\nplans = plan_transforms!(grid; flags=FFTW.MEASURE)\n\n# For production: save and load wisdom\nFFTW.export_wisdom(\"fftw_wisdom.txt\")\n# Later:\nFFTW.import_wisdom(\"fftw_wisdom.txt\")","category":"section"},{"location":"advanced/performance/#2.-Enable-Multi-threading","page":"Performance Tips","title":"2. Enable Multi-threading","text":"# Set threads before running Julia\nexport JULIA_NUM_THREADS=8\njulia --threads=8 simulation.jl\n\nIn Julia:\n\n# Check thread count\nThreads.nthreads()\n\n# FFTW uses its own threading\nFFTW.set_num_threads(8)","category":"section"},{"location":"advanced/performance/#3.-Use-Appropriate-Precision","page":"Performance Tips","title":"3. Use Appropriate Precision","text":"# Double precision (default, most accurate)\nstate = create_state(grid; T=Float64)\n\n# Single precision (2x memory savings, faster)\nstate = create_state(grid; T=Float32)\n\nwarning: Warning\nSingle precision may cause numerical instabilities for long simulations.","category":"section"},{"location":"advanced/performance/#Memory-Optimization","page":"Performance Tips","title":"Memory Optimization","text":"","category":"section"},{"location":"advanced/performance/#Pre-allocation","page":"Performance Tips","title":"Pre-allocation","text":"All arrays are pre-allocated to avoid GC:\n\n# Work arrays created once\nwork = create_work_arrays(grid)\n\n# Reused every time step\ntimestep!(state, grid, params, work, plans, a_ell, dt)","category":"section"},{"location":"advanced/performance/#Memory-Usage-Estimate","page":"Performance Tips","title":"Memory Usage Estimate","text":"function estimate_memory(nx, ny, nz; T=Float64)\n    # Main arrays\n    complex_size = sizeof(Complex{T}) * (nx÷2+1) * ny * nz\n    real_size = sizeof(T) * nx * ny * nz\n\n    n_complex = 10  # psi, q, B, A, etc.\n    n_real = 5      # u, v, work arrays\n\n    total = n_complex * complex_size + n_real * real_size\n    return total / 1e9  # GB\nend\n\nprintln(\"Memory: \", estimate_memory(256, 256, 128), \" GB\")","category":"section"},{"location":"advanced/performance/#Memory-Efficient-Output","page":"Performance Tips","title":"Memory-Efficient Output","text":"Write in chunks rather than storing everything:\n\n# Don't do this (stores all data)\nall_psi = zeros(nx, ny, nz, nsteps)\n\n# Do this (stream to disk)\nfor step = 1:nsteps\n    timestep!(state, ...)\n    if step % output_interval == 0\n        write_to_disk(state.psi, step)\n    end\nend","category":"section"},{"location":"advanced/performance/#Computational-Bottlenecks","page":"Performance Tips","title":"Computational Bottlenecks","text":"","category":"section"},{"location":"advanced/performance/#Profiling","page":"Performance Tips","title":"Profiling","text":"using Profile\n\n@profile run_simulation(config)\nProfile.print(mincount=100)\n\n# Flamegraph visualization\nusing ProfileSVG\nProfileSVG.save(\"profile.svg\")","category":"section"},{"location":"advanced/performance/#Typical-Time-Distribution","page":"Performance Tips","title":"Typical Time Distribution","text":"Operation Fraction Optimization\nFFT/IFFT 40-50% FFTW wisdom, threading\nTridiagonal solves 20-30% Pre-factorization\nArray operations 15-25% Loop fusion with @.\nI/O 5-10% Buffering, compression","category":"section"},{"location":"advanced/performance/#Timing-Individual-Components","page":"Performance Tips","title":"Timing Individual Components","text":"using BenchmarkTools\n\n# Time FFT\n@btime fft_forward!($work.tmp_k, $work.tmp, $plans)\n\n# Time elliptic solve\n@btime invert_q_to_psi!($state, $grid, $params, $a_ell)\n\n# Time full step\n@btime timestep!($state, $grid, $params, $work, $plans, $a_ell, $dt)","category":"section"},{"location":"advanced/performance/#Numerical-Efficiency","page":"Performance Tips","title":"Numerical Efficiency","text":"","category":"section"},{"location":"advanced/performance/#Time-Step-Selection","page":"Performance Tips","title":"Time Step Selection","text":"Use the largest stable time step:\n\n# CFL-based time step\nu_max = maximum(abs.(state.u))\ndt_cfl = 0.5 * grid.dx / u_max\n\n# Use slightly smaller for safety\ndt = 0.8 * dt_cfl","category":"section"},{"location":"advanced/performance/#Adaptive-Time-Stepping","page":"Performance Tips","title":"Adaptive Time Stepping","text":"function adaptive_dt(state, grid, params; cfl=0.5, dt_max=0.01)\n    u_max = maximum(abs.(state.u))\n    v_max = maximum(abs.(state.v))\n\n    dx = grid.Lx / grid.nx\n    dy = grid.Ly / grid.ny\n\n    dt = cfl * min(dx/u_max, dy/v_max)\n    return min(dt, dt_max)\nend","category":"section"},{"location":"advanced/performance/#Dissipation-Tuning","page":"Performance Tips","title":"Dissipation Tuning","text":"Too much dissipation wastes resolution. Too little causes instability.\n\n# Minimal dissipation for given resolution\nnu_h2 = 1e-4 * (2π/nx)^8  # Scales with grid spacing\n\n# Or based on energy pile-up check\nE_k = horizontal_energy_spectrum(state.psi, grid)\nif E_k[end] > 0.01 * maximum(E_k)\n    @warn \"Energy piling up at small scales, increase dissipation\"\nend","category":"section"},{"location":"advanced/performance/#Loop-Optimization","page":"Performance Tips","title":"Loop Optimization","text":"","category":"section"},{"location":"advanced/performance/#Broadcasting","page":"Performance Tips","title":"Broadcasting","text":"Use @. for fused operations:\n\n# Slow (multiple allocations)\nresult = a .+ b .* c\n\n# Fast (single pass, no allocation)\n@. result = a + b * c","category":"section"},{"location":"advanced/performance/#In-place-Operations","page":"Performance Tips","title":"In-place Operations","text":"# Allocating\nb = fft(a)\n\n# In-place\nmul!(b, plan, a)","category":"section"},{"location":"advanced/performance/#Loop-Order","page":"Performance Tips","title":"Loop Order","text":"Julia is column-major (like Fortran):\n\n# Fast (memory-contiguous)\nfor k in 1:nz\n    for j in 1:ny\n        for i in 1:nx\n            a[i, j, k] = ...\n        end\n    end\nend\n\n# Slow (cache-unfriendly)\nfor i in 1:nx\n    for j in 1:ny\n        for k in 1:nz\n            a[i, j, k] = ...\n        end\n    end\nend","category":"section"},{"location":"advanced/performance/#SIMD-and-LoopVectorization","page":"Performance Tips","title":"SIMD and LoopVectorization","text":"using LoopVectorization\n\n# Auto-vectorized loop\n@turbo for i in eachindex(a)\n    a[i] = b[i] * c[i] + d[i]\nend","category":"section"},{"location":"advanced/performance/#GPU-Acceleration","page":"Performance Tips","title":"GPU Acceleration","text":"","category":"section"},{"location":"advanced/performance/#CUDA-Support","page":"Performance Tips","title":"CUDA Support","text":"using CUDA\n\n# Move arrays to GPU\nstate_gpu = cu(state)\ngrid_gpu = cu(grid)\n\n# GPU FFT plans\nplans_gpu = plan_gpu_transforms!(grid_gpu)\n\n# Run on GPU\ntimestep!(state_gpu, grid_gpu, params, work_gpu, plans_gpu, a_ell_gpu, dt)","category":"section"},{"location":"advanced/performance/#When-to-Use-GPU","page":"Performance Tips","title":"When to Use GPU","text":"Scenario Recommendation\nnx, ny < 256 CPU often faster\nnx, ny ≥ 512 GPU beneficial\nMany particles GPU for interpolation\nMPI cluster CPU per node","category":"section"},{"location":"advanced/performance/#Parallelization-Strategy","page":"Performance Tips","title":"Parallelization Strategy","text":"","category":"section"},{"location":"advanced/performance/#Shared-Memory-(OpenMP/Threads)","page":"Performance Tips","title":"Shared Memory (OpenMP/Threads)","text":"Best for:\n\nSingle node\nnx × ny < 512²\nMemory-bound operations\n\n# Set threads\nThreads.@threads for k in 1:nz\n    process_layer!(state, k)\nend","category":"section"},{"location":"advanced/performance/#Distributed-Memory-(MPI)","page":"Performance Tips","title":"Distributed Memory (MPI)","text":"Best for:\n\nMultiple nodes\nnx × ny ≥ 512²\nLarge domains\n\nmpiexec -n 64 julia simulation.jl","category":"section"},{"location":"advanced/performance/#Hybrid-(MPI-Threads)","page":"Performance Tips","title":"Hybrid (MPI + Threads)","text":"# 4 MPI ranks × 8 threads each = 32 cores\nexport JULIA_NUM_THREADS=8\nmpiexec -n 4 julia simulation.jl","category":"section"},{"location":"advanced/performance/#I/O-Performance","page":"Performance Tips","title":"I/O Performance","text":"","category":"section"},{"location":"advanced/performance/#Buffered-Output","page":"Performance Tips","title":"Buffered Output","text":"# Write less frequently\noutput_interval = 1000  # Not every step\n\n# Buffer multiple snapshots\nbuffer_size = 10\noutput_buffer = zeros(nx, ny, nz, buffer_size)","category":"section"},{"location":"advanced/performance/#Compression","page":"Performance Tips","title":"Compression","text":"using NCDatasets\n\n# Compressed NetCDF\ndefVar(ds, \"psi\", Float64, (\"x\", \"y\", \"z\", \"t\");\n    deflatelevel = 5,\n    chunksizes = (nx, ny, nz, 1)\n)","category":"section"},{"location":"advanced/performance/#Parallel-I/O","page":"Performance Tips","title":"Parallel I/O","text":"# HDF5 with MPI I/O\nusing HDF5\n\nh5open(\"output.h5\", \"w\", mpi_comm) do fid\n    write_mpi(fid, \"psi\", local_psi, global_dims, local_range)\nend","category":"section"},{"location":"advanced/performance/#Benchmarking-Guide","page":"Performance Tips","title":"Benchmarking Guide","text":"","category":"section"},{"location":"advanced/performance/#Full-Benchmark-Suite","page":"Performance Tips","title":"Full Benchmark Suite","text":"function benchmark_simulation(nx, ny, nz; nsteps=100, Lx=500e3, Ly=500e3, Lz=4000.0)\n    grid = Grid(nx=nx, ny=ny, nz=nz)\n    params = default_params(Lx=Lx, Ly=Ly, Lz=Lz)  # Domain size is REQUIRED\n    state = create_state(grid)\n    initialize_random!(state, grid)\n\n    work = create_work_arrays(grid)\n    plans = plan_transforms!(grid)\n    a_ell = setup_elliptic_matrices(grid, params)\n\n    # Warm-up\n    for _ in 1:10\n        timestep!(state, grid, params, work, plans, a_ell, 0.001)\n    end\n\n    # Timed run\n    t_start = time()\n    for _ in 1:nsteps\n        timestep!(state, grid, params, work, plans, a_ell, 0.001)\n    end\n    t_end = time()\n\n    dt_avg = (t_end - t_start) / nsteps\n    throughput = nx * ny * nz / dt_avg / 1e6  # Million cells/second\n\n    return (dt_avg=dt_avg, throughput=throughput)\nend\n\n# Run benchmark\nresult = benchmark_simulation(128, 128, 64)\nprintln(\"Time per step: $(result.dt_avg*1000) ms\")\nprintln(\"Throughput: $(result.throughput) Mcells/s\")","category":"section"},{"location":"advanced/performance/#Scaling-Tests","page":"Performance Tips","title":"Scaling Tests","text":"# Strong scaling\nfor nprocs in [1, 2, 4, 8, 16]\n    # Run with mpiexec -n $nprocs\n    run_benchmark(256, 256, 128)\nend\n\n# Weak scaling\nfor n in [64, 128, 256, 512]\n    run_benchmark(n, n, n÷2)\nend","category":"section"},{"location":"advanced/performance/#Summary-Checklist","page":"Performance Tips","title":"Summary Checklist","text":"Before running:\n[ ] Set JULIA_NUM_THREADS appropriately\n[ ] Enable FFTW threading\n[ ] Use FFTW.MEASURE for plans\n[ ] Pre-allocate all arrays\nFor production:\n[ ] Profile to find bottlenecks\n[ ] Use appropriate time step (CFL)\n[ ] Minimize I/O frequency\n[ ] Enable compression for output\nFor large runs:\n[ ] Use MPI for distributed memory\n[ ] Consider GPU for large grids\n[ ] Use parallel I/O\n[ ] Monitor memory usage","category":"section"},{"location":"guide/simulation/#running","page":"Running Simulations","title":"Running Simulations","text":"This page explains how to run and monitor QGYBJ.jl simulations.","category":"section"},{"location":"guide/simulation/#Quick-Start","page":"Running Simulations","title":"Quick Start","text":"","category":"section"},{"location":"guide/simulation/#Simple-Interface","page":"Running Simulations","title":"Simple Interface","text":"using QGYBJ\n\nconfig = create_simple_config(\n    nx=64, ny=64, nz=32,\n    dt=0.001,\n    total_time=10.0\n)\n\nresult = run_simple_simulation(config)","category":"section"},{"location":"guide/simulation/#Manual-Control","page":"Running Simulations","title":"Manual Control","text":"# Setup with domain size (REQUIRED)\ngrid = Grid(nx=64, ny=64, nz=32)\nparams = default_params(Lx=500e3, Ly=500e3, Lz=4000.0)  # 500km × 500km × 4km\nstate = create_state(grid)\ninitialize_random_flow!(state, grid)\ninitialize_random_waves!(state, grid)\n\nwork = create_work_arrays(grid)\nplans = plan_transforms!(grid)\na_ell = setup_elliptic_matrices(grid, params)\n\n# Time loop\ndt = 0.001\nnsteps = 10000\n\nfor step = 1:nsteps\n    timestep!(state, grid, params, work, plans, a_ell, dt)\nend","category":"section"},{"location":"guide/simulation/#Time-Stepping","page":"Running Simulations","title":"Time Stepping","text":"","category":"section"},{"location":"guide/simulation/#The-timestep!-Function","page":"Running Simulations","title":"The timestep! Function","text":"timestep!(state, grid, params, work, plans, a_ell, dt)\n\nThis performs one AB3 time step, including:\n\nCompute nonlinear terms (Jacobians, refraction)\nApply integrating factors for diffusion\nUpdate prognostic variables (q, B)\nInvert elliptic equations (q→ψ, B→A)\nCompute velocities","category":"section"},{"location":"guide/simulation/#Adaptive-Time-Stepping","page":"Running Simulations","title":"Adaptive Time Stepping","text":"function adaptive_timestep!(state, grid, params, work, plans, a_ell;\n                            cfl=0.5, dt_min=1e-6, dt_max=0.01)\n    # Compute CFL-based dt\n    u_max = maximum(abs.(state.u))\n    v_max = maximum(abs.(state.v))\n    dt = cfl * min(grid.dx/u_max, grid.dy/v_max)\n\n    # Clamp to limits\n    dt = clamp(dt, dt_min, dt_max)\n\n    # Take step\n    timestep!(state, grid, params, work, plans, a_ell, dt)\n\n    return dt\nend","category":"section"},{"location":"guide/simulation/#Progress-Monitoring","page":"Running Simulations","title":"Progress Monitoring","text":"","category":"section"},{"location":"guide/simulation/#Basic-Progress","page":"Running Simulations","title":"Basic Progress","text":"for step = 1:nsteps\n    timestep!(...)\n\n    if step % 100 == 0\n        println(\"Step $step / $nsteps ($(100*step/nsteps)%)\")\n    end\nend","category":"section"},{"location":"guide/simulation/#With-Diagnostics","page":"Running Simulations","title":"With Diagnostics","text":"for step = 1:nsteps\n    timestep!(...)\n\n    if step % 100 == 0\n        KE = flow_kinetic_energy(state.u, state.v, grid)\n        WE = wave_energy(state.B, state.A, grid)[2]\n        println(\"Step $step: KE=$KE, WE=$WE\")\n    end\nend","category":"section"},{"location":"guide/simulation/#Progress-Bar","page":"Running Simulations","title":"Progress Bar","text":"using ProgressMeter\n\n@showprogress for step = 1:nsteps\n    timestep!(...)\nend","category":"section"},{"location":"guide/simulation/#Checkpointing","page":"Running Simulations","title":"Checkpointing","text":"","category":"section"},{"location":"guide/simulation/#Save-Checkpoints","page":"Running Simulations","title":"Save Checkpoints","text":"checkpoint_interval = 1000\n\nfor step = 1:nsteps\n    timestep!(...)\n\n    if step % checkpoint_interval == 0\n        filename = \"checkpoint_$(lpad(step, 8, '0')).jld2\"\n        @save filename state grid params step\n    end\nend","category":"section"},{"location":"guide/simulation/#Restart-from-Checkpoint","page":"Running Simulations","title":"Restart from Checkpoint","text":"using JLD2\n\n# Load checkpoint\n@load \"checkpoint_00005000.jld2\" state grid params step\n\n# Continue simulation\nfor step = step+1:nsteps\n    timestep!(...)\nend","category":"section"},{"location":"guide/simulation/#Stability-Monitoring","page":"Running Simulations","title":"Stability Monitoring","text":"","category":"section"},{"location":"guide/simulation/#CFL-Check","page":"Running Simulations","title":"CFL Check","text":"function check_cfl(state, grid, dt)\n    u_max = maximum(abs.(state.u))\n    v_max = maximum(abs.(state.v))\n    cfl = dt * max(u_max/grid.dx, v_max/grid.dy)\n    return cfl\nend\n\nfor step = 1:nsteps\n    timestep!(...)\n\n    cfl = check_cfl(state, grid, dt)\n    if cfl > 1.0\n        @warn \"CFL > 1 at step $step: $cfl\"\n    end\nend","category":"section"},{"location":"guide/simulation/#Energy-Conservation","page":"Running Simulations","title":"Energy Conservation","text":"E0 = flow_total_energy(state, grid, params)\n\nfor step = 1:nsteps\n    timestep!(...)\n\n    if step % 100 == 0\n        E = flow_total_energy(state, grid, params)\n        dE = (E - E0) / E0\n        if abs(dE) > 0.1\n            @warn \"Energy drift: $dE at step $step\"\n        end\n    end\nend","category":"section"},{"location":"guide/simulation/#Output-During-Simulation","page":"Running Simulations","title":"Output During Simulation","text":"","category":"section"},{"location":"guide/simulation/#Snapshots","page":"Running Simulations","title":"Snapshots","text":"output_interval = 100\noutput_steps = Int[]\noutput_times = Float64[]\n\nfor step = 1:nsteps\n    timestep!(...)\n    time = step * dt\n\n    if step % output_interval == 0\n        push!(output_steps, step)\n        push!(output_times, time)\n\n        # Save to NetCDF\n        write_snapshot(state, grid, step, time, \"output/\")\n    end\nend","category":"section"},{"location":"guide/simulation/#Time-Series","page":"Running Simulations","title":"Time Series","text":"KE_history = Float64[]\nWE_history = Float64[]\ntime_history = Float64[]\n\nfor step = 1:nsteps\n    timestep!(...)\n\n    push!(time_history, step * dt)\n    push!(KE_history, flow_kinetic_energy(state.u, state.v, grid))\n    push!(WE_history, wave_energy(state.B, state.A, grid)[2])\nend","category":"section"},{"location":"guide/simulation/#Parallel-Execution","page":"Running Simulations","title":"Parallel Execution","text":"","category":"section"},{"location":"guide/simulation/#Multi-threaded","page":"Running Simulations","title":"Multi-threaded","text":"# Set before starting Julia\nexport JULIA_NUM_THREADS=8\n\n# Or check in code\nprintln(\"Using $(Threads.nthreads()) threads\")","category":"section"},{"location":"guide/simulation/#MPI","page":"Running Simulations","title":"MPI","text":"using MPI\nMPI.Init()\n\n# Run with: mpiexec -n 16 julia simulation.jl\n\nSee MPI Parallelization for details.","category":"section"},{"location":"guide/simulation/#Common-Patterns","page":"Running Simulations","title":"Common Patterns","text":"","category":"section"},{"location":"guide/simulation/#Production-Run-Template","page":"Running Simulations","title":"Production Run Template","text":"using QGYBJ\nusing JLD2\n\nfunction run_production(;\n    nx, ny, nz, dt, nsteps,\n    Lx, Ly, Lz,  # Domain size is REQUIRED\n    output_interval=100,\n    checkpoint_interval=1000,\n    output_dir=\"output\"\n)\n    # Setup\n    mkpath(output_dir)\n    grid = Grid(nx=nx, ny=ny, nz=nz)\n    params = default_params(Lx=Lx, Ly=Ly, Lz=Lz)  # Domain size is REQUIRED\n    state = create_state(grid)\n    initialize_random_flow!(state, grid)\n    initialize_random_waves!(state, grid)\n\n    work = create_work_arrays(grid)\n    plans = plan_transforms!(grid)\n    a_ell = setup_elliptic_matrices(grid, params)\n\n    # Time loop\n    for step = 1:nsteps\n        timestep!(state, grid, params, work, plans, a_ell, dt)\n\n        # Output\n        if step % output_interval == 0\n            write_snapshot(state, grid, step, step*dt, output_dir)\n        end\n\n        # Checkpoint\n        if step % checkpoint_interval == 0\n            @save \"$output_dir/checkpoint.jld2\" state grid params step\n        end\n    end\n\n    return state\nend","category":"section"},{"location":"guide/simulation/#Troubleshooting","page":"Running Simulations","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/simulation/#NaN-Values","page":"Running Simulations","title":"NaN Values","text":"if any(isnan, state.psi)\n    error(\"NaN detected at step $step\")\nend","category":"section"},{"location":"guide/simulation/#Instability","page":"Running Simulations","title":"Instability","text":"Reduce time step\nIncrease dissipation\nCheck initial conditions for sharp gradients","category":"section"},{"location":"guide/simulation/#Memory-Issues","page":"Running Simulations","title":"Memory Issues","text":"Reduce grid size\nUse checkpointing\nEnable MPI for distribution","category":"section"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Package-Instantiation-Errors","page":"Troubleshooting","title":"Package Instantiation Errors","text":"Symptom: Package <X> is a direct dependency, but does not appear in the manifest\nFix: run Pkg.resolve(); Pkg.instantiate(); Pkg.precompile() in the project.","category":"section"},{"location":"troubleshooting/#Missing-NCDatasets-(NetCDF-I/O)","page":"Troubleshooting","title":"Missing NCDatasets (NetCDF I/O)","text":"Symptom: NCDatasets not available. Install NCDatasets.jl or skip NetCDF I/O.\nFix: julia --project=. -e 'using Pkg; Pkg.add(\"NCDatasets\")'\nAlternatively, disable NetCDF I/O by setting save_* to false in OutputConfig.","category":"section"},{"location":"troubleshooting/#FFT-Issues-on-HPC/Clusters","page":"Troubleshooting","title":"FFT Issues on HPC/Clusters","text":"Install system FFTW or let FFTW.jl download binaries automatically.\nEnsure using FFTW works and that shared libraries are available in your environment.","category":"section"},{"location":"troubleshooting/#MPI/Pencil-Setup","page":"Troubleshooting","title":"MPI/Pencil Setup","text":"Install MPI.jl and PencilArrays/PencilFFTs.\nLaunch with mpiexec -n <N> julia --project=. your_script.jl and pass use_mpi=true to setup_simulation.","category":"section"},{"location":"troubleshooting/#Stability/Time-Step","page":"Troubleshooting","title":"Stability/Time Step","text":"If you see blow‑ups or NaNs:\nReduce dt\nIncrease resolution\nEnable viscosity/hyperdiffusion (see parameters in QGParams)\nStart with linear=true to isolate linear dynamics","category":"section"},{"location":"configuration/#Configuration","page":"-","title":"Configuration","text":"QGYBJ.jl provides a high‑level configuration system for domains, stratification, initial conditions, and output.","category":"section"},{"location":"configuration/#Domain","page":"-","title":"Domain","text":"domain = create_domain_config(\n    nx=128, ny=128, nz=64,\n    Lx=4π, Ly=4π, Lz=2π,\n)","category":"section"},{"location":"configuration/#Stratification","page":"-","title":"Stratification","text":"# Constant N²\nstrat = create_stratification_config(:constant_N, N0=1.0)\n\n# Skewed Gaussian (Fortran test case parameters)\nstrat = create_stratification_config(:skewed_gaussian)\n\n# Tanh profile\nstrat = create_stratification_config(:tanh_profile,\n    N_upper=0.01, N_lower=0.025, z_pycno=0.6, width=0.05)\n\n# From NetCDF file containing an N²(z) variable\nstrat = create_stratification_config(:from_file, filename=\"N2_profile.nc\")","category":"section"},{"location":"configuration/#Initial-Conditions","page":"-","title":"Initial Conditions","text":"init = create_initial_condition_config(\n    psi_type=:random,     # :analytical, :from_file, :random\n    wave_type=:random,    # :zero, :analytical, :from_file, :random\n    wave_amplitude=1e-3,\n    random_seed=1234,\n)","category":"section"},{"location":"configuration/#Output","page":"-","title":"Output","text":"output = create_output_config(\n    output_dir=\"./output\",\n    psi_interval=1.0,\n    wave_interval=1.0,\n    diagnostics_interval=0.5,\n    save_psi=true,\n    save_waves=true,\n    save_velocities=true,\n    save_vertical_velocity=false,\n)","category":"section"},{"location":"configuration/#Combine-into-a-ModelConfig","page":"-","title":"Combine into a ModelConfig","text":"config = create_model_config(domain, strat, init, output;\n    dt=1e-3, total_time=10.0,\n    f₀=1.0,                    # Coriolis parameter (type: f\\_0<tab>)\n    # Model switches\n    ybj_plus=true,\n    no_wave_feedback=false,\n    fixed_mean_flow=false,\n)\n\n# Validate and print a summary\nerrors, warnings = validate_config(config)\nprint_config_summary(config)","category":"section"},{"location":"advanced/interpolation/#interpolation","page":"Interpolation","title":"Interpolation Methods","text":"This page describes interpolation methods available in QGYBJ.jl.","category":"section"},{"location":"advanced/interpolation/#Overview","page":"Interpolation","title":"Overview","text":"Interpolation is needed for:\n\nParticle advection: Evaluating velocities at particle positions\nOutput: Sampling fields at specific locations\nRegridding: Transferring data between grids","category":"section"},{"location":"advanced/interpolation/#Available-Methods","page":"Interpolation","title":"Available Methods","text":"","category":"section"},{"location":"advanced/interpolation/#Nearest-Neighbor","page":"Interpolation","title":"Nearest Neighbor","text":"Fastest but lowest accuracy:\n\nvalue = interpolate(field, x, y, z, grid; method=:nearest)\n\nOrder: 0\nContinuity: None (discontinuous)\nBest for: Quick visualization, large particle counts","category":"section"},{"location":"advanced/interpolation/#Trilinear","page":"Interpolation","title":"Trilinear","text":"Standard method for smooth fields:\n\nvalue = interpolate(field, x, y, z, grid; method=:linear)\n\nOrder: 1\nContinuity: C⁰ (continuous values, discontinuous derivatives)\nBest for: General-purpose interpolation","category":"section"},{"location":"advanced/interpolation/#Tricubic","page":"Interpolation","title":"Tricubic","text":"High-accuracy interpolation:\n\nvalue = interpolate(field, x, y, z, grid; method=:cubic)\n\nOrder: 3\nContinuity: C¹ (continuous first derivatives)\nBest for: Accurate particle trajectories, smooth fields","category":"section"},{"location":"advanced/interpolation/#Spectral","page":"Interpolation","title":"Spectral","text":"Exact for band-limited fields:\n\nvalue = interpolate_spectral(field_k, x, y, z, grid, plans)\n\nOrder: Spectral (N)\nContinuity: C^∞\nBest for: Highest accuracy, single-point queries","category":"section"},{"location":"advanced/interpolation/#Batch-Interpolation","page":"Interpolation","title":"Batch Interpolation","text":"For many points (e.g., particles):\n\n# Pre-allocate output\nvalues = zeros(nparticles)\n\n# Batch interpolation\ninterpolate_batch!(values, field, xs, ys, zs, grid; method=:linear)","category":"section"},{"location":"advanced/interpolation/#Performance-Comparison","page":"Interpolation","title":"Performance Comparison","text":"Method Points/second Memory\nNearest 10⁸ Minimal\nLinear 10⁷ Minimal\nCubic 10⁶ 64 coeff/point\nSpectral 10⁴ Full field","category":"section"},{"location":"advanced/interpolation/#Horizontal-Interpolation","page":"Interpolation","title":"Horizontal Interpolation","text":"For 2D slices:\n\n# At fixed depth\nvalue_xy = interpolate_horizontal(field[:,:,k], x, y, grid; method=:linear)","category":"section"},{"location":"advanced/interpolation/#Vertical-Interpolation","page":"Interpolation","title":"Vertical Interpolation","text":"Along the vertical:\n\n# At fixed horizontal position\nvalue_z = interpolate_vertical(field[i,j,:], z, grid; method=:linear)","category":"section"},{"location":"advanced/interpolation/#Spectral-Interpolation","page":"Interpolation","title":"Spectral Interpolation","text":"","category":"section"},{"location":"advanced/interpolation/#Theory","page":"Interpolation","title":"Theory","text":"For a spectral field:\n\nf(xyz) = sum_k_x k_y hatf(k_x k_y z) e^i(k_x x + k_y y)","category":"section"},{"location":"advanced/interpolation/#Implementation","page":"Interpolation","title":"Implementation","text":"function interpolate_spectral(field_k, x, y, z, grid, plans)\n    # Compute phase factors\n    phases = exp.(im .* (grid.kx .* x .+ grid.ky' .* y))\n\n    # Find vertical indices\n    k_lo, k_hi, wz = find_vertical_cell(z, grid)\n\n    # Interpolate vertically\n    field_z = (1-wz) .* field_k[:,:,k_lo] .+ wz .* field_k[:,:,k_hi]\n\n    # Sum over wavenumbers\n    return real(sum(field_z .* phases))\nend","category":"section"},{"location":"advanced/interpolation/#Stencil-Coefficients","page":"Interpolation","title":"Stencil Coefficients","text":"","category":"section"},{"location":"advanced/interpolation/#Linear-(8-point)","page":"Interpolation","title":"Linear (8-point)","text":"      z₁ -------- z₁\n      /|         /|\n     / |        / |\n   z₀ -------- z₀ |\n    |  y₁ -----|-- y₁\n    | /        | /\n    |/         |/\n   y₀ -------- y₀\n   x₀         x₁\n\nWeights: Product of 1D linear weights in each direction.","category":"section"},{"location":"advanced/interpolation/#Cubic-(64-point)","page":"Interpolation","title":"Cubic (64-point)","text":"Uses 4×4×4 stencil with Catmull-Rom spline weights.","category":"section"},{"location":"advanced/interpolation/#Boundary-Handling","page":"Interpolation","title":"Boundary Handling","text":"","category":"section"},{"location":"advanced/interpolation/#Periodic","page":"Interpolation","title":"Periodic","text":"Default for horizontal directions:\n\nx_wrapped = mod(x, grid.Lx)\ny_wrapped = mod(y, grid.Ly)","category":"section"},{"location":"advanced/interpolation/#Extrapolation","page":"Interpolation","title":"Extrapolation","text":"For vertical boundaries:\n\n# Clamp to domain\nz_clamped = clamp(z, 0, grid.H)\n\n# Or extrapolate linearly\nif z > grid.H\n    value = field[end] + (z - grid.H) * gradient[end]\nend","category":"section"},{"location":"advanced/interpolation/#Interpolation-for-Derivatives","page":"Interpolation","title":"Interpolation for Derivatives","text":"","category":"section"},{"location":"advanced/interpolation/#Gradient-Interpolation","page":"Interpolation","title":"Gradient Interpolation","text":"# Interpolate gradient components\ndudx = interpolate(dudx_field, x, y, z, grid)\ndudy = interpolate(dudy_field, x, y, z, grid)","category":"section"},{"location":"advanced/interpolation/#Directly-from-Spectral","page":"Interpolation","title":"Directly from Spectral","text":"function interpolate_gradient_spectral(field_k, x, y, z, grid, plans)\n    # Compute spectral derivatives\n    dfdx_k = im .* grid.kx .* field_k\n    dfdy_k = im .* grid.ky' .* field_k\n\n    # Interpolate both\n    dfdx = interpolate_spectral(dfdx_k, x, y, z, grid, plans)\n    dfdy = interpolate_spectral(dfdy_k, x, y, z, grid, plans)\n\n    return dfdx, dfdy\nend","category":"section"},{"location":"advanced/interpolation/#Regridding","page":"Interpolation","title":"Regridding","text":"","category":"section"},{"location":"advanced/interpolation/#To-Finer-Grid","page":"Interpolation","title":"To Finer Grid","text":"function regrid_fine(field_coarse, grid_coarse, grid_fine)\n    field_fine = zeros(grid_fine.nx, grid_fine.ny, grid_fine.nz)\n\n    for k in 1:grid_fine.nz\n        for j in 1:grid_fine.ny\n            for i in 1:grid_fine.nx\n                x = grid_fine.x[i]\n                y = grid_fine.y[j]\n                z = grid_fine.z[k]\n                field_fine[i,j,k] = interpolate(field_coarse, x, y, z,\n                                                 grid_coarse)\n            end\n        end\n    end\n\n    return field_fine\nend","category":"section"},{"location":"advanced/interpolation/#Spectral-Padding","page":"Interpolation","title":"Spectral Padding","text":"For spectral fields, zero-pad in wavenumber space:\n\nfunction spectral_refine(field_k_coarse, grid_coarse, grid_fine)\n    field_k_fine = zeros(ComplexF64, grid_fine.nx÷2+1, grid_fine.ny, grid_fine.nz)\n\n    # Copy low wavenumbers\n    nkx = grid_coarse.nx÷2+1\n    nky = grid_coarse.ny\n\n    field_k_fine[1:nkx, 1:nky÷2, :] = field_k_coarse[:, 1:nky÷2, :]\n    field_k_fine[1:nkx, end-nky÷2+1:end, :] = field_k_coarse[:, nky÷2+1:end, :]\n\n    return field_k_fine\nend","category":"section"},{"location":"advanced/interpolation/#API-Reference","page":"Interpolation","title":"API Reference","text":"The interpolation functionality is provided through the particle advection system. See interpolate_velocity_at_position in the particles module for the main interpolation interface used for Lagrangian particle tracking.","category":"section"},{"location":"advanced/parallel/#parallel","page":"MPI Parallelization","title":"MPI Parallelization","text":"This page describes how to run QGYBJ.jl on distributed memory systems using MPI with 2D pencil decomposition via PencilArrays and PencilFFTs.","category":"section"},{"location":"advanced/parallel/#Overview","page":"MPI Parallelization","title":"Overview","text":"QGYBJ.jl uses 2D pencil decomposition for optimal parallel scalability:\n\n           Serial (Full Domain)                2D Pencil Decomposition\n        ┌─────────────────────┐         ┌───────┬───────┬───────┐\n        │                     │         │  P0   │  P1   │  P2   │\n        │                     │         ├───────┼───────┼───────┤\n        │    nx × ny × nz     │   →     │  P3   │  P4   │  P5   │\n        │                     │         ├───────┼───────┼───────┤\n        │                     │         │  P6   │  P7   │  P8   │\n        └─────────────────────┘         └───────┴───────┴───────┘\n                                              9 processes in 3×3 grid\n\nThe domain is distributed across a 2D process grid (px × py), allowing scaling to O(N²) processes for an N³ grid.","category":"section"},{"location":"advanced/parallel/#Key-Concept:-Pencil-Configurations","page":"MPI Parallelization","title":"Key Concept: Pencil Configurations","text":"Different operations require data arranged differently. QGYBJ uses three pencil configurations:\n\nConfiguration decomp_dims Distribution Local Dim Use Case\nxy-pencil (2, 3) y,z distributed x Horizontal FFTs\nxz-pencil (1, 3) x,z distributed y Intermediate transpose\nz-pencil (1, 2) x,y distributed z Vertical operations\n\nWhy three configurations?\n\nHorizontal FFTs need consecutive x-data → xy-pencil\nVertical tridiagonal solves need all z-data → z-pencil\nPencilArrays constraint: Transpose requires decomp_dims to differ by at most ONE dimension\nSince (2,3)→(1,2) differs by TWO dimensions, we need intermediate xz-pencil (1,3)\nTwo-step transpose automatically switches between configurations","category":"section"},{"location":"advanced/parallel/#Requirements","page":"MPI Parallelization","title":"Requirements","text":"Install MPI-related packages:\n\nusing Pkg\nPkg.add([\"MPI\", \"PencilArrays\", \"PencilFFTs\"])\n\nEnsure you have a working MPI installation (OpenMPI, MPICH, Intel MPI, etc.).","category":"section"},{"location":"advanced/parallel/#Quick-Start","page":"MPI Parallelization","title":"Quick Start","text":"","category":"section"},{"location":"advanced/parallel/#Basic-MPI-Script","page":"MPI Parallelization","title":"Basic MPI Script","text":"# parallel_run.jl\nusing MPI\nusing PencilArrays\nusing PencilFFTs\nusing QGYBJ\n\n# Initialize MPI\nMPI.Init()\n\n# Setup MPI environment with automatic 2D topology\nmpi_config = QGYBJ.setup_mpi_environment()\n\n# Create parameters\nparams = default_params(nx=256, ny=256, nz=128)\n\n# Initialize distributed grid and state\ngrid = QGYBJ.init_mpi_grid(params, mpi_config)\nstate = QGYBJ.init_mpi_state(grid, mpi_config)\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\n\n# Plan parallel FFTs\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\n\n# Get physics coefficients\na_vec = a_ell_ut(params, grid)\ndealias = dealias_mask(grid)\n\n# Time stepping loop\ndt = 0.001\nfor step in 1:1000\n    # All operations automatically handle 2D decomposition\n    invert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\n    compute_velocities!(state, grid; plans=plans, params=params, workspace=workspace)\n    leapfrog_step!(state, state, state, grid, params, plans;\n                   a=a_vec, dealias_mask=dealias, workspace=workspace)\n\n    if step % 100 == 0 && mpi_config.is_root\n        println(\"Step $step completed\")\n    end\nend\n\nif mpi_config.is_root\n    println(\"Simulation complete!\")\nend\n\nMPI.Finalize()","category":"section"},{"location":"advanced/parallel/#Running","page":"MPI Parallelization","title":"Running","text":"# Run on 16 processes (auto-decomposed to 4×4 grid)\nmpiexec -n 16 julia --project parallel_run.jl\n\n# Run on 64 processes (auto-decomposed to 8×8 grid)\nmpiexec -n 64 julia --project parallel_run.jl","category":"section"},{"location":"advanced/parallel/#2D-Pencil-Decomposition-Details","page":"MPI Parallelization","title":"2D Pencil Decomposition Details","text":"","category":"section"},{"location":"advanced/parallel/#Process-Topology","page":"MPI Parallelization","title":"Process Topology","text":"The setup_mpi_environment() function automatically computes an optimal 2D process grid:\n\n# Automatic topology (recommended)\nmpi_config = QGYBJ.setup_mpi_environment()\n\n# For 16 processes: creates (4, 4) topology\n# For 12 processes: creates (3, 4) topology\n\n# Manual topology specification\nmpi_config = QGYBJ.setup_mpi_environment(topology=(4, 4))","category":"section"},{"location":"advanced/parallel/#PencilDecomp-Structure","page":"MPI Parallelization","title":"PencilDecomp Structure","text":"The decomposition is stored in grid.decomp:\n\n# Access decomposition info\ndecomp = grid.decomp\n\n# Three pencil configurations\ndecomp.pencil_xy  # decomp_dims=(2,3): y,z distributed, x local - for FFTs\ndecomp.pencil_xz  # decomp_dims=(1,3): x,z distributed, y local - INTERMEDIATE\ndecomp.pencil_z   # decomp_dims=(1,2): x,y distributed, z local - for vertical ops\n\n# Local index ranges for each configuration\ndecomp.local_range_xy  # (1:nx, y_start:y_end, z_start:z_end)\ndecomp.local_range_xz  # (x_start:x_end, 1:ny, z_start:z_end)\ndecomp.local_range_z   # (x_start:x_end, y_start:y_end, 1:nz)\n\n# Global dimensions and topology\ndecomp.global_dims  # (nx, ny, nz)\ndecomp.topology     # (px, py) process grid","category":"section"},{"location":"advanced/parallel/#How-Transposes-Work","page":"MPI Parallelization","title":"How Transposes Work","text":"QGYBJ uses two-step transpose because PencilArrays requires that pencil decompositions differ by at most one dimension. Since xy-pencil (2,3) and z-pencil (1,2) differ in both dimensions, we use an intermediate xz-pencil (1,3):\n\n                         QGYBJ Two-Step Transpose Architecture\n\n    ┌─────────────────────────────────────────────────────────────────────────────┐\n    │                         xy-pencil (2,3)                                     │\n    │                    y,z distributed; x local                                 │\n    │                  Used for: FFTs, horizontal operations                      │\n    └─────────────────────────────┬───────────────────────────────────────────────┘\n                                  │\n                    transpose!(buffer, src)  [changes 2→1]\n                                  ▼\n    ┌─────────────────────────────────────────────────────────────────────────────┐\n    │                         xz-pencil (1,3)                                     │\n    │                    x,z distributed; y local                                 │\n    │                       INTERMEDIATE for transposes                           │\n    └─────────────────────────────┬───────────────────────────────────────────────┘\n                                  │\n                    transpose!(dst, buffer)  [changes 3→2]\n                                  ▼\n    ┌─────────────────────────────────────────────────────────────────────────────┐\n    │                          z-pencil (1,2)                                     │\n    │                    x,y distributed; z local                                 │\n    │               Used for: Tridiagonal solves, vertical ops                    │\n    └─────────────────────────────────────────────────────────────────────────────┘\n\n    Transpose path satisfies PencilArrays constraint (max 1 dim change per step):\n    • xy→z: (2,3) → (1,3) → (1,2)  ✓\n    • z→xy: (1,2) → (1,3) → (2,3)  ✓\n\nThe two-step transpose is handled automatically by transpose_to_z_pencil! and transpose_to_xy_pencil!.\n\nExample: Inverting q to ψ requires a vertical tridiagonal solve:\n\nfunction invert_q_to_psi!(S, G; a, workspace)\n    # Detect if 2D decomposition is active\n    need_transpose = G.decomp !== nothing && hasfield(typeof(G.decomp), :pencil_z)\n\n    if need_transpose\n        # 1. Two-step transpose: xy(2,3) → xz(1,3) → z(1,2)\n        transpose_to_z_pencil!(workspace.q_z, S.q, G)\n\n        # 2. Solve tridiagonal system (z now fully local!)\n        # ... Thomas algorithm for each (i,j) column ...\n\n        # 3. Two-step transpose back: z(1,2) → xz(1,3) → xy(2,3)\n        transpose_to_xy_pencil!(S.psi, workspace.psi_z, G)\n    else\n        # Serial: direct solve\n        _invert_q_to_psi_direct!(S, G, a)\n    end\nend","category":"section"},{"location":"advanced/parallel/#Workspace-Arrays","page":"MPI Parallelization","title":"Workspace Arrays","text":"For 2D decomposition, pre-allocated z-pencil workspace arrays avoid repeated allocation:\n\n# Initialize workspace once\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\n\n# Workspace contains z-pencil arrays:\n# workspace.q_z     - for q transpose\n# workspace.psi_z   - for ψ transpose\n# workspace.B_z     - for B transpose\n# workspace.A_z     - for A transpose\n# workspace.C_z     - for C transpose\n# workspace.work_z  - general workspace\n\n# Pass workspace to functions\ninvert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\ninvert_B_to_A!(state, grid, params, a_vec; workspace=workspace)","category":"section"},{"location":"advanced/parallel/#Index-Mapping","page":"MPI Parallelization","title":"Index Mapping","text":"","category":"section"},{"location":"advanced/parallel/#Local-to-Global-Indices","page":"MPI Parallelization","title":"Local to Global Indices","text":"When iterating over distributed arrays, use local indices but map to global for wavenumbers:\n\n# For xy-pencil arrays (default)\nfor k_local in axes(arr, 3)\n    for j_local in axes(arr, 2)\n        for i_local in axes(arr, 1)\n            # Map to global indices for wavenumber lookup\n            i_global = local_to_global(i_local, 1, grid)\n            j_global = local_to_global(j_local, 2, grid)\n\n            kx = grid.kx[i_global]\n            ky = grid.ky[j_global]\n\n            # Use local indices for array access\n            arr[i_local, j_local, k_local] = ...\n        end\n    end\nend\n\n# For z-pencil arrays (after transpose)\ni_global = local_to_global_z(i_local, 1, grid)\nj_global = local_to_global_z(j_local, 2, grid)","category":"section"},{"location":"advanced/parallel/#Helper-Functions","page":"MPI Parallelization","title":"Helper Functions","text":"# Get local index ranges\nlocal_range = get_local_range(grid)       # xy-pencil\nlocal_range_z = get_local_range_z(grid)   # z-pencil\n\n# Get local dimensions of an array\nnx_local, ny_local, nz_local = get_local_dims(arr)\n\n# Check if array is distributed\nis_distributed = is_parallel_array(arr)\n\n# Access underlying data (works for both Array and PencilArray)\ndata = parent(arr)","category":"section"},{"location":"advanced/parallel/#Parallel-FFTs","page":"MPI Parallelization","title":"Parallel FFTs","text":"PencilFFTs handles the distributed FFTs automatically:\n\n# Plan creation\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\n\n# Forward FFT (physical → spectral)\nfft_forward!(dst, src, plans)\n\n# Backward FFT (spectral → physical)\nfft_backward!(dst, src, plans)\n\nPencilFFTs automatically handles:\n\nX-FFT in xy-pencil\nTranspose to appropriate configuration for Y-FFT\nTranspose back to output configuration","category":"section"},{"location":"advanced/parallel/#Communication-Patterns","page":"MPI Parallelization","title":"Communication Patterns","text":"","category":"section"},{"location":"advanced/parallel/#Global-Reductions","page":"MPI Parallelization","title":"Global Reductions","text":"# Sum a value across all processes\nlocal_energy = flow_kinetic_energy(state.u, state.v)\nglobal_energy = QGYBJ.mpi_reduce_sum(local_energy, mpi_config)\n\n# Only root has the correct sum\nif mpi_config.is_root\n    println(\"Total KE: $global_energy\")\nend","category":"section"},{"location":"advanced/parallel/#Gather/Scatter","page":"MPI Parallelization","title":"Gather/Scatter","text":"# Gather full field to root process\nglobal_psi = QGYBJ.gather_to_root(state.psi, grid, mpi_config)\n# Returns full array on rank 0, nothing on others\n\n# Scatter from root to all processes\ndistributed_psi = QGYBJ.scatter_from_root(initial_psi, grid, mpi_config)","category":"section"},{"location":"advanced/parallel/#Synchronization","page":"MPI Parallelization","title":"Synchronization","text":"# Barrier - wait for all processes\nQGYBJ.mpi_barrier(mpi_config)","category":"section"},{"location":"advanced/parallel/#Complete-Example","page":"MPI Parallelization","title":"Complete Example","text":"# full_mpi_simulation.jl\nusing MPI\nusing PencilArrays\nusing PencilFFTs\nusing QGYBJ\n\nfunction main()\n    MPI.Init()\n\n    # Setup MPI with 2D decomposition\n    mpi_config = QGYBJ.setup_mpi_environment()\n\n    if mpi_config.is_root\n        println(\"Running on $(mpi_config.nprocs) processes\")\n        println(\"Topology: $(mpi_config.topology)\")\n    end\n\n    # Parameters\n    params = default_params(\n        nx = 256, ny = 256, nz = 128,\n        Lx = 2π, Ly = 2π,\n        f₀ = 1.0,\n        stratification = :constant_N,\n        ybj_plus = true\n    )\n\n    # Initialize distributed grid, state, workspace\n    grid = QGYBJ.init_mpi_grid(params, mpi_config)\n    state = QGYBJ.init_mpi_state(grid, mpi_config)\n    workspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\n\n    # FFT plans\n    plans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\n\n    # Physics setup\n    a_vec = a_ell_ut(params, grid)\n    dealias = dealias_mask(grid)\n\n    # Initialize with random field (deterministic across processes)\n    QGYBJ.init_mpi_random_field!(state.psi, grid, 1.0, 42)\n    QGYBJ.init_mpi_random_field!(state.B, grid, 0.1, 123)\n\n    # Compute initial q from psi\n    invert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\n\n    # Time stepping\n    dt = 0.001\n    nsteps = 10000\n    output_interval = 100\n\n    for step in 1:nsteps\n        # Main physics\n        invert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\n        compute_velocities!(state, grid; plans=plans, params=params, workspace=workspace)\n\n        # Time step\n        leapfrog_step!(state, state, state, grid, params, plans;\n                       a=a_vec, dealias_mask=dealias, workspace=workspace)\n\n        # Diagnostics\n        if step % output_interval == 0\n            local_ke = flow_kinetic_energy(state.u, state.v)\n            global_ke = QGYBJ.mpi_reduce_sum(local_ke, mpi_config)\n\n            if mpi_config.is_root\n                println(\"Step $step / $nsteps: KE = $global_ke\")\n            end\n        end\n    end\n\n    # Final output\n    if mpi_config.is_root\n        println(\"Simulation complete!\")\n    end\n\n    MPI.Finalize()\nend\n\nmain()","category":"section"},{"location":"advanced/parallel/#Allocating-Distributed-Arrays","page":"MPI Parallelization","title":"Allocating Distributed Arrays","text":"# Allocate array in xy-pencil configuration (for FFTs)\n# decomp_dims=(2,3): y,z distributed; x local\narr_xy = QGYBJ.allocate_xy_pencil(grid, ComplexF64)\n\n# Allocate array in xz-pencil configuration (intermediate for transposes)\n# decomp_dims=(1,3): x,z distributed; y local\narr_xz = QGYBJ.allocate_xz_pencil(grid, ComplexF64)\n\n# Allocate array in z-pencil configuration (for vertical ops)\n# decomp_dims=(1,2): x,y distributed; z local\narr_z = QGYBJ.allocate_z_pencil(grid, ComplexF64)\n\nIn serial mode, all three functions return standard Array{T,3} of size (nx, ny, nz).","category":"section"},{"location":"advanced/parallel/#Performance-Considerations","page":"MPI Parallelization","title":"Performance Considerations","text":"","category":"section"},{"location":"advanced/parallel/#Scaling","page":"MPI Parallelization","title":"Scaling","text":"Regime Description\nStrong scaling Fixed problem size, increase processes\nWeak scaling Fixed work per process, increase total size\n\nQGYBJ.jl with 2D decomposition scales to O(N²) processes for N³ grid.","category":"section"},{"location":"advanced/parallel/#Communication-Costs","page":"MPI Parallelization","title":"Communication Costs","text":"Operation Communication Pattern Cost\nTranspose xy↔z Two-step all-to-all via xz-pencil 2 × O(N³/P) data moved\nFFT Internal transposes Handled by PencilFFTs\nReduction Global sum O(log P)\n\nNote: The two-step transpose (xy↔xz↔z) doubles the communication compared to a single transpose, but is required by PencilArrays' constraint that decomp_dims can only differ by one dimension per transpose.","category":"section"},{"location":"advanced/parallel/#Optimization-Tips","page":"MPI Parallelization","title":"Optimization Tips","text":"Use power-of-2 process counts for optimal topology\nMatch decomposition to problem: More processes in larger dimensions\nMinimize transpose frequency: Batch vertical operations\nPre-allocate workspace: Avoid allocation in time loop\n\n# Good: Power of 2\nmpiexec -n 16 julia script.jl   # 4×4 topology\nmpiexec -n 64 julia script.jl   # 8×8 topology\n\n# May be slower: Awkward factorization\nmpiexec -n 15 julia script.jl   # 3×5 topology","category":"section"},{"location":"advanced/parallel/#Job-Submission-Scripts","page":"MPI Parallelization","title":"Job Submission Scripts","text":"","category":"section"},{"location":"advanced/parallel/#SLURM","page":"MPI Parallelization","title":"SLURM","text":"#!/bin/bash\n#SBATCH --job-name=qgybj\n#SBATCH --nodes=4\n#SBATCH --ntasks-per-node=16\n#SBATCH --time=24:00:00\n#SBATCH --mem=32G\n\nmodule load julia openmpi\n\nexport JULIA_NUM_THREADS=1  # Use MPI parallelism\nmpiexec -n 64 julia --project run_simulation.jl","category":"section"},{"location":"advanced/parallel/#PBS","page":"MPI Parallelization","title":"PBS","text":"#!/bin/bash\n#PBS -N qgybj\n#PBS -l nodes=4:ppn=16\n#PBS -l walltime=24:00:00\n#PBS -l mem=128gb\n\nmodule load julia openmpi\n\ncd $PBS_O_WORKDIR\nmpiexec -n 64 julia --project run_simulation.jl","category":"section"},{"location":"advanced/parallel/#Troubleshooting","page":"MPI Parallelization","title":"Troubleshooting","text":"","category":"section"},{"location":"advanced/parallel/#MPI-Not-Found","page":"MPI Parallelization","title":"MPI Not Found","text":"# Use system MPI instead of Julia's binary\nusing MPIPreferences\nMPIPreferences.use_system_binary()\n# Restart Julia","category":"section"},{"location":"advanced/parallel/#Memory-Errors","page":"MPI Parallelization","title":"Memory Errors","text":"Local arrays too large → increase process count\nCheck with: size(parent(state.psi)) on each rank","category":"section"},{"location":"advanced/parallel/#Deadlock","page":"MPI Parallelization","title":"Deadlock","text":"Ensure ALL ranks call collective operations (gather, reduce, barrier)\nCheck for mismatched send/receive","category":"section"},{"location":"advanced/parallel/#Debugging","page":"MPI Parallelization","title":"Debugging","text":"function debug_print(msg, mpi_config)\n    for r in 0:(mpi_config.nprocs-1)\n        if mpi_config.rank == r\n            println(\"[Rank $r] $msg\")\n            flush(stdout)\n        end\n        QGYBJ.mpi_barrier(mpi_config)\n    end\nend","category":"section"},{"location":"advanced/parallel/#API-Reference","page":"MPI Parallelization","title":"API Reference","text":"The following MPI functions are provided:","category":"section"},{"location":"advanced/parallel/#Setup-Functions","page":"MPI Parallelization","title":"Setup Functions","text":"setup_mpi_environment - Initialize MPI environment and configuration\ninit_mpi_grid - Create grid with 2D pencil decomposition\ninit_mpi_state - Create distributed state arrays\ninit_mpi_workspace - Allocate workspace for z-pencil operations\nplan_mpi_transforms - Create PencilFFT plans","category":"section"},{"location":"advanced/parallel/#Communication-Functions","page":"MPI Parallelization","title":"Communication Functions","text":"gather_to_root - Collect distributed array to rank 0\nscatter_from_root - Distribute array from rank 0\nmpi_barrier - Synchronize all processes\nmpi_reduce_sum - Sum values across all processes","category":"section"},{"location":"advanced/parallel/#Transpose-Functions","page":"MPI Parallelization","title":"Transpose Functions","text":"transpose_to_z_pencil! - Two-step transpose: xy(2,3) → xz(1,3) → z(1,2)\ntranspose_to_xy_pencil! - Two-step transpose: z(1,2) → xz(1,3) → xy(2,3)","category":"section"},{"location":"advanced/parallel/#Index-Mapping-Functions","page":"MPI Parallelization","title":"Index Mapping Functions","text":"local_to_global - Map local index to global (xy-pencil), with dimension argument\nlocal_to_global_z - Map local index to global (z-pencil)\nrange_local - Get local index range (from PencilArrays)\nrange_remote - Get remote (global) index range (from PencilArrays)","category":"section"},{"location":"advanced/parallel/#Helper-Functions-2","page":"MPI Parallelization","title":"Helper Functions","text":"get_kh2 - Get horizontal wavenumber squared array\nis_dealiased - Check if a mode is within dealiasing radius","category":"section"},{"location":"advanced/parallel/#Array-Allocation","page":"MPI Parallelization","title":"Array Allocation","text":"allocate_xy_pencil - Allocate array in xy-pencil layout (for FFTs)\nallocate_xz_pencil - Allocate array in xz-pencil layout (intermediate)\nallocate_z_pencil - Allocate array in z-pencil layout (for vertical ops)","category":"section"},{"location":"api/grid_state/#api-grid-state","page":"Grid & State","title":"Grid & State","text":"This page documents the core data structures: Grid and State.","category":"section"},{"location":"api/grid_state/#Grid-Type","page":"Grid & State","title":"Grid Type","text":"The Grid struct contains spatial coordinates, spectral wavenumbers, and parallel decomposition information.","category":"section"},{"location":"api/grid_state/#Definition","page":"Grid & State","title":"Definition","text":"mutable struct Grid{T, AT}\n    # Grid dimensions\n    nx::Int                # Number of points in x (horizontal)\n    ny::Int                # Number of points in y (horizontal)\n    nz::Int                # Number of points in z (vertical)\n\n    # Domain sizes\n    Lx::T                  # Domain size in x\n    Ly::T                  # Domain size in y\n\n    # Grid spacings\n    dx::T                  # Grid spacing in x: dx = Lx/nx\n    dy::T                  # Grid spacing in y: dy = Ly/ny\n\n    # Vertical grid (unstaggered)\n    z::Vector{T}           # Vertical levels z[k], size nz\n    dz::Vector{T}          # Layer thicknesses: dz[k] = z[k+1] - z[k], size nz-1\n\n    # Spectral wavenumbers\n    kx::Vector{T}          # x-wavenumbers, size nx\n    ky::Vector{T}          # y-wavenumbers, size ny\n    kh2::AT                # kx² + ky² on spectral grid\n\n    # MPI decomposition (PencilArrays)\n    decomp::Any            # PencilDecomp or nothing for serial\nend","category":"section"},{"location":"api/grid_state/#Type-Parameters","page":"Grid & State","title":"Type Parameters","text":"T: Floating point type (typically Float64)\nAT: Array type for kh2 (Array{T,2} for serial, PencilArray{T,3} for parallel)","category":"section"},{"location":"api/grid_state/#Constructors","page":"Grid & State","title":"Constructors","text":"# Initialize from parameters (serial mode)\nparams = default_params(nx=64, ny=64, nz=32)\ngrid = init_grid(params)\n\n# Initialize with MPI decomposition\nusing MPI, PencilArrays, PencilFFTs\nMPI.Init()\nmpi_config = QGYBJ.setup_mpi_environment()\ngrid = QGYBJ.init_mpi_grid(params, mpi_config)","category":"section"},{"location":"api/grid_state/#Grid-Properties","page":"Grid & State","title":"Grid Properties","text":"# Dimensions\nnx, ny, nz = grid.nx, grid.ny, grid.nz\n\n# Domain size\nLx, Ly = grid.Lx, grid.Ly\n\n# Grid spacings\ndx, dy = grid.dx, grid.dy\n\n# Vertical levels\nz = grid.z       # Vector of length nz\ndz = grid.dz     # Vector of length nz-1\n\n# Check if parallel\nis_parallel = grid.decomp !== nothing","category":"section"},{"location":"api/grid_state/#Wavenumber-Access","page":"Grid & State","title":"Wavenumber Access","text":"# Wavenumber vectors (global, same on all processes)\nkx = grid.kx     # Vector of length nx\nky = grid.ky     # Vector of length ny\n\n# Horizontal wavenumber squared\n# Serial: 2D array (nx, ny)\n# Parallel: 3D PencilArray (local_nx, local_ny, local_nz)\nkh2 = grid.kh2\n\n# Convenience functions (handle serial/parallel automatically)\nkx_val = get_kx(i_local, grid)    # Get kx for local index\nky_val = get_ky(j_local, grid)    # Get ky for local index\nkh2_val = get_kh2(i, j, k, arr, grid)  # Get kh² for local indices","category":"section"},{"location":"api/grid_state/#Index-Mapping-(Parallel)","page":"Grid & State","title":"Index Mapping (Parallel)","text":"When using parallel decomposition, local indices must be mapped to global indices:\n\n# Get local index ranges\nlocal_range = get_local_range(grid)   # (i_range, j_range, k_range)\n\n# Map local to global indices (xy-pencil)\ni_global = local_to_global(i_local, 1, grid)  # x dimension\nj_global = local_to_global(j_local, 2, grid)  # y dimension\nk_global = local_to_global(k_local, 3, grid)  # z dimension\n\n# Map local to global indices (z-pencil)\ni_global = local_to_global_z(i_local, 1, grid)\nj_global = local_to_global_z(j_local, 2, grid)\n\n# Get local dimensions of any array\nnx_local, ny_local, nz_local = get_local_dims(arr)\n\n# Check if array is parallel\nis_distributed = is_parallel_array(arr)","category":"section"},{"location":"api/grid_state/#Decomposition-Access","page":"Grid & State","title":"Decomposition Access","text":"# Access decomposition (parallel mode only)\nif grid.decomp !== nothing\n    decomp = grid.decomp\n\n    # Pencil configurations\n    pencil_xy = decomp.pencil_xy   # For horizontal FFTs\n    pencil_z = decomp.pencil_z     # For vertical operations\n\n    # Local ranges\n    range_xy = decomp.local_range_xy\n    range_z = decomp.local_range_z\n\n    # Global dimensions\n    global_dims = decomp.global_dims   # (nx, ny, nz)\n\n    # Process topology\n    topology = decomp.topology   # (px, py)\nend","category":"section"},{"location":"api/grid_state/#State-Type","page":"Grid & State","title":"State Type","text":"The State struct contains all prognostic and diagnostic fields.","category":"section"},{"location":"api/grid_state/#Definition-2","page":"Grid & State","title":"Definition","text":"mutable struct State{T, RT<:AbstractArray{T,3}, CT<:AbstractArray{Complex{T},3}}\n    # Prognostic fields (spectral space, complex)\n    q::CT           # QG potential vorticity\n    B::CT           # YBJ+ wave envelope (B = L⁺A)\n\n    # Diagnostic fields (spectral space, complex)\n    psi::CT         # Streamfunction (from q via inversion)\n    A::CT           # Wave amplitude (from B via YBJ+ inversion)\n    C::CT           # Vertical derivative A_z\n\n    # Velocity fields (real space, real)\n    u::RT           # Zonal velocity: u = -dψ/dy\n    v::RT           # Meridional velocity: v = dψ/dx\n    w::RT           # Vertical velocity (from omega equation)\nend","category":"section"},{"location":"api/grid_state/#Type-Parameters-2","page":"Grid & State","title":"Type Parameters","text":"T: Floating point type (Float64)\nRT: Real array type (Array{T,3} or PencilArray{T,3})\nCT: Complex array type (Array{Complex{T},3} or PencilArray{Complex{T},3})","category":"section"},{"location":"api/grid_state/#Constructors-2","page":"Grid & State","title":"Constructors","text":"# Initialize from grid (serial mode)\nstate = init_state(grid)\n\n# Initialize with MPI (parallel mode)\nstate = QGYBJ.init_mpi_state(grid, mpi_config)","category":"section"},{"location":"api/grid_state/#Field-Access","page":"Grid & State","title":"Field Access","text":"# Prognostic fields (time-stepped)\nq = state.q      # QG potential vorticity (spectral)\nB = state.B      # Wave envelope (spectral)\n\n# Diagnostic fields (computed)\npsi = state.psi  # Streamfunction (spectral)\nA = state.A      # Wave amplitude (spectral)\nC = state.C      # Vertical derivative dA/dz (spectral)\n\n# Velocity fields (real space)\nu = state.u      # Zonal velocity\nv = state.v      # Meridional velocity\nw = state.w      # Vertical velocity","category":"section"},{"location":"api/grid_state/#Working-with-Arrays","page":"Grid & State","title":"Working with Arrays","text":"# Get underlying data (works for both Array and PencilArray)\npsi_data = parent(state.psi)\n\n# Get local dimensions\nnx_local, ny_local, nz_local = size(parent(state.psi))\n\n# Access single element\nval = state.psi[i, j, k]\n\n# Access slice\nsurface = state.psi[:, :, end]\nprofile = state.psi[i, j, :]\n\n# Set values\nstate.psi[i, j, k] = complex_value\nstate.psi[:, :, end] .= surface_values\n\n# Copy all of one field\nstate.psi .= initial_psi","category":"section"},{"location":"api/grid_state/#Physical-Interpretation","page":"Grid & State","title":"Physical Interpretation","text":"Field Symbol Physical Meaning\nq q QG potential vorticity: q = nabla²psi + (f²/N²)d²psi/dz²\nB B YBJ+ wave envelope: B = L⁺A\npsi psi Streamfunction\nA A Wave amplitude\nC dA/dz Vertical derivative of wave amplitude\nu u Zonal velocity: u = -dpsi/dy\nv v Meridional velocity: v = dpsi/dx\nw w Vertical velocity (from omega equation or YBJ)","category":"section"},{"location":"api/grid_state/#MPI-Workspace","page":"Grid & State","title":"MPI Workspace","text":"For 2D parallel decomposition, workspace arrays store z-pencil data:","category":"section"},{"location":"api/grid_state/#Definition-3","page":"Grid & State","title":"Definition","text":"struct MPIWorkspace{T, PA}\n    q_z::PA      # q in z-pencil configuration\n    psi_z::PA    # psi in z-pencil configuration\n    B_z::PA      # B in z-pencil configuration\n    A_z::PA      # A in z-pencil configuration\n    C_z::PA      # C in z-pencil configuration\n    work_z::PA   # General workspace\nend","category":"section"},{"location":"api/grid_state/#Constructor","page":"Grid & State","title":"Constructor","text":"# Initialize workspace (parallel mode only)\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)","category":"section"},{"location":"api/grid_state/#Usage","page":"Grid & State","title":"Usage","text":"# Pass workspace to functions requiring vertical operations\ninvert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)\ninvert_B_to_A!(state, grid, params, a_vec; workspace=workspace)\ncompute_vertical_velocity!(state, grid, plans, params; workspace=workspace)","category":"section"},{"location":"api/grid_state/#Allocating-Arrays","page":"Grid & State","title":"Allocating Arrays","text":"","category":"section"},{"location":"api/grid_state/#Serial-Mode","page":"Grid & State","title":"Serial Mode","text":"# Allocate using grid\nq = allocate_field(Float64, grid; complex=true)   # Complex spectral\nu = allocate_field(Float64, grid; complex=false)  # Real physical","category":"section"},{"location":"api/grid_state/#Parallel-Mode","page":"Grid & State","title":"Parallel Mode","text":"# Allocate in xy-pencil (for FFTs, horizontal operations)\narr_xy = QGYBJ.allocate_xy_pencil(grid, ComplexF64)\n\n# Allocate in z-pencil (for vertical operations)\narr_z = QGYBJ.allocate_z_pencil(grid, ComplexF64)","category":"section"},{"location":"api/grid_state/#Utility-Functions","page":"Grid & State","title":"Utility Functions","text":"","category":"section"},{"location":"api/grid_state/#Grid-Utilities","page":"Grid & State","title":"Grid Utilities","text":"# Compute wavenumbers (after changing Lx, Ly)\ncompute_wavenumbers!(grid)\n\n# Get dealiasing mask\nmask = dealias_mask(grid)  # 2D Bool array (nx, ny)","category":"section"},{"location":"api/grid_state/#State-Utilities","page":"Grid & State","title":"State Utilities","text":"# Zero all fields\nfill!(state.q, 0)\nfill!(state.B, 0)\nfill!(state.psi, 0)\n\n# Check for NaN\nhas_nan = any(isnan, parent(state.psi))","category":"section"},{"location":"api/grid_state/#Serial-vs-Parallel-Comparison","page":"Grid & State","title":"Serial vs Parallel Comparison","text":"Operation Serial Parallel\nGrid initialization init_grid(params) init_mpi_grid(params, mpi_config)\nState initialization init_state(grid) init_mpi_state(grid, mpi_config)\nArray type Array{T,3} PencilArray{T,3}\nIndex access Direct arr[i,j,k] Via parent(arr)[i,j,k]\nWavenumber lookup Direct grid.kx[i] grid.kx[local_to_global(i,1,grid)]\ngrid.decomp nothing PencilDecomp struct","category":"section"},{"location":"api/grid_state/#API-Reference","page":"Grid & State","title":"API Reference","text":"","category":"section"},{"location":"api/grid_state/#Grid-Initialization","page":"Grid & State","title":"Grid Initialization","text":"","category":"section"},{"location":"api/grid_state/#State-Initialization","page":"Grid & State","title":"State Initialization","text":"Field allocation is handled internally by init_state. For manual array creation, use standard Julia array allocation or allocate_xy_pencil/allocate_z_pencil for parallel mode.","category":"section"},{"location":"api/grid_state/#Index-Mapping-Functions","page":"Grid & State","title":"Index Mapping Functions","text":"","category":"section"},{"location":"api/grid_state/#QGYBJ.init_grid","page":"Grid & State","title":"QGYBJ.init_grid","text":"init_grid(par::QGParams) -> Grid\n\nInitialize the spatial grid and spectral wavenumbers from parameters.\n\nGrid Setup\n\nHorizontal: Uniform grid with spacing dx = Lx/nx, dy = Ly/ny\nVertical: Uniform grid from 0 to Lz with spacing dz = Lz/(nz-1)\nDomain size (Lx, Ly, Lz) is REQUIRED - specify in meters (e.g., 500e3 for 500 km)\n\nWavenumber Arrays\n\nComputes kx, ky following FFTW conventions for periodic domain:\n\nkx[i] = (i-1)           for i = 1, ..., nx/2\n        (i-1-nx)        for i = nx/2+1, ..., nx\n\nmultiplied by 2π/Lx.\n\nArguments\n\npar::QGParams: Parameter struct with nx, ny, nz, Lx, Ly, Lz\n\nReturns\n\nInitialized Grid struct with all arrays allocated.\n\nExample\n\n# Domain size is REQUIRED - specify in meters\npar = default_params(nx=64, ny=64, nz=32, Lx=500e3, Ly=500e3, Lz=4000.0)  # 500km × 500km × 4km\nG = init_grid(par)\n\nFortran Correspondence\n\nThis matches init_arrays in init.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.compute_wavenumbers!","page":"Grid & State","title":"QGYBJ.compute_wavenumbers!","text":"compute_wavenumbers!(G::Grid)\n\nRecompute wavenumber arrays kx, ky, kh2 if grid parameters changed.\n\nThis is useful after modifying grid dimensions or domain size.\n\nExample\n\nG.Lx = 4π  # Change domain size\ncompute_wavenumbers!(G)  # Update wavenumbers\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.init_state","page":"Grid & State","title":"QGYBJ.init_state","text":"init_state(G::Grid; T=Float64) -> State\n\nAllocate and initialize a State with all fields set to zero.\n\nArguments\n\nG::Grid: Grid struct (determines array sizes)\nT::Type: Floating point type (default Float64)\n\nReturns\n\nState struct with:\n\nSpectral fields (q, psi, A, B, C): Complex arrays, initialized to 0\nReal fields (u, v, w): Real arrays, initialized to 0\n\nExample\n\nG = init_grid(par)\nS = init_state(G)\n\n# All fields are zero - use init_random_psi! or similar to set ICs\ninit_random_psi!(S, G, par, plans)\n\nSee also: State, init_random_psi!\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.get_local_range","page":"Grid & State","title":"QGYBJ.get_local_range","text":"get_local_range(G::Grid) -> NTuple{3, UnitRange{Int}}\n\nGet the local index range for the current process (xy-pencil configuration).\n\nFor 2D decomposition, this returns the xy-pencil ranges where x is local and y,z are distributed. Use get_local_range_z for z-pencil configuration.\n\nReturns\n\nSerial mode: (1:nx, 1:ny, 1:nz)\nParallel mode: The local range from the xy-pencil decomposition\n\nExample\n\nlocal_range = get_local_range(grid)\nfor k in local_range[3], j in local_range[2], i in local_range[1]\n    # Access data at local indices\nend\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.local_to_global","page":"Grid & State","title":"QGYBJ.local_to_global","text":"local_to_global(local_idx::Int, dim::Int, G::Grid) -> Int\n\nConvert a local array index to a global index (xy-pencil configuration).\n\nFor 2D decomposition, this uses xy-pencil ranges. Use local_to_global_z for operations on z-pencil arrays.\n\nArguments\n\nlocal_idx: Local index in the array\ndim: Dimension (1, 2, or 3 for x, y, z)\nG::Grid: Grid with optional decomposition\n\nReturns\n\nGlobal index for wavenumber lookup.\n\nExample\n\nfor j_local in axes(arr, 2), i_local in axes(arr, 1)\n    i_global = local_to_global(i_local, 1, grid)\n    j_global = local_to_global(j_local, 2, grid)\n    kx = grid.kx[i_global]\n    ky = grid.ky[j_global]\nend\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.get_local_dims","page":"Grid & State","title":"QGYBJ.get_local_dims","text":"get_local_dims(arr) -> Tuple{Int, Int, Int}\n\nGet the local dimensions of an array (works for both Array and PencilArray).\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.get_kx","page":"Grid & State","title":"QGYBJ.get_kx","text":"get_kx(i_local::Int, G::Grid) -> Real\n\nGet the x-wavenumber for a local index, handling both serial and parallel cases.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.get_ky","page":"Grid & State","title":"QGYBJ.get_ky","text":"get_ky(j_local::Int, G::Grid) -> Real\n\nGet the y-wavenumber for a local index, handling both serial and parallel cases.\n\n\n\n\n\n","category":"function"},{"location":"api/grid_state/#QGYBJ.get_kh2","page":"Grid & State","title":"QGYBJ.get_kh2","text":"get_kh2(i_local::Int, j_local::Int, k_local::Int, arr, G::Grid) -> Real\n\nGet horizontal wavenumber squared for local indices.\n\nFor serial mode, accesses G.kh2 directly. For parallel mode, accesses the local PencilArray element.\n\n\n\n\n\n","category":"function"},{"location":"physics/numerical_methods/#numerical-methods","page":"Numerical Methods","title":"Numerical Methods","text":"This page describes the numerical algorithms used in QGYBJ.jl, including the 2D pencil decomposition strategy for parallel execution.","category":"section"},{"location":"physics/numerical_methods/#Spatial-Discretization","page":"Numerical Methods","title":"Spatial Discretization","text":"","category":"section"},{"location":"physics/numerical_methods/#Horizontal:-Pseudo-Spectral-Method","page":"Numerical Methods","title":"Horizontal: Pseudo-Spectral Method","text":"The model uses a pseudo-spectral approach in the horizontal:\n\nOperation Space Method\nLinear derivatives Spectral Multiply by ik_x, ik_y\nNonlinear products Physical Pointwise multiplication\nTransform Both FFT / IFFT","category":"section"},{"location":"physics/numerical_methods/#Advantages","page":"Numerical Methods","title":"Advantages","text":"Spectral accuracy for smooth fields\nEfficient O(N log N) via FFT\nNo numerical diffusion from derivatives","category":"section"},{"location":"physics/numerical_methods/#Dealiasing","page":"Numerical Methods","title":"Dealiasing","text":"Nonlinear products create aliasing errors. We use the 2/3 rule:\n\nk_max = frac23 cdot fracN2\n\nModes with |k| > k_max are set to zero after each nonlinear term.\n\n# Apply dealiasing mask\nmask = dealias_mask(grid)\n@. field_k *= mask","category":"section"},{"location":"physics/numerical_methods/#Vertical:-Finite-Differences","page":"Numerical Methods","title":"Vertical: Finite Differences","text":"The vertical direction uses second-order centered differences:\n\nfracpartial fpartial zbigg_k approx fracf_k+1 - f_k-12Delta z\n\nfracpartial^2 fpartial z^2bigg_k approx fracf_k+1 - 2f_k + f_k-1Delta z^2\n\nFor variable coefficients (stratification):\n\nfracpartialpartial zleft(a(z)fracpartial fpartial zright) approx fraca_k+12(f_k+1 - f_k) - a_k-12(f_k - f_k-1)Delta z^2","category":"section"},{"location":"physics/numerical_methods/#Time-Integration","page":"Numerical Methods","title":"Time Integration","text":"","category":"section"},{"location":"physics/numerical_methods/#Leapfrog-with-Robert-Asselin-Filter-and-Integrating-Factors","page":"Numerical Methods","title":"Leapfrog with Robert-Asselin Filter and Integrating Factors","text":"The primary time stepping scheme is leapfrog with Robert-Asselin filtering and integrating factors for hyperdiffusion.","category":"section"},{"location":"physics/numerical_methods/#Forward-Euler-(First-Step)","page":"Numerical Methods","title":"Forward Euler (First Step)","text":"The first step uses forward Euler to bootstrap the leapfrog scheme:\n\nq^n+1 = left q^n - Delta t cdot J(psi q)^n + Delta t cdot D_q^n right cdot e^-lambda Delta t\n\nFor the wave envelope (in real/imaginary form):\n\nB_R^n+1 = left B_R^n - Delta t cdot J(psi B_R) - Delta t cdot fracN^2 k_h^22 f_0 A_I + Delta t cdot frac12 r_BI right cdot e^-lambda_w Delta t\n\nB_I^n+1 = left B_I^n - Delta t cdot J(psi B_I) + Delta t cdot fracN^2 k_h^22 f_0 A_R - Delta t cdot frac12 r_BR right cdot e^-lambda_w Delta t\n\nwhere N^2 is the buoyancy frequency squared and f_0 is the Coriolis parameter.","category":"section"},{"location":"physics/numerical_methods/#Leapfrog-(Subsequent-Steps)","page":"Numerical Methods","title":"Leapfrog (Subsequent Steps)","text":"Subsequent steps use centered leapfrog with integrating factors:\n\nq^n+1 = q^n-1 cdot e^-2lambda Delta t - 2Delta t cdot J(psi q)^n cdot e^-lambda Delta t + 2Delta t cdot D_q^n cdot e^-2lambda Delta t\n\nB_R^n+1 = B_R^n-1 cdot e^-2lambda_w Delta t - 2Delta t cdot left J(psi B_R) + fracN^2 k_h^22 f_0 A_I - frac12 r_BI right^n cdot e^-lambda_w Delta t\n\nB_I^n+1 = B_I^n-1 cdot e^-2lambda_w Delta t - 2Delta t cdot left J(psi B_I) - fracN^2 k_h^22 f_0 A_R + frac12 r_BR right^n cdot e^-lambda_w Delta t","category":"section"},{"location":"physics/numerical_methods/#Robert-Asselin-Filter","page":"Numerical Methods","title":"Robert-Asselin Filter","text":"The Robert-Asselin filter damps the computational mode that can grow with leapfrog:\n\ntildeq^n = q^n + gamma left( q^n-1 - 2q^n + q^n+1 right)\n\nwhere gamma approx 0001 (typically very small to minimize physical mode damping).\n\n# First step: Forward Euler\nfirst_projection_step!(state, grid, params, plans; a=a_vec, dealias_mask=mask)\n\n# Subsequent steps: Leapfrog with Robert-Asselin\nleapfrog_step!(state_np1, state_n, state_nm1, grid, params, plans;\n               a=a_vec, dealias_mask=mask)","category":"section"},{"location":"physics/numerical_methods/#Integrating-Factor-Method","page":"Numerical Methods","title":"Integrating Factor Method","text":"The integrating factor lambda handles hyperdiffusion exactly:\n\nlambda = nu_h1 left( k_x^2 cdot ilap1 + k_y^2 cdot ilap1 right) + nu_h2 left( k_x^2 cdot ilap2 + k_y^2 cdot ilap2 right)\n\nwhere (using Unicode parameters):\n\nnu_h1 (νₕ₁), ilap1: First hyperdiffusion operator (default: biharmonic with ilap1=2)\nnu_h2 (νₕ₂), ilap2: Second hyperdiffusion operator (default: hyper-6 with ilap2=6)\n\nThe wave field has its own integrating factor lambda_w with potentially different coefficients.\n\nAdvantages of integrating factors:\n\nHyperdiffusion is treated exactly (no stability restriction)\nAllows much larger time steps than explicit diffusion treatment\nSecond-order accuracy preserved for advective terms","category":"section"},{"location":"physics/numerical_methods/#Elliptic-Inversions","page":"Numerical Methods","title":"Elliptic Inversions","text":"","category":"section"},{"location":"physics/numerical_methods/#Tridiagonal-Systems","page":"Numerical Methods","title":"Tridiagonal Systems","text":"Both QG (q -> psi) and YBJ+ (B -> A) inversions lead to tridiagonal systems at each horizontal wavenumber (kx, ky):\n\na_k x_k-1 + b_k x_k + c_k x_k+1 = d_k","category":"section"},{"location":"physics/numerical_methods/#Thomas-Algorithm","page":"Numerical Methods","title":"Thomas Algorithm","text":"We solve these in O(N) operations using the Thomas algorithm:\n\nForward sweep:\n\nfor k = 2:nz\n    w = a[k] / b[k-1]\n    b[k] = b[k] - w * c[k-1]\n    d[k] = d[k] - w * d[k-1]\nend\n\nBack substitution:\n\nx[nz] = d[nz] / b[nz]\nfor k = nz-1:-1:1\n    x[k] = (d[k] - c[k] * x[k+1]) / b[k]\nend","category":"section"},{"location":"physics/numerical_methods/#Key-Inversions","page":"Numerical Methods","title":"Key Inversions","text":"Function Solves Physical Meaning\ninvert_q_to_psi! nabla²psi + (f²/N²)d²psi/dz² = q PV to streamfunction\ninvert_B_to_A! L⁺A = B Wave envelope to amplitude\ninvert_helmholtz! nabla²phi - lambda*phi = f General Helmholtz","category":"section"},{"location":"physics/numerical_methods/#FFT-Implementation","page":"Numerical Methods","title":"FFT Implementation","text":"","category":"section"},{"location":"physics/numerical_methods/#Serial-Mode:-FFTW","page":"Numerical Methods","title":"Serial Mode: FFTW","text":"We use FFTW with measured plans for optimal performance:\n\n# Create optimized plans\nplans = plan_transforms!(grid)\n\n# Forward FFT (physical -> spectral)\nfft_forward!(dst, src, plans)\n\n# Backward FFT (spectral -> physical)\nfft_backward!(dst, src, plans)\n\nPlan creation is expensive (~seconds) but execution is fast.","category":"section"},{"location":"physics/numerical_methods/#Parallel-Mode:-PencilFFTs","page":"Numerical Methods","title":"Parallel Mode: PencilFFTs","text":"For MPI parallel execution, we use PencilFFTs which handles distributed FFTs:\n\n# Create parallel FFT plans\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\n\n# Same interface as serial\nfft_forward!(dst, src, plans)\nfft_backward!(dst, src, plans)\n\nPencilFFTs automatically handles the transposes needed for distributed FFTs.","category":"section"},{"location":"physics/numerical_methods/#2D-Pencil-Decomposition","page":"Numerical Methods","title":"2D Pencil Decomposition","text":"","category":"section"},{"location":"physics/numerical_methods/#The-Challenge","page":"Numerical Methods","title":"The Challenge","text":"The model requires two types of operations:\n\nHorizontal FFTs: Need consecutive x and y data\nVertical solves: Need all z data at each (x,y) point\n\nWith 2D decomposition, no single configuration has all data local.","category":"section"},{"location":"physics/numerical_methods/#Solution:-Dual-Pencil-Configurations","page":"Numerical Methods","title":"Solution: Dual Pencil Configurations","text":"QGYBJ.jl uses two pencil configurations:\n\nConfiguration Local Dimension Distributed Dimensions Use\nxy-pencil x y, z Horizontal FFTs\nz-pencil z x, y Vertical operations\n\n    xy-pencil                           z-pencil\n   (x local)                          (z local)\n┌─────────────────┐               ┌─────────────────┐\n│ x: FULL         │               │ x: distributed  │\n│ y: distributed  │  <----->      │ y: distributed  │\n│ z: distributed  │  transpose    │ z: FULL         │\n└─────────────────┘               └─────────────────┘","category":"section"},{"location":"physics/numerical_methods/#Transpose-Operations","page":"Numerical Methods","title":"Transpose Operations","text":"Functions requiring vertical operations follow this pattern:\n\nfunction some_vertical_operation!(S, G; workspace=nothing)\n    # Check if 2D decomposition is active\n    need_transpose = G.decomp !== nothing && hasfield(typeof(G.decomp), :pencil_z)\n\n    if need_transpose\n        # 1. Transpose from xy-pencil to z-pencil\n        transpose_to_z_pencil!(workspace.field_z, S.field, G)\n\n        # 2. Perform vertical operation (z now fully local)\n        _vertical_operation_on_z_pencil!(workspace.result_z, workspace.field_z, ...)\n\n        # 3. Transpose result back to xy-pencil\n        transpose_to_xy_pencil!(S.result, workspace.result_z, G)\n    else\n        # Serial mode: direct vertical operation\n        _vertical_operation_direct!(S, G, ...)\n    end\nend","category":"section"},{"location":"physics/numerical_methods/#Functions-Using-This-Pattern","page":"Numerical Methods","title":"Functions Using This Pattern","text":"Function What it does Needs z local?\ninvert_q_to_psi! PV inversion Yes (tridiagonal)\ninvert_B_to_A! Wave amplitude recovery Yes (tridiagonal)\ninvert_helmholtz! General Helmholtz Yes (tridiagonal)\ncompute_vertical_velocity! Omega equation Yes (tridiagonal)\ncompute_ybj_vertical_velocity! YBJ w formula Yes (vertical derivative)\ndissipation_q_nv! Numerical dissipation Yes (vertical terms)\nsumB! Sum B over depth Yes (vertical sum)\ncompute_sigma YBJ sigma term Yes (vertical operations)\ncompute_A! Compute A from B Yes (vertical operations)\nomega_eqn_rhs! RHS of omega equation Yes (vertical derivatives)","category":"section"},{"location":"physics/numerical_methods/#Workspace-Arrays","page":"Numerical Methods","title":"Workspace Arrays","text":"To avoid repeated allocation, pre-allocate z-pencil workspace:\n\n# Initialize once\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\n\n# Contents:\n# workspace.q_z, workspace.psi_z, workspace.B_z,\n# workspace.A_z, workspace.C_z, workspace.work_z\n\n# Pass to functions\ninvert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)","category":"section"},{"location":"physics/numerical_methods/#Jacobian/Advection-Computation","page":"Numerical Methods","title":"Jacobian/Advection Computation","text":"","category":"section"},{"location":"physics/numerical_methods/#Divergence-Form-(convol_waqg)","page":"Numerical Methods","title":"Divergence Form (convol_waqg)","text":"For advection terms like J(psi q), QGYBJ.jl uses the divergence form:\n\nJ(psi q) = fracpartial(uq)partial x + fracpartial(vq)partial y = ik_x widehatuq + ik_y widehatvq\n\nwhere u = -partialpsipartial y and v = partialpsipartial x are the geostrophic velocities.","category":"section"},{"location":"physics/numerical_methods/#Algorithm-(convol_waqg)","page":"Numerical Methods","title":"Algorithm (convol_waqg)","text":"Precompute velocities in real space: u_r, v_r\nTransform field to real space:\nfft_backward!(qr, qk, plans)\nCompute products in real space:\nuterm = u_r .* qr\nvterm = v_r .* qr\nTransform back and compute divergence:\nfft_forward!(uterm_k, uterm, plans)\nfft_forward!(vterm_k, vterm, plans)\nJ_k = im * kx .* uterm_k + im * ky .* vterm_k\nApply dealiasing:\nJ_k[.!dealias_mask] .= 0\nNormalize (for unnormalized FFT):\nJ_k ./= (nx * ny)","category":"section"},{"location":"physics/numerical_methods/#Conservation-Properties","page":"Numerical Methods","title":"Conservation Properties","text":"The pseudo-spectral advection conserves:\n\nCirculation: int J(psi q)  dA = 0\nEnergy (to machine precision in inviscid limit)\nEnstrophy (to machine precision in inviscid limit)","category":"section"},{"location":"physics/numerical_methods/#Stability-Constraints","page":"Numerical Methods","title":"Stability Constraints","text":"","category":"section"},{"location":"physics/numerical_methods/#CFL-Condition","page":"Numerical Methods","title":"CFL Condition","text":"For advection terms:\n\nDelta t  fracDelta xmaxu approx fracLNU","category":"section"},{"location":"physics/numerical_methods/#Diffusion-Stability","page":"Numerical Methods","title":"Diffusion Stability","text":"With integrating factors, there is no diffusion stability limit.\n\nWithout integrating factors, explicit diffusion requires:\n\nDelta t  fracDelta x^2p2nu\n\nFor hyperdiffusion (p=4), this is very restrictive.","category":"section"},{"location":"physics/numerical_methods/#Recommended-Time-Steps","page":"Numerical Methods","title":"Recommended Time Steps","text":"Resolution Typical dt\n64^3 0.001 - 0.01\n128^3 0.0005 - 0.005\n256^3 0.0002 - 0.002\n512^3 0.0001 - 0.001","category":"section"},{"location":"physics/numerical_methods/#Memory-Layout","page":"Numerical Methods","title":"Memory Layout","text":"","category":"section"},{"location":"physics/numerical_methods/#Array-Ordering","page":"Numerical Methods","title":"Array Ordering","text":"Julia uses column-major ordering (Fortran-style):\n\n# Fast index first for cache efficiency\nfor k = 1:nz\n    for j = 1:ny\n        for i = 1:nx\n            field[i, j, k] = ...\n        end\n    end\nend","category":"section"},{"location":"physics/numerical_methods/#Complex-Arrays","page":"Numerical Methods","title":"Complex Arrays","text":"Spectral fields are stored as Array{ComplexF64, 3}:\n\n# Spectral field dimensions\npsi_k = zeros(ComplexF64, nx, ny, nz)","category":"section"},{"location":"physics/numerical_methods/#PencilArrays-(Parallel)","page":"Numerical Methods","title":"PencilArrays (Parallel)","text":"In parallel mode, arrays are PencilArray{T,3}:\n\n# Access underlying data\ndata = parent(arr)\n\n# Local dimensions\nnx_local, ny_local, nz_local = size(data)","category":"section"},{"location":"physics/numerical_methods/#Accuracy-Verification","page":"Numerical Methods","title":"Accuracy Verification","text":"","category":"section"},{"location":"physics/numerical_methods/#Order-of-Accuracy","page":"Numerical Methods","title":"Order of Accuracy","text":"Component Spatial Order Temporal Order\nHorizontal derivatives Spectral -\nVertical derivatives 2nd -\nElliptic solvers 2nd (vertical) -\nTime stepping (Leapfrog) - 2nd\nIntegrating factors - Exact","category":"section"},{"location":"physics/numerical_methods/#Conservation-Tests","page":"Numerical Methods","title":"Conservation Tests","text":"Run with inviscid settings to verify:\n\nEnergy conservation (< 10^-10 relative change)\nEnstrophy conservation (< 10^-10 relative change)\n\n# Check energy conservation\nKE_initial = flow_kinetic_energy(state.u, state.v)\n# ... run simulation ...\nKE_final = flow_kinetic_energy(state.u, state.v)\nprintln(\"Relative change: \", abs(KE_final - KE_initial) / KE_initial)","category":"section"},{"location":"physics/numerical_methods/#Performance-Optimization","page":"Numerical Methods","title":"Performance Optimization","text":"","category":"section"},{"location":"physics/numerical_methods/#Key-Optimizations","page":"Numerical Methods","title":"Key Optimizations","text":"Pre-allocated work arrays: No allocations in time loop\nFFTW planning: Measured plans for optimal performance\nLoop fusion: @. macro for element-wise operations\nIn-place operations: Minimize memory allocation\nWorkspace reuse: Pre-allocated z-pencil arrays for transposes","category":"section"},{"location":"physics/numerical_methods/#Profiling","page":"Numerical Methods","title":"Profiling","text":"using Profile\n\n# Profile time stepping\n@profile for _ in 1:100\n    leapfrog_step!(state_np1, state_n, state_nm1, grid, params, plans;\n                   a=a_vec, dealias_mask=mask, workspace=workspace)\nend\n\nProfile.print()\n\nTypical hotspots:\n\nFFT transforms (~40-50%)\nTridiagonal solves (~20-30%)\nTranspose operations (~10-20% in parallel)\nArray operations (~10-20%)","category":"section"},{"location":"physics/numerical_methods/#Parallel-Scaling","page":"Numerical Methods","title":"Parallel Scaling","text":"Processes Expected Speedup Limiting Factor\n1-16 Near linear -\n16-64 Good Transpose overhead\n64-256 Moderate Communication\n256+ Diminishing Problem size dependent","category":"section"},{"location":"physics/numerical_methods/#References","page":"Numerical Methods","title":"References","text":"Canuto, C., et al. (2006). Spectral Methods: Fundamentals in Single Domains. Springer.\nDurran, D. R. (2010). Numerical Methods for Fluid Dynamics. Springer.\nPencilArrays.jl documentation: https://jipolanco.github.io/PencilArrays.jl/\nPencilFFTs.jl documentation: https://jipolanco.github.io/PencilFFTs.jl/","category":"section"},{"location":"guide/stratification/#stratification","page":"Stratification","title":"Stratification","text":"This page explains how to configure ocean stratification profiles in QGYBJ.jl.","category":"section"},{"location":"guide/stratification/#Why-Stratification-Matters","page":"Stratification","title":"Why Stratification Matters","text":"The buoyancy frequency N(z) affects:\n\nWave propagation: Dispersion depends on N^2\nVertical structure: Mode shapes vary with N(z)\nRefraction: Waves bend toward regions of lower N\nEnergy flux: Vertical group velocity scales with N","category":"section"},{"location":"guide/stratification/#Built-in-Profiles","page":"Stratification","title":"Built-in Profiles","text":"","category":"section"},{"location":"guide/stratification/#Constant-N","page":"Stratification","title":"Constant N","text":"Uniform stratification throughout the water column:\n\nsetup_stratification!(grid, params, :constant_N)\n\nProfile:\n\nN^2(z) = N_0^2 = textconst\n\nBest for:\n\nIdealized studies\nAnalytical comparisons\nSimple mode structure","category":"section"},{"location":"guide/stratification/#Exponential","page":"Stratification","title":"Exponential","text":"Stratification decreasing exponentially with depth:\n\nsetup_stratification!(grid, params, :exponential;\n    depth_scale = 0.1  # e-folding scale\n)\n\nProfile:\n\nN^2(z) = N_0^2  e^zd\n\nwhere d is the depth scale and z is negative (depth).\n\nBest for:\n\nRealistic ocean upper thermocline\nSimple continuous variation","category":"section"},{"location":"guide/stratification/#Skewed-Gaussian-(Pycnocline)","page":"Stratification","title":"Skewed Gaussian (Pycnocline)","text":"Sharp pycnocline with gradual decrease below:\n\nsetup_stratification!(grid, params, :skewed_gaussian;\n    pycnocline_depth = 0.05,   # Depth of N² maximum\n    pycnocline_width = 0.02,   # Width of pycnocline\n    deep_N2_ratio = 0.01       # N²(deep) / N²(surface)\n)\n\nProfile (schematic):\n\nN² →\n│\n│    ╱╲\n│   ╱  ╲\n│  ╱    ╲____\n│ ╱           ╲____\n│╱                  ──────\n└─────────────────────────── z (depth)\n     ↑\n  pycnocline\n\nBest for:\n\nRealistic subtropical ocean\nStrong near-surface trapping\nWave focusing studies","category":"section"},{"location":"guide/stratification/#Two-Layer","page":"Stratification","title":"Two-Layer","text":"Step-like stratification:\n\nsetup_stratification!(grid, params, :two_layer;\n    interface_depth = 0.2,     # Depth of interface\n    upper_N2 = 1.0,            # N² in upper layer\n    lower_N2 = 0.01            # N² in lower layer\n)\n\nProfile:\n\nN² →\n│\n│ ────────────\n│             │\n│             │\n│             ─────────────\n│\n└────────────────────────── z\n\nBest for:\n\nSimple layered models\nMode-1 dominated dynamics\nPedagogical examples","category":"section"},{"location":"guide/stratification/#Custom-Profiles","page":"Stratification","title":"Custom Profiles","text":"","category":"section"},{"location":"guide/stratification/#From-Function","page":"Stratification","title":"From Function","text":"# Define custom N² profile\nfunction my_N2(z; N0=1.0, z_pyc=-0.1, sigma=0.02)\n    return N0^2 * exp(-((z - z_pyc)/sigma)^2)\nend\n\n# Evaluate on grid\nN2_profile = [my_N2(z) for z in grid.z]\n\n# Apply to grid\nset_stratification!(grid, N2_profile)","category":"section"},{"location":"guide/stratification/#From-Data","page":"Stratification","title":"From Data","text":"using DelimitedFiles\n\n# Load from file (depth, N2 columns)\ndata = readdlm(\"N2_profile.txt\")\nz_data = data[:, 1]\nN2_data = data[:, 2]\n\n# Interpolate to grid\nusing Interpolations\nitp = linear_interpolation(z_data, N2_data)\nN2_profile = [itp(z) for z in grid.z]\n\nset_stratification!(grid, N2_profile)","category":"section"},{"location":"guide/stratification/#From-Observations","page":"Stratification","title":"From Observations","text":"using NCDatasets\n\n# Load from NetCDF (e.g., Argo profile)\nds = NCDataset(\"argo_profile.nc\")\ndepth = ds[\"depth\"][:]\ntemp = ds[\"temperature\"][:]\nsalt = ds[\"salinity\"][:]\nclose(ds)\n\n# Compute N² from T, S profiles\nN2_profile = compute_N2_from_TS(depth, temp, salt)\n\n# Interpolate and apply\n# ... (similar to above)","category":"section"},{"location":"guide/stratification/#Stratification-Structure","page":"Stratification","title":"Stratification Structure","text":"","category":"section"},{"location":"guide/stratification/#Internal-Storage","page":"Stratification","title":"Internal Storage","text":"The grid stores stratification at cell centers and faces:\n\ngrid.N2      # N² at cell centers [nz]\ngrid.N2_face # N² at cell faces [nz+1]\ngrid.a       # f₀²/N² at cell centers [nz]\ngrid.a_face  # f₀²/N² at cell faces [nz+1]","category":"section"},{"location":"guide/stratification/#Accessing-Values","page":"Stratification","title":"Accessing Values","text":"# Get N² profile\nN2 = get_stratification(grid)\n\n# Get at specific depth\nz_target = -0.5\nN2_at_z = interpolate_N2(grid, z_target)","category":"section"},{"location":"guide/stratification/#Effects-on-Dynamics","page":"Stratification","title":"Effects on Dynamics","text":"","category":"section"},{"location":"guide/stratification/#Vertical-Modes","page":"Stratification","title":"Vertical Modes","text":"Stratification determines the vertical mode structure:\n\n# Compute vertical modes\nmodes, eigenvalues = compute_vertical_modes(grid, params)\n\n# modes[:, n] is the n-th mode shape\n# eigenvalues[n] is the corresponding Rossby radius⁻²\n\nMode-1 dominates when:\n\nStrong pycnocline exists\nN^2 decreases smoothly with depth","category":"section"},{"location":"guide/stratification/#Wave-Trapping","page":"Stratification","title":"Wave Trapping","text":"Strong surface stratification traps waves near the surface:\n\nStrong N²    Weak N²\nnear surface everywhere\n\n    │           │\n  ──┴──       ──┴──\n  Wave        Wave\n  trapped     penetrates\n  above       to depth\n  pycnocline","category":"section"},{"location":"guide/stratification/#Deformation-Radius","page":"Stratification","title":"Deformation Radius","text":"The first baroclinic deformation radius:\n\nR_d = frac1f_0piint_0^H N(z)  dz\n\nComputed as:\n\nRd = compute_deformation_radius(grid, params)","category":"section"},{"location":"guide/stratification/#Visualization","page":"Stratification","title":"Visualization","text":"","category":"section"},{"location":"guide/stratification/#Profile-Plot","page":"Stratification","title":"Profile Plot","text":"using Plots\n\nz = grid.z\nN2 = grid.N2\n\nplot(sqrt.(N2), z,\n    xlabel = \"N (s⁻¹)\",\n    ylabel = \"Depth\",\n    title = \"Stratification Profile\",\n    legend = false,\n    flip = true  # Depth increases downward\n)","category":"section"},{"location":"guide/stratification/#With-Modes","page":"Stratification","title":"With Modes","text":"modes, _ = compute_vertical_modes(grid, params)\n\np = plot(layout=(1, 2))\n\n# Left: N² profile\nplot!(p[1], N2, z, xlabel=\"N²\", ylabel=\"z\")\n\n# Right: First 3 modes\nfor n in 1:3\n    plot!(p[2], modes[:, n], z, label=\"Mode $n\")\nend\nxlabel!(p[2], \"Mode amplitude\")","category":"section"},{"location":"guide/stratification/#Best-Practices","page":"Stratification","title":"Best Practices","text":"","category":"section"},{"location":"guide/stratification/#Resolution-Guidelines","page":"Stratification","title":"Resolution Guidelines","text":"Profile Type Recommended n_z\nConstant N 16-32\nSmooth exponential 32-64\nSharp pycnocline 64-128\nTwo-layer 32-64\n\nSharp features need higher resolution to avoid Gibbs phenomena.","category":"section"},{"location":"guide/stratification/#Smoothness","page":"Stratification","title":"Smoothness","text":"Ensure N^2(z) is smooth for numerical stability:\n\n# Bad: Discontinuous\nN2[z .> -0.1] .= 1.0\nN2[z .<= -0.1] .= 0.01\n\n# Good: Smooth transition\nN2 = 0.505 .+ 0.495 .* tanh.((z .+ 0.1) ./ 0.02)","category":"section"},{"location":"guide/stratification/#Physical-Constraints","page":"Stratification","title":"Physical Constraints","text":"N^2  0 everywhere (stable stratification)\nN^2 should decrease with depth (typically)\nAvoid very small N^2 (causes numerical issues in inversions)\n\n# Ensure minimum N²\nN2_min = 1e-6\nN2 = max.(N2, N2_min)","category":"section"},{"location":"guide/stratification/#Stratification-Types-Reference","page":"Stratification","title":"Stratification Types Reference","text":"Type Parameters Best For\n:constant_N N0 Idealized\n:exponential depth_scale Thermocline\n:skewed_gaussian pycnocline_depth, pycnocline_width Realistic ocean\n:two_layer interface_depth, upper_N2, lower_N2 Layered models\n:custom N2_profile Observations","category":"section"},{"location":"guide/stratification/#Related-Topics","page":"Stratification","title":"Related Topics","text":"QG Equations: How N² enters PV\nYBJ+ Wave Model: Wave dispersion with N²\nConfiguration: Setting up simulations","category":"section"},{"location":"getting_started/#getting_started","page":"Installation","title":"Installation & Getting Started","text":"This page walks you through installing QGYBJ.jl, running a quick example, and understanding the core concepts.","category":"section"},{"location":"getting_started/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting_started/#Basic-Installation","page":"Installation","title":"Basic Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/subhk/QGYBJ.jl\")\n\nOr clone and develop locally:\n\ngit clone https://github.com/subhk/QGYBJ.jl\ncd QGYBJ.jl\njulia --project=. -e 'using Pkg; Pkg.instantiate(); Pkg.precompile()'","category":"section"},{"location":"getting_started/#Dependencies","page":"Installation","title":"Dependencies","text":"Package Purpose Required\nFFTW.jl FFT transforms Yes\nLinearAlgebra Matrix operations Yes (stdlib)\nNCDatasets.jl NetCDF I/O Optional","category":"section"},{"location":"getting_started/#MPI-Support-(Optional)","page":"Installation","title":"MPI Support (Optional)","text":"For parallel execution with 2D pencil decomposition:\n\nusing Pkg\nPkg.add([\"MPI\", \"PencilArrays\", \"PencilFFTs\"])\n\nThe MPI extension is automatically loaded when these packages are imported.","category":"section"},{"location":"getting_started/#Quick-Example","page":"Installation","title":"Quick Example","text":"","category":"section"},{"location":"getting_started/#Serial-Mode","page":"Installation","title":"Serial Mode","text":"using QGYBJ\n\n# Create configuration (Lx, Ly, Lz are REQUIRED)\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # 500km × 500km × 4km\n    nx=64, ny=64, nz=32,\n    dt=0.001,\n    total_time=1.0,\n    output_interval=100\n)\n\n# Run simulation\nresult = run_simple_simulation(config)\n\n# Check results\nprintln(\"Final KE: \", flow_kinetic_energy(result.state.u, result.state.v))","category":"section"},{"location":"getting_started/#Parallel-Mode-(MPI)","page":"Installation","title":"Parallel Mode (MPI)","text":"# run_parallel.jl\nusing MPI, PencilArrays, PencilFFTs, QGYBJ\n\nMPI.Init()\nmpi_config = QGYBJ.setup_mpi_environment()\n\n# Setup distributed simulation (Lx, Ly, Lz are REQUIRED)\nparams = default_params(\n    nx=256, ny=256, nz=128,\n    Lx=1000e3, Ly=1000e3, Lz=5000.0  # 1000km × 1000km × 5km\n)\ngrid = QGYBJ.init_mpi_grid(params, mpi_config)\nstate = QGYBJ.init_mpi_state(grid, mpi_config)\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\n\n# Run time stepping...\n\nMPI.Finalize()\n\nRun with:\n\nmpiexec -n 16 julia --project run_parallel.jl","category":"section"},{"location":"getting_started/#Core-Concepts","page":"Installation","title":"Core Concepts","text":"","category":"section"},{"location":"getting_started/#QGParams","page":"Installation","title":"QGParams","text":"All model parameters in one struct:\n\nparams = default_params(\n    nx=64, ny=64, nz=32,      # Grid dimensions\n    Lx=2π, Ly=2π,              # Domain size\n    f₀=1.0,                    # Coriolis parameter\n    N²=1.0,                    # Buoyancy frequency squared\n    dt=0.001,                  # Time step\n    νₕ₂=10.0,                  # Hyperdiffusion\n    ybj_plus=true              # Use YBJ+ formulation\n)\n\nNote: Parameter names use Unicode subscripts (e.g., f₀ instead of f0). Type f\\_0<tab> in Julia REPL to get f₀.","category":"section"},{"location":"getting_started/#Grid","page":"Installation","title":"Grid","text":"Spatial coordinates and spectral wavenumbers:\n\ngrid = init_grid(params)\n\n# Physical coordinates\ngrid.x, grid.y, grid.z     # Coordinate arrays\ngrid.dx, grid.dy           # Grid spacings\n\n# Spectral wavenumbers\ngrid.kx, grid.ky           # Wavenumber vectors\ngrid.kh2                   # Horizontal wavenumber squared\n\n# Parallel decomposition (if using MPI)\ngrid.decomp                # PencilDecomp or nothing","category":"section"},{"location":"getting_started/#State","page":"Installation","title":"State","text":"Prognostic and diagnostic fields:\n\nstate = init_state(grid)\n\n# Prognostic (time-stepped)\nstate.q      # QG potential vorticity (spectral)\nstate.B      # Wave envelope B = L⁺A (spectral)\n\n# Diagnostic (computed)\nstate.psi    # Streamfunction (spectral)\nstate.A      # Wave amplitude (spectral)\nstate.C      # Vertical derivative dA/dz (spectral)\n\n# Velocities (real space)\nstate.u, state.v, state.w","category":"section"},{"location":"getting_started/#FFT-Transforms","page":"Installation","title":"FFT Transforms","text":"# Serial mode\nplans = plan_transforms!(grid)\nfft_forward!(dst, src, plans)   # Physical → Spectral\nfft_backward!(dst, src, plans)  # Spectral → Physical\n\n# Parallel mode (automatic with PencilFFTs)\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)","category":"section"},{"location":"getting_started/#What's-Next?","page":"Installation","title":"What's Next?","text":"Quick Start Tutorial - Hands-on introduction\nConfiguration Guide - All parameters explained\nMPI Parallelization - Scale to large domains\nPhysics Overview - Understand the equations","category":"section"},{"location":"quickstart/#quickstart","page":"Quick Start","title":"Quick Start Tutorial","text":"This tutorial will guide you through your first QGYBJ.jl simulation in about 5 minutes.","category":"section"},{"location":"quickstart/#What-We'll-Build","page":"Quick Start","title":"What We'll Build","text":"A simulation of near-inertial waves interacting with a turbulent eddy field:\n\n64×64×32 grid\nRandom initial streamfunction (eddies)\nRandom initial wave field\n1000 time steps","category":"section"},{"location":"quickstart/#Step-1:-Load-the-Package","page":"Quick Start","title":"Step 1: Load the Package","text":"using QGYBJ","category":"section"},{"location":"quickstart/#Step-2:-Create-a-Simple-Configuration","page":"Quick Start","title":"Step 2: Create a Simple Configuration","text":"The easiest way to set up a simulation is with create_simple_config:\n\nconfig = create_simple_config(\n    # Domain size (REQUIRED - in meters)\n    Lx = 500e3,   # 500 km\n    Ly = 500e3,   # 500 km\n    Lz = 4000.0,  # 4 km depth\n\n    # Grid dimensions\n    nx = 64,\n    ny = 64,\n    nz = 32,\n\n    # Time stepping\n    dt = 0.001,\n    total_time = 1.0,\n\n    # Output\n    output_interval = 100,\n    output_dir = \"output\"\n)\n\nThis creates a complete configuration with sensible defaults. Note that Lx, Ly, and Lz are required parameters - there are no default domain sizes.","category":"section"},{"location":"quickstart/#Step-3:-Run-the-Simulation","page":"Quick Start","title":"Step 3: Run the Simulation","text":"result = run_simple_simulation(config)\n\nYou'll see progress output:\n\nSetting up QG-YBJ simulation...\n  Grid: 64 × 64 × 32\n  Time step: 0.001\n  Total steps: 1000\nStarting simulation...\n  Step 100/1000 (10.0%)\n  Step 200/1000 (20.0%)\n  ...\nSimulation complete!","category":"section"},{"location":"quickstart/#Step-4:-Examine-Results","page":"Quick Start","title":"Step 4: Examine Results","text":"The result contains the final state and diagnostics:\n\n# Access the final state\nstate = result.state\n\n# Streamfunction (spectral space, complex)\npsi = state.psi  # Array{ComplexF64, 3} of size (64, 64, 32)\n\n# Wave envelope (spectral space, complex)\nB = state.B      # Array{ComplexF64, 3} of size (64, 64, 32)\n\n# Velocities (real space)\nu = state.u      # Zonal velocity\nv = state.v      # Meridional velocity","category":"section"},{"location":"quickstart/#Step-5:-Compute-Diagnostics","page":"Quick Start","title":"Step 5: Compute Diagnostics","text":"# Kinetic energy of the flow\nKE = flow_kinetic_energy(state.u, state.v)\nprintln(\"Kinetic Energy: $KE\")\n\n# Wave energy\nE_B, E_A = wave_energy(state.B, state.A)\nprintln(\"Wave Energy (B): $E_B\")\nprintln(\"Wave Energy (A): $E_A\")","category":"section"},{"location":"quickstart/#Step-6:-Visualize-(Optional)","page":"Quick Start","title":"Step 6: Visualize (Optional)","text":"If you have Plots.jl installed:\n\nusing Plots\n\n# Get plans for FFT\nG = result.grid\nplans = plan_transforms!(G)\n\n# Get a horizontal slice of vorticity\nzeta = slice_horizontal(state.psi, G, plans; k=G.nz)\n\n# Multiply by -kh² to get vorticity\n# (simplified - actual vorticity computation is more involved)\n\nheatmap(zeta, title=\"Surface Vorticity\", aspect_ratio=1)","category":"section"},{"location":"quickstart/#Complete-Script","page":"Quick Start","title":"Complete Script","text":"Here's the complete code:\n\nusing QGYBJ\n\n# Configure (Lx, Ly, Lz are REQUIRED)\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # 500km × 500km × 4km\n    nx=64, ny=64, nz=32,\n    dt=0.001, total_time=1.0,\n    output_interval=100\n)\n\n# Run\nresult = run_simple_simulation(config)\n\n# Analyze\nprintln(\"Final Kinetic Energy: \", flow_kinetic_energy(result.state.u, result.state.v))\nprintln(\"Final Wave Energy: \", wave_energy(result.state.B, result.state.A))","category":"section"},{"location":"quickstart/#What's-Next?","page":"Quick Start","title":"What's Next?","text":"Worked Example: More detailed walkthrough\nConfiguration: Customize all parameters\nPhysics Overview: Understand the equations\nMPI Parallelization: Scale to large domains","category":"section"},{"location":"quickstart/#Common-Customizations","page":"Quick Start","title":"Common Customizations","text":"","category":"section"},{"location":"quickstart/#Change-Stratification","page":"Quick Start","title":"Change Stratification","text":"config = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # Domain size required\n    nx=64, ny=64, nz=32,\n    stratification_type = :skewed_gaussian,  # Realistic pycnocline\n    # Or use :constant_N for uniform stratification\n)","category":"section"},{"location":"quickstart/#Enable/Disable-Physics","page":"Quick Start","title":"Enable/Disable Physics","text":"config = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,\n    nx=64, ny=64, nz=32,\n\n    # Disable wave feedback on mean flow\n    no_wave_feedback = true,\n\n    # Run inviscid\n    inviscid = true,\n\n    # Linear dynamics only (no advection)\n    linear = true,\n)","category":"section"},{"location":"quickstart/#Larger-Domain","page":"Quick Start","title":"Larger Domain","text":"config = create_simple_config(\n    Lx=1000e3, Ly=1000e3, Lz=5000.0,  # 1000km × 1000km × 5km\n    nx=256, ny=256, nz=128,            # Larger grid\n    dt=0.0005,                          # Smaller time step for stability\n    total_time=10.0,\n)\n\ntip: Memory Consideration\nA 256×256×128 complex array uses about 1 GB of memory. For larger domains, consider using MPI parallelization.","category":"section"},{"location":"quickstart/#Parallel-Mode-(MPI)","page":"Quick Start","title":"Parallel Mode (MPI)","text":"For large-scale simulations, use MPI with 2D pencil decomposition:\n\n# run_parallel.jl\nusing MPI, PencilArrays, PencilFFTs, QGYBJ\n\nMPI.Init()\nmpi_config = QGYBJ.setup_mpi_environment()\n\n# Setup distributed simulation (Lx, Ly, Lz are REQUIRED)\nparams = default_params(\n    nx=256, ny=256, nz=128,\n    Lx=1000e3, Ly=1000e3, Lz=5000.0  # 1000km × 1000km × 5km\n)\ngrid = QGYBJ.init_mpi_grid(params, mpi_config)\nstate = QGYBJ.init_mpi_state(grid, mpi_config)\nworkspace = QGYBJ.init_mpi_workspace(grid, mpi_config)\nplans = QGYBJ.plan_mpi_transforms(grid, mpi_config)\n\n# ... run simulation ...\n\nMPI.Finalize()\n\nRun with:\n\nmpiexec -n 16 julia --project run_parallel.jl\n\nSee MPI Parallelization for details on 2D pencil decomposition.","category":"section"},{"location":"api/particles/#api-particles","page":"Particles","title":"Particle API","text":"This page documents the particle advection API for Lagrangian tracking.","category":"section"},{"location":"api/particles/#Core-Types","page":"Particles","title":"Core Types","text":"","category":"section"},{"location":"api/particles/#Particle-Initialization-Constructors","page":"Particles","title":"Particle Initialization Constructors","text":"Simple, intuitive functions for creating particle distributions:","category":"section"},{"location":"api/particles/#Initialization-and-Advection","page":"Particles","title":"Initialization and Advection","text":"","category":"section"},{"location":"api/particles/#I/O-Functions","page":"Particles","title":"I/O Functions","text":"","category":"section"},{"location":"api/particles/#Interpolation-Methods","page":"Particles","title":"Interpolation Methods","text":"","category":"section"},{"location":"api/particles/#3D-Particle-Types","page":"Particles","title":"3D Particle Types","text":"","category":"section"},{"location":"api/particles/#Quick-Reference","page":"Particles","title":"Quick Reference","text":"Constructor Description Example\nparticles_in_box(z; ...) 2D box at fixed z particles_in_box(π/2; nx=10, ny=10)\nparticles_in_circle(z; ...) Circular disk particles_in_circle(1.0; radius=0.5, n=100)\nparticles_in_grid_3d(; ...) 3D grid particles_in_grid_3d(; nx=10, ny=10, nz=5)\nparticles_in_layers(zs; ...) Multiple z-levels particles_in_layers([0.5, 1.0, 1.5]; nx=10, ny=10)\nparticles_random_3d(n; ...) Random 3D particles_random_3d(500)\nparticles_custom(pos; ...) Custom positions particles_custom([(1.0,1.0,0.5), ...])","category":"section"},{"location":"api/particles/#Usage-Example","page":"Particles","title":"Usage Example","text":"using QGYBJ\n\n# Setup model\npar = default_params(nx=64, ny=64, nz=32)\nG, S, plans, a = setup_model(; par)\n\n# Create particle configuration (100 particles in a box at z = π/2)\npconfig = particles_in_box(π/2;\n    nx=10, ny=10,\n    integration_method=:rk4,\n    save_interval=0.1\n)\n\n# Or use a circular distribution\npconfig = particles_in_circle(π/2; radius=1.0, n=100)\n\n# Or multiple z-levels\npconfig = particles_in_layers([π/4, π/2, 3π/4]; nx=10, ny=10)\n\n# Create tracker and initialize\ntracker = ParticleTracker(pconfig, G)\ninitialize_particles!(tracker, pconfig)\n\n# Advection loop\ndt = par.dt\nfor step in 1:1000\n    compute_velocities!(S, G, plans)\n    advect_particles!(tracker, S, G, dt, step * dt)\nend\n\n# Write trajectories\nwrite_particle_trajectories(\"trajectories.nc\", tracker)","category":"section"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.ParticleConfig","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.ParticleConfig","text":"Configuration for particle initialization and advection.\n\nKey parameters:\n\nSpatial domain: xmin/max, ymin/max, z_level for initial particle placement\nParticle count: nxparticles × nyparticles \nPhysics options: useybjw (vertical velocity), use3dadvection\nTiming control: particleadvectime - when to start advecting particles\nIntegration: method (:euler, :rk2, :rk4) and interpolation scheme\nBoundaries: periodicx/y, reflectz for boundary conditions\nI/O: saveinterval and maxsave_points for trajectory output\n\nAdvanced timing control:\n\nparticleadvectime=0.0: Start advecting immediately (default)\nparticleadvectime>0.0: Keep particles stationary until this time\nUseful for letting flow field develop before particle release\nEnables study of transient vs established flow patterns\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.ParticleState","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.ParticleState","text":"Particle state including positions, velocities, and trajectory history.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.ParticleTracker","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.ParticleTracker","text":"Main particle tracker that handles both serial and parallel execution.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.initialize_particles!","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.initialize_particles!","text":"initialize_particles!(tracker, config)\n\nInitialize particles uniformly in specified region, handling both serial and parallel.\n\n\n\n\n\ninitialize_particles!(tracker, config3d)\n\nInitialize particles using enhanced 3D configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.advect_particles!","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.advect_particles!","text":"advect_particles!(tracker, state, grid, dt, current_time=nothing; params=nothing, N2_profile=nothing)\n\nAdvect particles using unified serial/parallel interface. Respects the particleadvectime setting - particles remain stationary until this time.\n\nParameters:\n\ntracker: ParticleTracker instance\nstate: Current fluid state\ngrid: Grid information\ndt: Time step\ncurrent_time: Current simulation time (if not provided, uses tracker's internal time)\nparams: Model parameters (QGParams). Required for YBJ vertical velocity to get correct f₀, N².\nN2profile: Optional N²(z) profile for nonuniform stratification. If not provided and `useybj_w=true`, will use constant N² from params, which may be inconsistent with the simulation's actual stratification.\n\nImportant\n\nWhen using YBJ vertical velocity (use_ybj_w=true) with variable stratification, you MUST pass the same N2_profile used in the simulation. Otherwise, compute_ybj_vertical_velocity! will re-invert B→A with constant N², giving inconsistent particle velocities.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.interpolate_velocity_at_position","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.interpolate_velocity_at_position","text":"interpolate_velocity_at_position(x, y, z, tracker)\n\nInterpolate velocity at particle position with advanced schemes and cross-domain capability.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.ParticleIO.write_particle_trajectories","page":"Particles","title":"QGYBJ.ParticleIO.write_particle_trajectories","text":"write_particle_trajectories(filename, tracker; metadata=Dict())\n\nWrite complete particle trajectory history to NetCDF file.\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.ParticleIO.read_particle_trajectories","page":"Particles","title":"QGYBJ.ParticleIO.read_particle_trajectories","text":"read_particle_trajectories(filename) -> NamedTuple\n\nRead particle trajectory history from NetCDF file.\n\nReturns a NamedTuple with fields:\n\nx: Matrix of x positions (np × ntime)\ny: Matrix of y positions (np × ntime)\nz: Matrix of z positions (np × ntime)\ntime: Vector of time values (ntime)\nparticle_ids: Vector of particle identifiers (np)\nattributes: Dict of global attributes from the file\n\nThis is the inverse of write_particle_trajectories.\n\nExample\n\n# Write trajectories\nwrite_particle_trajectories(\"particles.nc\", tracker)\n\n# Read them back\ntraj = read_particle_trajectories(\"particles.nc\")\nprintln(\"Number of particles: \", size(traj.x, 1))\nprintln(\"Number of time steps: \", length(traj.time))\nprintln(\"Initial x positions: \", traj.x[:, 1])\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.ParticleIO.write_particle_snapshot","page":"Particles","title":"QGYBJ.ParticleIO.write_particle_snapshot","text":"write_particle_snapshot(filename, tracker, time)\n\nWrite current particle positions to NetCDF file (single time snapshot).\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.ParticleIO.write_particle_trajectories_by_zlevel","page":"Particles","title":"QGYBJ.ParticleIO.write_particle_trajectories_by_zlevel","text":"write_particle_trajectories_by_zlevel(base_filename, tracker;\n                                      z_tolerance=1e-6, metadata=Dict())\n\nWrite particle trajectories to separate files based on z-level.\n\nThis function groups particles by their initial z-level and saves each group to a separate NetCDF file. Useful for analyzing particles initialized at different depths independently.\n\nParameters:\n\nbasefilename: Base name for output files (e.g., \"particles\" -> \"particlesz1.23.nc\")\ntracker: ParticleTracker instance with trajectory history\nz_tolerance: Tolerance for grouping particles by z-level (default: 1e-6)\nmetadata: Additional metadata to include in all files\n\nReturns: Dictionary mapping z-levels to filenames\n\nExample:\n\n# Initialize particles at multiple z-levels\nconfig = create_layered_distribution(0.0, 2π, 0.0, 2π, [π/4, π/2, 3π/4], 4, 4)\ntracker = ParticleTracker(config, grid, parallel_config)\n\n# Run simulation...\n\n# Save each z-level to separate file\nfiles = write_particle_trajectories_by_zlevel(\"particles\", tracker)\n# Creates: particles_z0.785.nc, particles_z1.571.nc, particles_z2.356.nc\n\n\n\n\n\n","category":"function"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.InterpolationSchemes.InterpolationMethod","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.InterpolationSchemes.InterpolationMethod","text":"Available interpolation methods.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleConfig3D","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleConfig3D","text":"Enhanced particle configuration supporting 3D distributions.\n\nDomain bounds (xmax, ymax, zmax) are REQUIRED - no defaults. Use the Grid to get domain size: `xmax = G.Lx, ymax = G.Ly, zmax = G.Lz`\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleDistribution","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.EnhancedParticleConfig.ParticleDistribution","text":"Available particle distribution patterns.\n\n\n\n\n\n","category":"type"},{"location":"api/particles/#QGYBJ.UnifiedParticleAdvection.EnhancedParticleConfig.initialize_particles_3d!","page":"Particles","title":"QGYBJ.UnifiedParticleAdvection.EnhancedParticleConfig.initialize_particles_3d!","text":"initialize_particles_3d!(tracker, config3d)\n\nInitialize particles using 3D configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#api-physics","page":"Physics Functions","title":"Physics Functions","text":"This page documents the physics functions in QGYBJ.jl.","category":"section"},{"location":"api/physics/#Elliptic-Inversions","page":"Physics Functions","title":"Elliptic Inversions","text":"","category":"section"},{"location":"api/physics/#Streamfunction-Inversion","page":"Physics Functions","title":"Streamfunction Inversion","text":"Solves: nabla^2psi + fracpartialpartial zleft(fracf_0^2N^2fracpartialpsipartial zright) = q\n\nUsage:\n\n# Serial mode\ninvert_q_to_psi!(state, grid; a=a_ell)\n\n# Parallel mode (with workspace for 2D decomposition)\ninvert_q_to_psi!(state, grid; a=a_ell, workspace=workspace)\n# Updates state.psi from state.q","category":"section"},{"location":"api/physics/#Wave-Amplitude-Inversion","page":"Physics Functions","title":"Wave Amplitude Inversion","text":"Solves: fracpartialpartial zleft(fracf_0^2N^2fracpartial Apartial zright) - frack_h^24A = B\n\nUsage:\n\n# Serial mode\ninvert_B_to_A!(state, grid, params, a_ell)\n\n# Parallel mode (with workspace for 2D decomposition)\ninvert_B_to_A!(state, grid, params, a_ell; workspace=workspace)\n# Updates state.A from state.B","category":"section"},{"location":"api/physics/#Helmholtz-Solver","page":"Physics Functions","title":"Helmholtz Solver","text":"","category":"section"},{"location":"api/physics/#Nonlinear-Terms","page":"Physics Functions","title":"Nonlinear Terms","text":"","category":"section"},{"location":"api/physics/#Jacobian","page":"Physics Functions","title":"Jacobian","text":"Computes: J(a b) = fracpartial apartial xfracpartial bpartial y - fracpartial apartial yfracpartial bpartial x","category":"section"},{"location":"api/physics/#Wave-Advection-and-Refraction","page":"Physics Functions","title":"Wave Advection and Refraction","text":"The wave nonlinear terms are documented in the Time Stepping API:\n\nconvol_waqg! - Computes J(psi B) (advection of wave envelope by streamfunction)\nrefraction_waqg! - Computes B zeta (wave refraction by vorticity)\ncompute_qw! - Computes wave feedback on mean flow q^w","category":"section"},{"location":"api/physics/#Velocity-Computation","page":"Physics Functions","title":"Velocity Computation","text":"Computes:\n\nu = -partialpsipartial y\nv = partialpsipartial x","category":"section"},{"location":"api/physics/#Vertical-Velocity","page":"Physics Functions","title":"Vertical Velocity","text":"","category":"section"},{"location":"api/physics/#Total-Velocities","page":"Physics Functions","title":"Total Velocities","text":"","category":"section"},{"location":"api/physics/#Dissipation","page":"Physics Functions","title":"Dissipation","text":"","category":"section"},{"location":"api/physics/#Vertical-Diffusion","page":"Physics Functions","title":"Vertical Diffusion","text":"Dissipation functions are documented in the Time Stepping API:\n\ndissipation_q_nv! - Applies vertical diffusion nu_z partial^2 q  partial z^2\nint_factor - Integrating factor for stiff hyperdiffusion terms","category":"section"},{"location":"api/physics/#Diagnostics-Functions","page":"Physics Functions","title":"Diagnostics Functions","text":"","category":"section"},{"location":"api/physics/#Energy","page":"Physics Functions","title":"Energy","text":"Flow energy can be computed from velocity fields using standard summation.","category":"section"},{"location":"api/physics/#Spectral-Energy-Functions","page":"Physics Functions","title":"Spectral Energy Functions","text":"The following spectral energy functions compute energy with proper dealiasing and density weighting:","category":"section"},{"location":"api/physics/#Global-Energy-Functions-(MPI-aware)","page":"Physics Functions","title":"Global Energy Functions (MPI-aware)","text":"For parallel simulations, use these MPI-aware versions that reduce across all processes:","category":"section"},{"location":"api/physics/#Energy-Diagnostics-Manager","page":"Physics Functions","title":"Energy Diagnostics Manager","text":"The EnergyDiagnosticsManager provides automatic saving of energy time series to separate NetCDF files:\n\nOutput Files:\n\ndiagnostic/wave_KE.nc - Wave kinetic energy\ndiagnostic/wave_PE.nc - Wave potential energy\ndiagnostic/wave_CE.nc - Wave correction energy (YBJ+)\ndiagnostic/mean_flow_KE.nc - Mean flow kinetic energy\ndiagnostic/mean_flow_PE.nc - Mean flow potential energy\ndiagnostic/total_energy.nc - Summary with all energies\n\nUsage:\n\n# Automatic (created during setup_simulation)\nsim = setup_simulation(config)\nrun_simulation!(sim)  # Energies saved automatically\n\n# Manual\nmanager = EnergyDiagnosticsManager(\"output_dir\"; output_interval=1.0)\nrecord_energies!(manager, time, wke, wpe, wce, mke, mpe)\nwrite_all_energy_files!(manager)","category":"section"},{"location":"api/physics/#Omega-Equation","page":"Physics Functions","title":"Omega Equation","text":"","category":"section"},{"location":"api/physics/#Transform-Functions","page":"Physics Functions","title":"Transform Functions","text":"","category":"section"},{"location":"api/physics/#Forward-Transforms","page":"Physics Functions","title":"Forward Transforms","text":"Real space → Spectral space","category":"section"},{"location":"api/physics/#Backward-Transforms","page":"Physics Functions","title":"Backward Transforms","text":"Spectral space → Real space","category":"section"},{"location":"api/physics/#Dealiasing","page":"Physics Functions","title":"Dealiasing","text":"Creates dealiasing mask using 2/3 rule.","category":"section"},{"location":"api/physics/#YBJ-Normal-Mode-Functions","page":"Physics Functions","title":"YBJ Normal Mode Functions","text":"","category":"section"},{"location":"api/physics/#Function-Signatures-Summary","page":"Physics Functions","title":"Function Signatures Summary","text":"Function Input Output In-place\ninvert_q_to_psi! q psi Yes\ninvert_B_to_A! B A, C Yes\njacobian_spectral! a, b J(a,b) Yes\ncompute_velocities! psi u, v Yes\nflow_kinetic_energy u, v scalar No\nwave_energy B, A scalar No","category":"section"},{"location":"api/physics/#Performance-Notes","page":"Physics Functions","title":"Performance Notes","text":"All physics functions are in-place to avoid allocations\nFFT plans are pre-computed for efficiency\nTridiagonal systems use Thomas algorithm (O(n))\nFunctions are type-stable for optimal JIT compilation","category":"section"},{"location":"api/physics/#2D-Decomposition-Notes","page":"Physics Functions","title":"2D Decomposition Notes","text":"Functions requiring vertical operations automatically detect 2D decomposition and use the appropriate method:\n\nFunction Serial Parallel (2D)\ninvert_q_to_psi! Direct solve Transpose → solve → transpose\ninvert_B_to_A! Direct solve Transpose → solve → transpose\ncompute_vertical_velocity! Direct solve Transpose → solve → transpose\ndissipation_q_nv! Direct Transpose if needed\n\nPattern:\n\nneed_transpose = G.decomp !== nothing && hasfield(typeof(G.decomp), :pencil_z)\nif need_transpose\n    _function_2d!(...)   # Uses transpose operations\nelse\n    _function_direct!(...)  # Direct vertical access\nend\n\nWorkspace requirement: Pass workspace argument for parallel mode to avoid repeated allocation of z-pencil arrays.","category":"section"},{"location":"api/physics/#QGYBJ.Elliptic.invert_q_to_psi!","page":"Physics Functions","title":"QGYBJ.Elliptic.invert_q_to_psi!","text":"invert_q_to_psi!(S, G; a, par=nothing, workspace=nothing)\n\nInvert spectral QGPV q(kx,ky,z) to obtain streamfunction ψ(kx,ky,z).\n\nMathematical Problem\n\nFor each horizontal wavenumber (kₓ, kᵧ), solve the vertical ODE:\n\na(z) ∂²ψ/∂z² - kₕ² ψ = q\n\nwith Neumann boundary conditions ψ_z = 0 at top and bottom.\n\nArguments\n\nS::State: State struct containing q (input) and psi (output)\nG::Grid: Grid struct with wavenumbers and vertical coordinates\na::AbstractVector: Elliptic coefficient a_ell(z) = f²/N²(z), length nz\npar: Optional QGParams for density weighting (defaults to unity weights)\nworkspace: Optional z-pencil workspace arrays for 2D decomposition\n\nImplementation Details\n\nFor 2D decomposition:\n\nTranspose q from xy-pencil to z-pencil (z becomes local)\nPerform tridiagonal solve on z-pencil data\nTranspose ψ from z-pencil back to xy-pencil\n\nThe discrete system is tridiagonal with structure:\n\nDiagonal: d[k] = -(a[k] + a[k-1])/r_st[k] - kₕ² dz²\nUpper diagonal: du[k] = a[k]/r_st[k]\nLower diagonal: dl[k] = a[k-1]/r_st[k]\n\nwhere rut, rst are density weights (unity for Boussinesq).\n\nFortran Correspondence\n\nThis matches psi_solver in elliptic.f90.\n\nMean Mode (kₕ=0) Handling\n\nFor the horizontal mean mode (kₓ=kᵧ=0), the equation reduces to:     ∂/∂z(a(z) ∂ψ/∂z) = q\n\nWith Neumann boundary conditions (∂ψ/∂z=0 at both boundaries), this operator is singular: the homogeneous equation has the constant function as its null space. Consequently:\n\nA solution exists only if ∫q dz = 0 (compatibility condition)\nThe solution is determined only up to an arbitrary constant\n\nThis implementation sets ψ=0 for kₕ=0 because:\n\nFor periodic domains, the mean streamfunction doesn't affect velocities (u = -∂ψ/∂y, v = ∂ψ/∂x, both zero for constant ψ)\nStandard spectral QG codes typically ignore the barotropic mean\nInitial conditions and forcing are assumed to have zero horizontal mean\n\nIf your application requires tracking vertically-varying barotropic modes, you would need to solve the singular ODE with an additional constraint (e.g., ∫ψ dz = 0) to uniquely determine the solution.\n\nExample\n\na_vec = a_ell_ut(params, G)  # Compute a_ell = f²/N²\ninvert_q_to_psi!(state, grid; a=a_vec)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Elliptic.invert_B_to_A!","page":"Physics Functions","title":"QGYBJ.Elliptic.invert_B_to_A!","text":"invert_B_to_A!(S, G, par, a; workspace=nothing)\n\nYBJ+ wave amplitude recovery: solve for A given B = L⁺A.\n\nMathematical Problem\n\nFor each horizontal wavenumber (kₓ, kᵧ), solve:\n\na(z) ∂²A/∂z² - (kₕ²/4) A = B\n\nwith Neumann boundary conditions A_z = 0 at top and bottom.\n\nArguments\n\nS::State: State containing B (input), A and C (output)\nG::Grid: Grid struct\npar: QGParams (for f0, N2 parameters)\na::AbstractVector: Elliptic coefficient a_ell(z) = f²/N²(z)\nworkspace: Optional z-pencil workspace for 2D decomposition\n\nOutput Fields\n\nS.A: Recovered wave amplitude A\nS.C: Vertical derivative C = ∂A/∂z (for wave velocity computation)\n\nMean Mode (kₕ=0) Handling\n\nFor the horizontal mean mode (kₓ=kᵧ=0), the equation reduces to:     a(z) ∂²A/∂z² = B\n\nWith Neumann boundary conditions (∂A/∂z=0 at both boundaries), this operator is singular - the constant function is in its null space. This implementation sets A=0 and C=0 for kₕ=0 because:\n\nHorizontally uniform waves (kₕ=0) have no horizontal gradients\nThe YBJ vertical velocity formula involves ∂A/∂x, ∂A/∂y which vanish for kₕ=0\nStandard NIW codes assume waves have horizontal structure\n\nIf your application requires horizontally uniform wave modes, you would need to solve the singular ODE with an additional constraint (e.g., ∫A dz = 0).\n\nFortran Correspondence\n\nThis matches A_solver_ybj_plus in elliptic.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Elliptic.invert_helmholtz!","page":"Physics Functions","title":"QGYBJ.Elliptic.invert_helmholtz!","text":"invert_helmholtz!(dstk, rhs, G, par; a, b=zeros, scale_kh2=1.0, bot_bc=nothing, top_bc=nothing, workspace=nothing)\n\nGeneral vertical Helmholtz inversion for each horizontal wavenumber.\n\nMathematical Problem\n\nSolve the ODE:\n\na(z) ∂²φ/∂z² + b(z) ∂φ/∂z - scale_kh2 × kₕ² φ = rhs\n\nwith Neumann boundary conditions (∂φ/∂z specified at boundaries).\n\nDiscretization (matches Fortran helmholtzdouble)\n\nUses a centered stencil where same a[k], b[k] apply to all diagonals at point k:\n\nBottom (k=1):  d = -a[1] - 0.5b[1]Δz - αkₕ²Δz², du = a[1] + 0.5b[1]Δz\nInterior:      d = -2a[k] - αkₕ²Δz², du = a[k] + 0.5b[k]Δz, dl = a[k] - 0.5b[k]Δz\nTop (k=nz):    d = -a[nz] + 0.5b[nz]Δz - αkₕ²Δz², dl = a[nz] - 0.5b[nz]Δz\n\nBoundary flux terms are added to RHS:\n\nBottom: rhs[1] += (a[1] - 0.5b[1]Δz) × Δz × bot_bc\nTop:    rhs[nz] -= (a[nz] + 0.5b[nz]Δz) × Δz × top_bc\n\nArguments\n\ndstk: Output array (nx, ny, nz) for solution φ\nrhs: Right-hand side array (nx, ny, nz)\nG::Grid: Grid struct\npar: QGParams (currently unused, kept for API consistency)\na::AbstractVector: Second derivative coefficient a(z), length nz\nb::AbstractVector: First derivative coefficient b(z), length nz (default zeros)\nscale_kh2::Real: Multiplier α for kₕ² term (default 1.0)\nbot_bc, top_bc: Optional boundary flux arrays (nx, ny) for non-zero Neumann BCs\nworkspace: Optional z-pencil workspace for 2D decomposition\n\nFortran Correspondence\n\nThis matches helmholtzdouble in elliptic.f90 exactly.\n\nNote\n\nFor 2D decomposition, boundary conditions are not yet supported and will trigger a warning.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Nonlinear.jacobian_spectral!","page":"Physics Functions","title":"QGYBJ.Nonlinear.jacobian_spectral!","text":"jacobian_spectral!(dstk, phik, chik, G, plans; Lmask=nothing)\n\nCompute the Jacobian J(φ, χ) = ∂φ/∂x ∂χ/∂y - ∂φ/∂y ∂χ/∂x using pseudo-spectral method.\n\nnote: Usage Note\nThis function is exported for user convenience but is not used in the main time-stepping code. The main code uses convol_waqg! instead, which computes advection terms using the divergence form with precomputed velocities.\n\nMathematical Definition\n\nThe Jacobian (also called Poisson bracket) is:\n\nJ(φ, χ) = ∂φ/∂x ∂χ/∂y - ∂φ/∂y ∂χ/∂x\n\nIn vector form: J(φ, χ) = ẑ · (∇φ × ∇χ)\n\nPhysical Interpretation\n\nJ(ψ, q): Advection of PV by geostrophic flow\nJ(ψ, B): Advection of wave envelope by mean flow\nThe Jacobian conserves both integrals ∫φ and ∫χ\n\nAlgorithm\n\nCompute spectral derivatives: φ̂ₓ = ikₓφ̂, φ̂ᵧ = ikᵧφ̂\nTransform derivatives to physical space\nCompute product: J = φₓχᵧ - φᵧχₓ (pointwise)\nTransform result back to spectral space\n\nArguments\n\ndstk: Output array for Ĵ(φ, χ) in spectral space\nphik: φ̂ in spectral space (must be real field, i.e., Hermitian symmetric)\nchik: χ̂ in spectral space (must be real field, i.e., Hermitian symmetric)\nG::Grid: Grid with wavenumber arrays\nplans: FFT plans from plan_transforms!\nLmask: Optional 2/3 dealiasing mask (true = keep mode, false = zero)\n\nImportant\n\nThis function assumes φ and χ are real-valued fields in physical space. For real fields, IFFT of spectral derivatives (imkφ̂) yields purely imaginary results, so the physical derivatives are extracted via imag().\n\nExample\n\n# Compute J(ψ, q) for real fields ψ and q\njacobian_spectral!(Jpsi_q, psi_k, q_k, grid, plans)\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Operators.compute_velocities!","page":"Physics Functions","title":"QGYBJ.Operators.compute_velocities!","text":"compute_velocities!(S, G; plans=nothing, params=nothing, compute_w=true, use_ybj_w=false, N2_profile=nothing, workspace=nothing, dealias_mask=nothing)\n\nCompute geostrophic velocities from the spectral streamfunction ψ̂.\n\nPhysical Equations\n\nHorizontal velocities from geostrophic balance:\n\nu = -∂ψ/∂y  →  û(k) = -i kᵧ ψ̂(k)\nv =  ∂ψ/∂x  →  v̂(k) =  i kₓ ψ̂(k)\n\nVertical velocity from QG omega equation:\n\n∇²w + (N²/f²) ∂²w/∂z² = 2 J(ψ_z, ∇²ψ)\n\nor YBJ formulation:\n\nw = -(f²/N²) [(∂A/∂x)_z - i(∂A/∂y)_z] + c.c.\n\nAlgorithm\n\nCompute û = -i kᵧ ψ̂ and v̂ = i kₓ ψ̂ in spectral space\nTransform to physical space via inverse FFT\nOptionally solve omega equation or use YBJ formula for w\n\nArguments\n\nS::State: State with ψ (input) and u, v, w (output)\nG::Grid: Grid with wavenumbers kx, ky\nplans: FFT plans (auto-generated if nothing)\nparams: Model parameters (for f₀, N²)\ncompute_w::Bool: If true, compute vertical velocity\nuse_ybj_w::Bool: If true, use YBJ formula instead of omega equation\nN2_profile::Vector: Optional N²(z) profile for vertical velocity computation\nworkspace: Optional pre-allocated workspace for 2D decomposition\ndealias_mask: Optional 2D dealiasing mask for omega equation RHS (quadratic term). Should be the same mask used for other nonlinear terms (typically 2/3 rule).\n\nReturns\n\nModified State with updated u, v, w fields.\n\nNote\n\nThis computes ONLY QG velocities. For Lagrangian advection including wave effects, use compute_total_velocities! instead.\n\nFortran Correspondence\n\nMatches compute_velo in derivatives.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Operators.compute_vertical_velocity!","page":"Physics Functions","title":"QGYBJ.Operators.compute_vertical_velocity!","text":"compute_vertical_velocity!(S, G, plans, params; N2_profile=nothing, workspace=nothing, dealias_mask=nothing)\n\nSolve the QG omega equation for ageostrophic vertical velocity.\n\nPhysical Background\n\nIn quasi-geostrophic dynamics, the leading-order horizontal flow is non-divergent (∇·u_g = 0). Vertical motion arises from ageostrophic corrections that maintain thermal wind balance as the flow evolves.\n\nThe omega equation relates w to the horizontal flow:\n\n∇²w + (N²/f²) ∂²w/∂z² = 2 J(ψ_z, ∇²ψ)\n\nwhere:\n\nLeft side: 3D Laplacian (horizontal + stratification-weighted vertical)\nRight side: Jacobian forcing from vertical shear and vorticity\n\nPhysical Interpretation\n\nThe RHS forcing J(ψ_z, ∇²ψ) represents:\n\nThermal wind tilting: vertical shear ψ_z interacting with vorticity ∇²ψ\nFrontogenesis/frontolysis: differential advection of temperature gradients\n\nStrong w occurs at:\n\nFronts (sharp density gradients)\nEdges of eddies (strong vorticity gradients)\n\nNumerical Method\n\nCompute RHS in spectral space via omegaeqnrhs!\nFor each horizontal wavenumber (kₓ, kᵧ):\nSet up tridiagonal system in z\nSolve using LAPACK gtsv! (O(nz) per wavenumber)\nTransform w to physical space\n\nBoundary Conditions\n\nw = 0 at z = 0 and z = Lz (rigid lid and bottom).\n\nArguments\n\nS::State: State with ψ (input) and w (output)\nG::Grid: Grid structure\nplans: FFT plans\nparams: Model parameters (f₀)\nN2_profile::Vector: Optional N²(z) profile (default: constant N² = 1)\nworkspace: Optional pre-allocated workspace for 2D decomposition\ndealias_mask: 2D dealiasing mask for omega equation RHS. If nothing (default), a standard 2/3-rule mask is computed automatically to avoid aliasing in the quadratic Jacobian term.\n\nFortran Correspondence\n\nMatches omega equation solver in the Fortran implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Operators.compute_total_velocities!","page":"Physics Functions","title":"QGYBJ.Operators.compute_total_velocities!","text":"compute_total_velocities!(S, G; plans=nothing, params=nothing, compute_w=true, use_ybj_w=false, N2_profile=nothing, workspace=nothing, dealias_mask=nothing)\n\nCompute the TOTAL velocity field for Lagrangian particle advection.\n\nPhysical Background\n\nIn QG-YBJ+ dynamics, a particle is advected by:\n\nGeostrophic flow: uQG = -∂ψ/∂y, vQG = ∂ψ/∂x\nWave-induced drift: Stokes drift from near-inertial waves\n\nThe total velocity is:\n\nu_total = u_QG + u_wave\nv_total = v_QG + v_wave\nw_total = w (from omega equation or YBJ)\n\nWave-Induced Horizontal Velocities\n\nThe Stokes drift from the wave envelope:\n\nu_wave = Re[(∂A*/∂x)A + A*(∂A/∂x)] = 2 Re[A* ∂A/∂x]\nv_wave = Re[(∂A*/∂y)A + A*(∂A/∂y)] = 2 Re[A* ∂A/∂y]\n\nThese wave corrections can be significant in regions of strong wave gradients.\n\nUsage\n\nFor Lagrangian particle advection, always use this function rather than compute_velocities! to include wave effects.\n\nArguments\n\nS::State: State with ψ, A (input) and u, v, w (output)\nG::Grid: Grid structure\nplans: FFT plans\nparams: Model parameters\ncompute_w::Bool: If true, compute vertical velocity\nuse_ybj_w::Bool: If true, use YBJ formula for w\nN2_profile::Vector: Optional N²(z) profile for vertical velocity computation\nworkspace: Optional pre-allocated workspace for 2D decomposition\ndealias_mask: Optional 2D dealiasing mask for omega equation RHS\n\nReturns\n\nModified State with total velocity fields u, v, w.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.wave_energy","page":"Physics Functions","title":"QGYBJ.Diagnostics.wave_energy","text":"wave_energy(B, A) -> (E_B, E_A)\n\nCompute domain-integrated wave energy from both B and A fields (simple version).\n\nPhysical Background\n\nTwo measures of wave energy in the model:\n\nEnvelope energy E_B = Σ |B|²\nBased on the evolved wave envelope\nDirectly available from prognostic variable\nAmplitude energy E_A = Σ |A|²\nBased on the recovered wave amplitude\nMore physically meaningful for wave energy flux\n\nUse Cases\n\nMonitor total wave energy conservation/dissipation\nCompare EB and EA to verify B→A recovery\nTrack energy exchange with mean flow\n\nArguments\n\nB::Array{Complex,3}: Wave envelope (spectral or physical)\nA::Array{Complex,3}: Wave amplitude (spectral or physical)\n\nReturns\n\nTuple (EB, EA) of domain-summed squared magnitudes.\n\nNote\n\nThese are domain SUMS, not means. For energy density, divide by grid volume.\nIn MPI mode, this returns LOCAL energy. Use mpireducesum for global total.\nFor physically accurate wave energies with dealiasing and density weighting, use wave_energy_spectral instead.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.flow_kinetic_energy_spectral","page":"Physics Functions","title":"QGYBJ.Diagnostics.flow_kinetic_energy_spectral","text":"flow_kinetic_energy_spectral(uk, vk, G, par; Lmask=nothing) -> KE\n\nCompute kinetic energy in spectral space with dealiasing and density weighting.\n\nPhysical Background (matches Fortran diagzentrum/energylinear)\n\nThe kinetic energy is computed as:\n\nKE(z) = Σₖ L(kₓ,kᵧ) × (|uₖ|² + |vₖ|²) - 0.5 × (|u₀₀|² + |v₀₀|²)\n\nThe dealiasing correction subtracts half the kh=0 mode because:\n\nWith 2/3 dealiasing: Σₖ (1/2)|u|² = Σₖ L|u|² - 0.5|u(0,0)|²\n\nThe total KE integrates over z with density weighting:\n\nKE_total = (1/nz) Σᵢ ρₛ(zᵢ) × KE(zᵢ)\n\nAlgorithm\n\nLoop over all spectral modes (kₓ, kᵧ, z) with dealiasing mask L\nAccumulate |u|² + |v|² at each level\nApply dealiasing correction: subtract half the kh=0 mode\nWeight by density ρₛ(z) and integrate (divide by nz)\n\nArguments\n\nuk, vk: Spectral velocity fields (complex)\nG::Grid: Grid structure\npar: QGParams (for density profiles)\nLmask: Optional dealiasing mask (default: all modes included)\n\nReturns\n\nTotal kinetic energy, normalized by nz, with density weighting.\n\nFortran Correspondence\n\nMatches the kinetic energy computation in diag_zentrum (diagnostics.f90:127-161) and energy_linear (diagnostics.f90:3024-3107).\n\nNote\n\nIn MPI mode, returns LOCAL energy. Use mpireducesum for global total.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.flow_potential_energy_spectral","page":"Physics Functions","title":"QGYBJ.Diagnostics.flow_potential_energy_spectral","text":"flow_potential_energy_spectral(bk, G, par; Lmask=nothing) -> PE\n\nCompute potential energy in spectral space with dealiasing and density weighting.\n\nPhysical Background\n\nThe potential energy from buoyancy variance:\n\nPE(z) = Σₖ L(kₓ,kᵧ) × (a_ell × ρ₁/ρ₂) × |bₖ|² - 0.5 × correction\n\nwhere a_ell = f²/N² is the elliptic coefficient.\n\nFor QG: b = ψ_z, so PE represents available potential energy from isopycnal tilting.\n\nArguments\n\nbk: Spectral buoyancy field (complex)\nG::Grid: Grid structure\npar: QGParams (for f0, N2 and density profiles)\nLmask: Optional dealiasing mask\n\nReturns\n\nTotal potential energy, normalized by nz, with density weighting.\n\nFortran Correspondence\n\nMatches the potential energy computation in diag_zentrum (ps term).\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.wave_energy_spectral","page":"Physics Functions","title":"QGYBJ.Diagnostics.wave_energy_spectral","text":"wave_energy_spectral(BR, BI, AR, AI, CR, CI, G, par; Lmask=nothing) -> (WKE, WPE, WCE)\n\nCompute physically accurate wave energies in spectral space with dealiasing.\n\nPhysical Background (matches Fortran wave_energy)\n\nThree components of wave energy:\n\nWave Kinetic Energy (WKE): WKE = Σₖ (|BRₖ|² + |BIₖ|²) - 0.5×(kh=0 mode)\nThis is the envelope-based kinetic energy, analogous to KE ~ ∫(u² + v²)dV.\nWave Potential Energy (WPE): WPE = Σₖ (0.5/(ρ₂×a_ell)) × kh² × (|CRₖ|² + |CIₖ|²)\nwhere C = ∂A/∂z and a_ell = f²/N². This represents the potential energy from vertical wave structure.\nWave Correction Energy (WCE): WCE = Σₖ (1/8) × (1/a_ell²) × kh⁴ × (|ARₖ|² + |AIₖ|²)\nHigher-order correction term from the YBJ+ formulation.\n\nAlgorithm\n\nLoop over all spectral modes with dealiasing mask L\nAccumulate |B|², kh²|C|²/(ρ₂×aell), kh⁴|A|²/(8×aell²)\nApply dealiasing correction: subtract half the kh=0 mode from WKE\nIntegrate over z (sum local, divide by nz)\n\nArguments\n\nBR, BI: Real and imaginary parts of wave envelope B (spectral)\nAR, AI: Real and imaginary parts of wave amplitude A (spectral)\nCR, CI: Real and imaginary parts of C = ∂A/∂z (spectral)\nG::Grid: Grid structure\npar: QGParams (for f0, N2)\nLmask: Optional dealiasing mask\n\nReturns\n\nTuple (WKE, WPE, WCE) of wave energy components, normalized by nz.\n\nFortran Correspondence\n\nMatches wave_energy subroutine in diagnostics.f90 (lines 647-743).\n\nNote\n\nIn MPI mode, returns LOCAL energy. Use mpireducesum for global totals.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.flow_kinetic_energy_spectral_global","page":"Physics Functions","title":"QGYBJ.Diagnostics.flow_kinetic_energy_spectral_global","text":"flow_kinetic_energy_spectral_global(uk, vk, G, par; Lmask=nothing, mpi_config=nothing) -> KE\n\nCompute GLOBAL kinetic energy in spectral space across all MPI processes.\n\nArguments\n\nuk, vk: Spectral velocity fields (local portion in MPI mode)\nG::Grid: Grid structure\npar: QGParams\nLmask: Optional dealiasing mask\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nGlobal kinetic energy with dealiasing and density weighting.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.flow_potential_energy_spectral_global","page":"Physics Functions","title":"QGYBJ.Diagnostics.flow_potential_energy_spectral_global","text":"flow_potential_energy_spectral_global(bk, G, par; Lmask=nothing, mpi_config=nothing) -> PE\n\nCompute GLOBAL potential energy in spectral space across all MPI processes.\n\nArguments\n\nbk: Spectral buoyancy field (local portion in MPI mode)\nG::Grid: Grid structure\npar: QGParams\nLmask: Optional dealiasing mask\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nGlobal potential energy with dealiasing and density weighting.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.wave_energy_spectral_global","page":"Physics Functions","title":"QGYBJ.Diagnostics.wave_energy_spectral_global","text":"wave_energy_spectral_global(BR, BI, AR, AI, CR, CI, G, par; Lmask=nothing, mpi_config=nothing) -> (WKE, WPE, WCE)\n\nCompute GLOBAL wave energies in spectral space across all MPI processes.\n\nArguments\n\nBR, BI, AR, AI, CR, CI: Spectral wave fields (local portions in MPI mode)\nG::Grid: Grid structure\npar: QGParams\nLmask: Optional dealiasing mask\nmpi_config: MPI configuration (nothing for serial mode)\n\nReturns\n\nTuple (WKE, WPE, WCE) of global wave energy components.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.EnergyDiagnostics.EnergyDiagnosticsManager","page":"Physics Functions","title":"QGYBJ.EnergyDiagnostics.EnergyDiagnosticsManager","text":"EnergyDiagnosticsManager\n\nManages separate energy diagnostic output files.\n\n\n\n\n\n","category":"type"},{"location":"api/physics/#QGYBJ.EnergyDiagnostics.record_energies!","page":"Physics Functions","title":"QGYBJ.EnergyDiagnostics.record_energies!","text":"record_energies!(manager, time, wave_KE, wave_PE, wave_CE, mean_flow_KE, mean_flow_PE)\n\nRecord energy values to the internal time series.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.EnergyDiagnostics.write_all_energy_files!","page":"Physics Functions","title":"QGYBJ.EnergyDiagnostics.write_all_energy_files!","text":"write_all_energy_files!(manager::EnergyDiagnosticsManager)\n\nWrite all energy time series to their respective files.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Diagnostics.omega_eqn_rhs!","page":"Physics Functions","title":"QGYBJ.Diagnostics.omega_eqn_rhs!","text":"omega_eqn_rhs!(rhs, psi, G, plans; Lmask=nothing, workspace=nothing)\n\nCompute the RHS forcing for the QG omega equation.\n\nPhysical Background\n\nThe QG omega equation relates vertical velocity w to the horizontal flow:\n\n∇²w + (N²/f²) ∂²w/∂z² = 2 J(ψ_z, ∇²ψ)\n\nThis function computes the RHS: 2 J(ψ_z, ∇²ψ), which represents the forcing for ageostrophic vertical motion.\n\nPhysical Interpretation\n\nThe Jacobian J(ψ_z, ∇²ψ) represents:\n\nψ_z: Vertical shear of streamfunction (related to thermal wind/buoyancy)\n∇²ψ: Relative vorticity ζ\nJ: Cross-gradient interaction\n\nStrong RHS forcing occurs where:\n\nFronts (large ψ_z) interact with vorticity gradients\nEddies tilt isopycnals through differential advection\n\nNumerical Method\n\nVertical derivative: ψ_z via forward finite difference\nψ_z[k] = (ψ[k+1] - ψ[k]) / dz,  ψ_z[nz] = 0 (Neumann)\nSpectral derivatives:\n∂ψz/∂x = i kₓ ψz\n∂ψz/∂y = i kᵧ ψz\n∂(∇²ψ)/∂x = -i kₓ kh² ψ_avg\n∂(∇²ψ)/∂y = -i kᵧ kh² ψ_avg\nwhere ψ_avg = (ψ[k+1] + ψ[k])/2 for staggered-grid consistency\nJacobian in physical space:\nJ(ψ_z, ∇²ψ) = (∂ψ_z/∂x)(∂∇²ψ/∂y) - (∂ψ_z/∂y)(∂∇²ψ/∂x)\nTransform back: FFT to get spectral RHS\n\nArguments\n\nrhs::Array{Complex,3}: Output RHS array (modified in-place)\npsi::Array{Complex,3}: Spectral streamfunction\nG::Grid: Grid structure\nplans: FFT plans\nLmask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nReturns\n\nModified rhs array with the omega equation forcing.\n\nFortran Correspondence\n\nMatches omega_eqn_rhs computation in the Fortran implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Transforms.fft_forward!","page":"Physics Functions","title":"QGYBJ.Transforms.fft_forward!","text":"fft_forward!(dst, src, P::Plans)\n\nCompute horizontal forward FFT (complex-to-complex) for each z-plane.\n\nAlgorithm\n\nSerial FFTW backend: Loops over z-slices and applies 2D FFT to each (x,y) plane.\n\nArguments\n\ndst: Destination array (spectral space)\nsrc: Source array (physical space)\nP::Plans: FFT plans\n\nReturns\n\nModified dst array.\n\nNote\n\nFor parallel execution with PencilArrays, the extension module (QGYBJMPIExt) provides a separate fft_forward!(dst::PencilArray, src::PencilArray, plans::MPIPlans) method that handles distributed transforms automatically.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.Transforms.fft_backward!","page":"Physics Functions","title":"QGYBJ.Transforms.fft_backward!","text":"fft_backward!(dst, src, P::Plans)\n\nCompute horizontal inverse FFT (complex-to-complex) for each z-plane.\n\nAlgorithm\n\nSerial FFTW backend: Loops over z-slices and applies 2D inverse FFT to each (x,y) plane. FFTW.ifft is NORMALIZED (divides by N automatically).\n\nArguments\n\ndst: Destination array (physical space, normalized)\nsrc: Source array (spectral space)\nP::Plans: FFT plans\n\nReturns\n\nModified dst array.\n\nNote\n\nFor parallel execution with PencilArrays, the extension module (QGYBJMPIExt) provides a separate fft_backward!(dst::PencilArray, src::PencilArray, plans::MPIPlans) method that uses ldiv! for normalized inverse transforms.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.dealias_mask","page":"Physics Functions","title":"QGYBJ.dealias_mask","text":"dealias_mask(G) -> Matrix{Bool}\n\nCompute the 2/3-rule dealiasing mask for spectral space.\n\nPhysical Background\n\nIn pseudo-spectral methods, nonlinear terms are computed by:\n\nTransform fields to physical space (inverse FFT)\nCompute products in physical space\nTransform back to spectral space (forward FFT)\n\nThe problem: A product of two fields with max wavenumber kmax produces wavenumbers up to 2×kmax. With finite resolution, these high-k components \"fold back\" (alias) onto resolved wavenumbers, causing errors.\n\nThe 2/3 Rule\n\nTo prevent aliasing from quadratic nonlinearities (e.g., u·∇q):\n\nKeep only wavenumbers |k| ≤ (2/3) × k_Nyquist\nTruncated modes: set to zero before computing nonlinear products\nResult: product wavenumbers stay within (2/3)×2 = (4/3) < k_Nyquist\n\nThis rule is exact for quadratic nonlinearities in 1D. For 2D with radial cutoff, it provides effective dealiasing.\n\nAlgorithm\n\nUses radial (isotropic) cutoff:\n\nk_max = min(nx, ny) / 3\nKeep mode (i,j) if sqrt(kx² + ky²) ≤ k_max\nMore isotropic than rectangular truncation\n\nArguments\n\nG::Grid: Grid with dimensions nx, ny\n\nReturns\n\nMatrix{Bool} of size (nx, ny):\n\ntrue = keep this wavenumber\nfalse = truncate (set to zero)\n\nUsage\n\nmask = dealias_mask(G)\nq_hat .*= mask  # Zero out aliased modes\n\nFortran Correspondence\n\nMatches LL(i,j) mask in the Fortran implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.YBJNormal.sumB!","page":"Physics Functions","title":"QGYBJ.YBJNormal.sumB!","text":"sumB!(B, G; Lmask=nothing, workspace=nothing)\n\nRemove the vertical mean from the wave envelope B at each horizontal wavenumber.\n\nPhysical Background\n\nIn the normal YBJ formulation, the wave envelope B is related to amplitude A by:\n\nB = N² ∂²A/∂z²\n\nSince ∂²A/∂z² must integrate to zero (boundary conditions), B should have zero vertical mean. This function enforces that constraint.\n\nAlgorithm\n\nFor each horizontal wavenumber (kₓ, kᵧ) within the dealiasing mask:\n\nCompute vertical mean: B̄(kₓ,kᵧ) = (1/nz) Σₖ B(kₓ,kᵧ,k)\nSubtract mean: B(kₓ,kᵧ,k) ← B(kₓ,kᵧ,k) - B̄\n\nFor wavenumbers outside the mask or kh² = 0, set B = 0.\n\nArguments\n\nB::Array{Complex,3}: Wave envelope (modified in-place)\nG::Grid: Grid structure with wavenumbers\nLmask: Optional dealiasing mask (default: all modes kept)\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nReturns\n\nModified B array with zero vertical mean at each (kₓ, kᵧ).\n\nFortran Correspondence\n\nMatches sumB in derivatives.f90.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.YBJNormal.compute_sigma","page":"Physics Functions","title":"QGYBJ.YBJNormal.compute_sigma","text":"compute_sigma(par, G, nBRk, nBIk, rBRk, rBIk; Lmask=nothing, workspace=nothing) -> sigma\n\nCompute the sigma constraint for normal YBJ A recovery.\n\nPhysical Background\n\nWhen recovering A from B via vertical integration, we need to determine the vertical mean of A. The sigma parameter provides this constraint from the nonlinear forcing terms.\n\nMathematical Formula\n\nFor each horizontal wavenumber (kₓ, kᵧ):\n\nσ(kₓ,kᵧ) = Σₖ [(rBRk + 2·nBIk)/kh² + i(rBIk - 2·nBRk)/kh²]\n\nwhere:\n\nnBRk, nBIk: Real and imaginary parts of nonlinear advection term\nrBRk, rBIk: Real and imaginary parts of refraction term\nkh² = kₓ² + kᵧ²\n\nArguments\n\npar::QGParams: Model parameters\nG::Grid: Grid with wavenumbers\nnBRk, nBIk: Real/imaginary parts of advection forcing\nrBRk, rBIk: Real/imaginary parts of refraction forcing\nLmask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nReturns\n\n2D complex array sigma(nxlocal, nylocal) with the constraint values.\n\nFortran Correspondence\n\nMatches compute_sigma in derivatives.f90.\n\nNote\n\nIn MPI mode with 2D decomposition, this requires z to be fully local. Transpose operations are handled internally if needed.\n\n\n\n\n\n","category":"function"},{"location":"api/physics/#QGYBJ.YBJNormal.compute_A!","page":"Physics Functions","title":"QGYBJ.YBJNormal.compute_A!","text":"compute_A!(A, C, BRk, BIk, sigma, par, G; Lmask=nothing, workspace=nothing)\n\nRecover wave amplitude A from envelope B using normal YBJ vertical integration.\n\nPhysical Background\n\nIn normal YBJ, B and A are related by:\n\nB = N² ∂²A/∂z²\n\nTo recover A from B, we integrate twice:\n\nFirst integral: ∂A/∂z = ∫ B/N² dz + c₁\nSecond integral: A = ∫∫ B/N² dz² + c₁z + c₂\n\nThe constants are determined by:\n\nBoundary condition: ∂A/∂z = 0 at top (Neumann)\nMean constraint: ∫A dz = σ (from sigma)\n\nAlgorithm\n\nFor each horizontal wavenumber (kₓ, kᵧ):\n\nStage 1: Cumulative Integration\n\nÃ[1] = 0\nÃ[k] = Ã[k-1] + (Σⱼ₌₁ᵏ⁻¹ B[j]) × N²[k-1] × dz²\n\nStage 2: Apply Sigma Constraint\n\nsumA = Σₖ Ã[k]\nadj = (σ - sumA) / nz\nA[k] = Ã[k] + adj   # Enforce ∫A = σ\n\nStage 3: Compute Vertical Derivative\n\nC[k] = (A[k+1] - A[k]) / dz   # Forward difference\nC[nz] = 0                      # Neumann BC at top\n\nArguments\n\nA::Array{Complex,3}: Output wave amplitude (modified in-place)\nC::Array{Complex,3}: Output vertical derivative A_z (modified in-place)\nBRk, BIk: Real/imaginary parts of wave envelope B\nsigma::Array{Complex,2}: Sigma constraint from compute_sigma\npar::QGParams: Model parameters\nG::Grid: Grid structure\nLmask: Optional dealiasing mask\nworkspace: Optional pre-allocated workspace for 2D decomposition\n\nReturns\n\nTuple (A, C) with recovered amplitude and its vertical derivative.\n\nFortran Correspondence\n\nMatches compute_A in derivatives.f90.\n\nNote\n\nThis is the NORMAL YBJ recovery method. For YBJ+, use invert_B_to_A! instead, which solves the full L⁺A = B elliptic problem via tridiagonal solve.\n\n\n\n\n\n","category":"function"},{"location":"worked_example/#Worked-Example","page":"Worked Example","title":"Worked Example","text":"This walkthrough sets up a small QG–YBJ+ simulation, runs it for a short time, and inspects some outputs.","category":"section"},{"location":"worked_example/#1)-Create-a-configuration","page":"Worked Example","title":"1) Create a configuration","text":"using QGYBJ\n\ndomain = create_domain_config(nx=64, ny=64, nz=32, Lx=4π, Ly=4π, Lz=2π)\nstrat  = create_stratification_config(:constant_N, N0=1.0)\ninit   = create_initial_condition_config(psi_type=:random, wave_type=:random,\n                                         psi_amplitude=0.1, wave_amplitude=0.01)\noutput = create_output_config(output_dir=\"./output_example\",\n                              psi_interval=1.0, wave_interval=1.0,\n                              save_velocities=true, save_vertical_velocity=true)\n\nconfig = create_model_config(domain, strat, init, output; dt=1e-3, total_time=2.0)","category":"section"},{"location":"worked_example/#2)-Setup-and-run-the-simulation","page":"Worked Example","title":"2) Setup and run the simulation","text":"sim = setup_simulation(config)\nrun_simulation!(sim)","category":"section"},{"location":"worked_example/#3)-Inspect-fields","page":"Worked Example","title":"3) Inspect fields","text":"# Compute velocities (if not already)\ncompute_velocities!(sim.state, sim.grid; plans=sim.plans, params=sim.params, compute_w=true)\n\n# Simple diagnostics\nusing QGYBJ: wave_energy\nEB, EA = wave_energy(sim.state.B, sim.state.A)\n@info \"Wave energies\" EB EA\n\n# Extract a horizontal slice of ψ\nusing QGYBJ: slice_horizontal\nψxy = slice_horizontal(sim.state.psi, sim.grid, sim.plans; k=sim.grid.nz ÷ 2)\n@info \"psi slice stats\" minimum(ψxy) maximum(ψxy)","category":"section"},{"location":"worked_example/#4)-Optional:-NetCDF-output","page":"Worked Example","title":"4) Optional: NetCDF output","text":"If you've installed NCDatasets.jl, run_simulation! writes NetCDF files in output_example/ at your configured intervals. You can open them with tools like Panoply, MATLAB, xarray, or NCDatasets.jl.","category":"section"},{"location":"#QGYBJ.jl","page":"Home","title":"QGYBJ.jl","text":"","category":"section"},{"location":"#A-Julia-Model-for-Wave-Eddy-Interactions-in-the-Ocean","page":"Home","title":"A Julia Model for Wave-Eddy Interactions in the Ocean","text":"QGYBJ.jl is a high-performance Julia implementation of the Quasi-Geostrophic Young-Ben Jelloul Plus (QG-YBJ+) model for simulating the interaction between near-inertial waves and mesoscale ocean eddies.\n\ntip: New to QGYBJ.jl?\nStart with the Quick Start Tutorial for a hands-on introduction.","category":"section"},{"location":"#What-This-Model-Does","page":"Home","title":"What This Model Does","text":"The ocean contains two important types of motion at different scales:\n\nMesoscale eddies (~100 km): Long-lived rotating vortices that dominate ocean kinetic energy\nNear-inertial waves (~10 km): Wind-generated internal waves oscillating near the Coriolis frequency\n\nThese two types of motion interact strongly: eddies refract and focus waves, while waves can feed energy back into the mean flow. QGYBJ.jl simulates this coupled system using:\n\nQuasi-geostrophic (QG) dynamics for the balanced eddy flow\nYBJ+ equations for the near-inertial wave envelope\nTwo-way coupling capturing wave-mean flow energy exchange","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Feature Description\nSpectral Methods Pseudo-spectral horizontal derivatives with FFTW\nVertical Solvers Efficient tridiagonal solvers for elliptic inversions\n2D Pencil Decomposition Scalable MPI parallelization with PencilArrays/PencilFFTs\nDual Pencil Configurations Automatic xy-pencil ↔ z-pencil transposes for vertical operations\nParticle Tracking Lagrangian advection with multiple interpolation schemes\nFlexible Physics Configurable stratification, dissipation, and wave feedback\nNetCDF I/O Standard output format for analysis","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using QGYBJ\n\n# Create configuration (Lx, Ly, Lz are REQUIRED)\nconfig = create_simple_config(\n    Lx=500e3, Ly=500e3, Lz=4000.0,  # 500km × 500km × 4km (required)\n    nx=64, ny=64, nz=32,             # Grid size\n    dt=0.001,                         # Time step\n    total_time=1.0,                   # Simulation duration\n    output_interval=100               # Output frequency\n)\n\n# Run simulation\nresult = run_simple_simulation(config)\n\n# Access results\npsi = result.state.psi   # Streamfunction\nB = result.state.B       # Wave envelope","category":"section"},{"location":"#Documentation-Sections","page":"Home","title":"Documentation Sections","text":"","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"Installation - How to install QGYBJ.jl\nQuick Start Tutorial - Your first simulation in 5 minutes\nWorked Example - Detailed walkthrough with explanations","category":"section"},{"location":"#Physics-and-Theory","page":"Home","title":"Physics & Theory","text":"Model Overview - Physical background and equations\nQG Equations - Quasi-geostrophic dynamics\nYBJ+ Wave Model - Near-inertial wave formulation\nNumerical Methods - Algorithms and discretization","category":"section"},{"location":"#User-Guide","page":"Home","title":"User Guide","text":"Configuration - Setting up simulations\nStratification - Ocean density profiles\nI/O and Output - Saving and loading data\nDiagnostics - Energy and analysis tools","category":"section"},{"location":"#Advanced-Topics","page":"Home","title":"Advanced Topics","text":"MPI Parallelization - Running on clusters\nParticle Advection - Lagrangian tracking\nPerformance Tips - Optimization strategies","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"Core Types - QGParams, Grid, State\nPhysics Functions - Operators and solvers\nFull Index - Complete function listing","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Basic-Installation","page":"Home","title":"Basic Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/subhk/QGYBJ.jl\")","category":"section"},{"location":"#With-MPI-Support","page":"Home","title":"With MPI Support","text":"Pkg.add([\"MPI\", \"PencilArrays\", \"PencilFFTs\"])","category":"section"},{"location":"#With-NetCDF-Output","page":"Home","title":"With NetCDF Output","text":"Pkg.add(\"NCDatasets\")","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use QGYBJ.jl in your research, please cite:\n\n@software{qgybj_jl,\n  author = {Kar, Subhajit},\n  title = {QGYBJ.jl: A Julia Implementation of the QG-YBJ+ Model},\n  year = {2024},\n  url = {https://github.com/subhk/QGYBJ.jl}\n}","category":"section"},{"location":"#Key-References","page":"Home","title":"Key References","text":"Asselin & Young (2019): YBJ+ formulation for penetration of near-inertial waves\nXie & Vanneste (2015): Wave feedback mechanism (qʷ term)\nYoung & Ben Jelloul (1997): Original YBJ wave envelope equation","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"Issues: GitHub Issues\nDiscussions: GitHub Discussions","category":"section"},{"location":"#License","page":"Home","title":"License","text":"QGYBJ.jl is released under the MIT License.","category":"section"}]
}
