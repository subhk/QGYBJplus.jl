<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Methods · QGYBJ.jl</title><meta name="title" content="Numerical Methods · QGYBJ.jl"/><meta property="og:title" content="Numerical Methods · QGYBJ.jl"/><meta property="twitter:title" content="Numerical Methods · QGYBJ.jl"/><meta name="description" content="Documentation for QGYBJ.jl."/><meta property="og:description" content="Documentation for QGYBJ.jl."/><meta property="twitter:description" content="Documentation for QGYBJ.jl."/><meta property="og:url" content="https://subhk.github.io/QGYBJ.jl/stable/physics/numerical_methods/"/><meta property="twitter:url" content="https://subhk.github.io/QGYBJ.jl/stable/physics/numerical_methods/"/><link rel="canonical" href="https://subhk.github.io/QGYBJ.jl/stable/physics/numerical_methods/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QGYBJ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../worked_example/">Worked Example</a></li></ul></li><li><span class="tocitem">Physics &amp; Theory</span><ul><li><a class="tocitem" href="../overview/">Model Overview</a></li><li><a class="tocitem" href="../qg_equations/">QG Equations</a></li><li><a class="tocitem" href="../ybj_plus/">YBJ+ Wave Model</a></li><li><a class="tocitem" href="../wave_mean/">Wave-Mean Interaction</a></li><li class="is-active"><a class="tocitem" href>Numerical Methods</a><ul class="internal"><li><a class="tocitem" href="#Spatial-Discretization"><span>Spatial Discretization</span></a></li><li><a class="tocitem" href="#Time-Integration"><span>Time Integration</span></a></li><li><a class="tocitem" href="#Elliptic-Inversions"><span>Elliptic Inversions</span></a></li><li><a class="tocitem" href="#FFT-Implementation"><span>FFT Implementation</span></a></li><li><a class="tocitem" href="#2D-Pencil-Decomposition"><span>2D Pencil Decomposition</span></a></li><li><a class="tocitem" href="#Jacobian/Advection-Computation"><span>Jacobian/Advection Computation</span></a></li><li><a class="tocitem" href="#Stability-Constraints"><span>Stability Constraints</span></a></li><li><a class="tocitem" href="#Memory-Layout"><span>Memory Layout</span></a></li><li><a class="tocitem" href="#Accuracy-Verification"><span>Accuracy Verification</span></a></li><li><a class="tocitem" href="#Performance-Optimization"><span>Performance Optimization</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../guide/configuration/">Configuration</a></li><li><a class="tocitem" href="../../guide/stratification/">Stratification</a></li><li><a class="tocitem" href="../../guide/initial_conditions/">Initial Conditions</a></li><li><a class="tocitem" href="../../guide/simulation/">Running Simulations</a></li><li><a class="tocitem" href="../../guide/io/">I/O and Output</a></li><li><a class="tocitem" href="../../guide/diagnostics/">Diagnostics</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../../advanced/parallel/">MPI Parallelization</a></li><li><a class="tocitem" href="../../advanced/particles/">Particle Advection</a></li><li><a class="tocitem" href="../../advanced/parallel_particles/">Parallel Particle Algorithm</a></li><li><a class="tocitem" href="../../advanced/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../advanced/performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../api/types/">Core Types</a></li><li><a class="tocitem" href="../../api/grid_state/">Grid &amp; State</a></li><li><a class="tocitem" href="../../api/physics/">Physics Functions</a></li><li><a class="tocitem" href="../../api/timestepping/">Time Stepping</a></li><li><a class="tocitem" href="../../api/particles/">Particles</a></li><li><a class="tocitem" href="../../api/">Full Index</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Physics &amp; Theory</a></li><li class="is-active"><a href>Numerical Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/QGYBJ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/QGYBJ.jl/blob/main/docs/src/physics/numerical_methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="numerical-methods"><a class="docs-heading-anchor" href="#numerical-methods">Numerical Methods</a><a id="numerical-methods-1"></a><a class="docs-heading-anchor-permalink" href="#numerical-methods" title="Permalink"></a></h1><p>This page describes the numerical algorithms used in QGYBJ.jl, including the 2D pencil decomposition strategy for parallel execution.</p><h2 id="Spatial-Discretization"><a class="docs-heading-anchor" href="#Spatial-Discretization">Spatial Discretization</a><a id="Spatial-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Discretization" title="Permalink"></a></h2><h3 id="Horizontal:-Pseudo-Spectral-Method"><a class="docs-heading-anchor" href="#Horizontal:-Pseudo-Spectral-Method">Horizontal: Pseudo-Spectral Method</a><a id="Horizontal:-Pseudo-Spectral-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Horizontal:-Pseudo-Spectral-Method" title="Permalink"></a></h3><p>The model uses a <strong>pseudo-spectral</strong> approach in the horizontal:</p><table><tr><th style="text-align: left">Operation</th><th style="text-align: left">Space</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left">Linear derivatives</td><td style="text-align: left">Spectral</td><td style="text-align: left">Multiply by <code>ik_x</code>, <code>ik_y</code></td></tr><tr><td style="text-align: left">Nonlinear products</td><td style="text-align: left">Physical</td><td style="text-align: left">Pointwise multiplication</td></tr><tr><td style="text-align: left">Transform</td><td style="text-align: left">Both</td><td style="text-align: left">FFT / IFFT</td></tr></table><h4 id="Advantages"><a class="docs-heading-anchor" href="#Advantages">Advantages</a><a id="Advantages-1"></a><a class="docs-heading-anchor-permalink" href="#Advantages" title="Permalink"></a></h4><ul><li><strong>Spectral accuracy</strong> for smooth fields</li><li><strong>Efficient</strong> O(N log N) via FFT</li><li><strong>No numerical diffusion</strong> from derivatives</li></ul><h4 id="Dealiasing"><a class="docs-heading-anchor" href="#Dealiasing">Dealiasing</a><a id="Dealiasing-1"></a><a class="docs-heading-anchor-permalink" href="#Dealiasing" title="Permalink"></a></h4><p>Nonlinear products create aliasing errors. We use the <strong>2/3 rule</strong>:</p><p class="math-container">\[k_{max} = \frac{2}{3} \cdot \frac{N}{2}\]</p><p>Modes with <code>|k| &gt; k_max</code> are set to zero after each nonlinear term.</p><pre><code class="language-julia hljs"># Apply dealiasing mask
mask = dealias_mask(grid)
@. field_k *= mask</code></pre><h3 id="Vertical:-Finite-Differences"><a class="docs-heading-anchor" href="#Vertical:-Finite-Differences">Vertical: Finite Differences</a><a id="Vertical:-Finite-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Vertical:-Finite-Differences" title="Permalink"></a></h3><p>The vertical direction uses <strong>second-order centered differences</strong>:</p><p class="math-container">\[\frac{\partial f}{\partial z}\bigg|_k \approx \frac{f_{k+1} - f_{k-1}}{2\Delta z}\]</p><p class="math-container">\[\frac{\partial^2 f}{\partial z^2}\bigg|_k \approx \frac{f_{k+1} - 2f_k + f_{k-1}}{\Delta z^2}\]</p><p>For variable coefficients (stratification):</p><p class="math-container">\[\frac{\partial}{\partial z}\left(a(z)\frac{\partial f}{\partial z}\right) \approx \frac{a_{k+1/2}(f_{k+1} - f_k) - a_{k-1/2}(f_k - f_{k-1})}{\Delta z^2}\]</p><h2 id="Time-Integration"><a class="docs-heading-anchor" href="#Time-Integration">Time Integration</a><a id="Time-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Integration" title="Permalink"></a></h2><h3 id="Leapfrog-with-Robert-Asselin-Filter-and-Integrating-Factors"><a class="docs-heading-anchor" href="#Leapfrog-with-Robert-Asselin-Filter-and-Integrating-Factors">Leapfrog with Robert-Asselin Filter and Integrating Factors</a><a id="Leapfrog-with-Robert-Asselin-Filter-and-Integrating-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Leapfrog-with-Robert-Asselin-Filter-and-Integrating-Factors" title="Permalink"></a></h3><p>The primary time stepping scheme is <strong>leapfrog</strong> with Robert-Asselin filtering and <strong>integrating factors</strong> for hyperdiffusion.</p><h4 id="Forward-Euler-(First-Step)"><a class="docs-heading-anchor" href="#Forward-Euler-(First-Step)">Forward Euler (First Step)</a><a id="Forward-Euler-(First-Step)-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Euler-(First-Step)" title="Permalink"></a></h4><p>The first step uses forward Euler to bootstrap the leapfrog scheme:</p><p class="math-container">\[q^{n+1} = \left[ q^n - \Delta t \cdot J(\psi, q)^n + \Delta t \cdot D_q^n \right] \cdot e^{-\lambda \Delta t}\]</p><p>For the wave envelope (in real/imaginary form):</p><p class="math-container">\[B_R^{n+1} = \left[ B_R^n - \Delta t \cdot J(\psi, B_R) - \Delta t \cdot \frac{N^2 k_h^2}{2 f_0} A_I + \Delta t \cdot \frac{1}{2} r_{BI} \right] \cdot e^{-\lambda_w \Delta t}\]</p><p class="math-container">\[B_I^{n+1} = \left[ B_I^n - \Delta t \cdot J(\psi, B_I) + \Delta t \cdot \frac{N^2 k_h^2}{2 f_0} A_R - \Delta t \cdot \frac{1}{2} r_{BR} \right] \cdot e^{-\lambda_w \Delta t}\]</p><p>where <span>$N^2$</span> is the buoyancy frequency squared and <span>$f_0$</span> is the Coriolis parameter.</p><h4 id="Leapfrog-(Subsequent-Steps)"><a class="docs-heading-anchor" href="#Leapfrog-(Subsequent-Steps)">Leapfrog (Subsequent Steps)</a><a id="Leapfrog-(Subsequent-Steps)-1"></a><a class="docs-heading-anchor-permalink" href="#Leapfrog-(Subsequent-Steps)" title="Permalink"></a></h4><p>Subsequent steps use centered leapfrog with integrating factors:</p><p class="math-container">\[q^{n+1} = q^{n-1} \cdot e^{-2\lambda \Delta t} - 2\Delta t \cdot J(\psi, q)^n \cdot e^{-\lambda \Delta t} + 2\Delta t \cdot D_q^n \cdot e^{-2\lambda \Delta t}\]</p><p class="math-container">\[B_R^{n+1} = B_R^{n-1} \cdot e^{-2\lambda_w \Delta t} - 2\Delta t \cdot \left[ J(\psi, B_R) + \frac{N^2 k_h^2}{2 f_0} A_I - \frac{1}{2} r_{BI} \right]^n \cdot e^{-\lambda_w \Delta t}\]</p><p class="math-container">\[B_I^{n+1} = B_I^{n-1} \cdot e^{-2\lambda_w \Delta t} - 2\Delta t \cdot \left[ J(\psi, B_I) - \frac{N^2 k_h^2}{2 f_0} A_R + \frac{1}{2} r_{BR} \right]^n \cdot e^{-\lambda_w \Delta t}\]</p><h4 id="Robert-Asselin-Filter"><a class="docs-heading-anchor" href="#Robert-Asselin-Filter">Robert-Asselin Filter</a><a id="Robert-Asselin-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Robert-Asselin-Filter" title="Permalink"></a></h4><p>The Robert-Asselin filter damps the computational mode that can grow with leapfrog:</p><p class="math-container">\[\tilde{q}^n = q^n + \gamma \left( q^{n-1} - 2q^n + q^{n+1} \right)\]</p><p>where <span>$\gamma \approx 0.001$</span> (typically very small to minimize physical mode damping).</p><pre><code class="language-julia hljs"># First step: Forward Euler
first_projection_step!(state, grid, params, plans; a=a_vec, dealias_mask=mask)

# Subsequent steps: Leapfrog with Robert-Asselin
leapfrog_step!(state_np1, state_n, state_nm1, grid, params, plans;
               a=a_vec, dealias_mask=mask)</code></pre><h3 id="Integrating-Factor-Method"><a class="docs-heading-anchor" href="#Integrating-Factor-Method">Integrating Factor Method</a><a id="Integrating-Factor-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Integrating-Factor-Method" title="Permalink"></a></h3><p>The integrating factor <span>$\lambda$</span> handles hyperdiffusion exactly:</p><p class="math-container">\[\lambda = \nu_{h1} \left( |k_x|^{2 \cdot ilap1} + |k_y|^{2 \cdot ilap1} \right) + \nu_{h2} \left( |k_x|^{2 \cdot ilap2} + |k_y|^{2 \cdot ilap2} \right)\]</p><p>where (using Unicode parameters):</p><ul><li><span>$\nu_{h1}$</span> (<code>νₕ₁</code>), <code>ilap1</code>: First hyperdiffusion operator (default: biharmonic with ilap1=2)</li><li><span>$\nu_{h2}$</span> (<code>νₕ₂</code>), <code>ilap2</code>: Second hyperdiffusion operator (default: hyper-6 with ilap2=6)</li></ul><p>The wave field has its own integrating factor <span>$\lambda_w$</span> with potentially different coefficients.</p><p><strong>Advantages of integrating factors:</strong></p><ul><li>Hyperdiffusion is treated <strong>exactly</strong> (no stability restriction)</li><li>Allows much larger time steps than explicit diffusion treatment</li><li>Second-order accuracy preserved for advective terms</li></ul><h2 id="Elliptic-Inversions"><a class="docs-heading-anchor" href="#Elliptic-Inversions">Elliptic Inversions</a><a id="Elliptic-Inversions-1"></a><a class="docs-heading-anchor-permalink" href="#Elliptic-Inversions" title="Permalink"></a></h2><h3 id="Tridiagonal-Systems"><a class="docs-heading-anchor" href="#Tridiagonal-Systems">Tridiagonal Systems</a><a id="Tridiagonal-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Tridiagonal-Systems" title="Permalink"></a></h3><p>Both QG (q -&gt; psi) and YBJ+ (B -&gt; A) inversions lead to tridiagonal systems at each horizontal wavenumber (kx, ky):</p><p class="math-container">\[a_k x_{k-1} + b_k x_k + c_k x_{k+1} = d_k\]</p><h3 id="Thomas-Algorithm"><a class="docs-heading-anchor" href="#Thomas-Algorithm">Thomas Algorithm</a><a id="Thomas-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Thomas-Algorithm" title="Permalink"></a></h3><p>We solve these in O(N) operations using the Thomas algorithm:</p><p><strong>Forward sweep:</strong></p><pre><code class="language-julia hljs">for k = 2:nz
    w = a[k] / b[k-1]
    b[k] = b[k] - w * c[k-1]
    d[k] = d[k] - w * d[k-1]
end</code></pre><p><strong>Back substitution:</strong></p><pre><code class="language-julia hljs">x[nz] = d[nz] / b[nz]
for k = nz-1:-1:1
    x[k] = (d[k] - c[k] * x[k+1]) / b[k]
end</code></pre><h3 id="Key-Inversions"><a class="docs-heading-anchor" href="#Key-Inversions">Key Inversions</a><a id="Key-Inversions-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Inversions" title="Permalink"></a></h3><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Solves</th><th style="text-align: left">Physical Meaning</th></tr><tr><td style="text-align: left"><code>invert_q_to_psi!</code></td><td style="text-align: left">nabla²psi + (f²/N²)d²psi/dz² = q</td><td style="text-align: left">PV to streamfunction</td></tr><tr><td style="text-align: left"><code>invert_B_to_A!</code></td><td style="text-align: left">L⁺A = B</td><td style="text-align: left">Wave envelope to amplitude</td></tr><tr><td style="text-align: left"><code>invert_helmholtz!</code></td><td style="text-align: left">nabla²phi - lambda*phi = f</td><td style="text-align: left">General Helmholtz</td></tr></table><h2 id="FFT-Implementation"><a class="docs-heading-anchor" href="#FFT-Implementation">FFT Implementation</a><a id="FFT-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#FFT-Implementation" title="Permalink"></a></h2><h3 id="Serial-Mode:-FFTW"><a class="docs-heading-anchor" href="#Serial-Mode:-FFTW">Serial Mode: FFTW</a><a id="Serial-Mode:-FFTW-1"></a><a class="docs-heading-anchor-permalink" href="#Serial-Mode:-FFTW" title="Permalink"></a></h3><p>We use FFTW with <strong>measured</strong> plans for optimal performance:</p><pre><code class="language-julia hljs"># Create optimized plans
plans = plan_transforms!(grid)

# Forward FFT (physical -&gt; spectral)
fft_forward!(dst, src, plans)

# Backward FFT (spectral -&gt; physical)
fft_backward!(dst, src, plans)</code></pre><p>Plan creation is expensive (~seconds) but execution is fast.</p><h3 id="Parallel-Mode:-PencilFFTs"><a class="docs-heading-anchor" href="#Parallel-Mode:-PencilFFTs">Parallel Mode: PencilFFTs</a><a id="Parallel-Mode:-PencilFFTs-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Mode:-PencilFFTs" title="Permalink"></a></h3><p>For MPI parallel execution, we use PencilFFTs which handles distributed FFTs:</p><pre><code class="language-julia hljs"># Create parallel FFT plans
plans = QGYBJ.plan_mpi_transforms(grid, mpi_config)

# Same interface as serial
fft_forward!(dst, src, plans)
fft_backward!(dst, src, plans)</code></pre><p>PencilFFTs automatically handles the transposes needed for distributed FFTs.</p><h2 id="2D-Pencil-Decomposition"><a class="docs-heading-anchor" href="#2D-Pencil-Decomposition">2D Pencil Decomposition</a><a id="2D-Pencil-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Pencil-Decomposition" title="Permalink"></a></h2><h3 id="The-Challenge"><a class="docs-heading-anchor" href="#The-Challenge">The Challenge</a><a id="The-Challenge-1"></a><a class="docs-heading-anchor-permalink" href="#The-Challenge" title="Permalink"></a></h3><p>The model requires two types of operations:</p><ol><li><strong>Horizontal FFTs</strong>: Need consecutive x and y data</li><li><strong>Vertical solves</strong>: Need all z data at each (x,y) point</li></ol><p>With 2D decomposition, no single configuration has all data local.</p><h3 id="Solution:-Dual-Pencil-Configurations"><a class="docs-heading-anchor" href="#Solution:-Dual-Pencil-Configurations">Solution: Dual Pencil Configurations</a><a id="Solution:-Dual-Pencil-Configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Solution:-Dual-Pencil-Configurations" title="Permalink"></a></h3><p>QGYBJ.jl uses two pencil configurations:</p><table><tr><th style="text-align: left">Configuration</th><th style="text-align: left">Local Dimension</th><th style="text-align: left">Distributed Dimensions</th><th style="text-align: left">Use</th></tr><tr><td style="text-align: left"><strong>xy-pencil</strong></td><td style="text-align: left">x</td><td style="text-align: left">y, z</td><td style="text-align: left">Horizontal FFTs</td></tr><tr><td style="text-align: left"><strong>z-pencil</strong></td><td style="text-align: left">z</td><td style="text-align: left">x, y</td><td style="text-align: left">Vertical operations</td></tr></table><pre><code class="nohighlight hljs">    xy-pencil                           z-pencil
   (x local)                          (z local)
┌─────────────────┐               ┌─────────────────┐
│ x: FULL         │               │ x: distributed  │
│ y: distributed  │  &lt;-----&gt;      │ y: distributed  │
│ z: distributed  │  transpose    │ z: FULL         │
└─────────────────┘               └─────────────────┘</code></pre><h3 id="Transpose-Operations"><a class="docs-heading-anchor" href="#Transpose-Operations">Transpose Operations</a><a id="Transpose-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Transpose-Operations" title="Permalink"></a></h3><p>Functions requiring vertical operations follow this pattern:</p><pre><code class="language-julia hljs">function some_vertical_operation!(S, G; workspace=nothing)
    # Check if 2D decomposition is active
    need_transpose = G.decomp !== nothing &amp;&amp; hasfield(typeof(G.decomp), :pencil_z)

    if need_transpose
        # 1. Transpose from xy-pencil to z-pencil
        transpose_to_z_pencil!(workspace.field_z, S.field, G)

        # 2. Perform vertical operation (z now fully local)
        _vertical_operation_on_z_pencil!(workspace.result_z, workspace.field_z, ...)

        # 3. Transpose result back to xy-pencil
        transpose_to_xy_pencil!(S.result, workspace.result_z, G)
    else
        # Serial mode: direct vertical operation
        _vertical_operation_direct!(S, G, ...)
    end
end</code></pre><h3 id="Functions-Using-This-Pattern"><a class="docs-heading-anchor" href="#Functions-Using-This-Pattern">Functions Using This Pattern</a><a id="Functions-Using-This-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-Using-This-Pattern" title="Permalink"></a></h3><table><tr><th style="text-align: left">Function</th><th style="text-align: left">What it does</th><th style="text-align: left">Needs z local?</th></tr><tr><td style="text-align: left"><code>invert_q_to_psi!</code></td><td style="text-align: left">PV inversion</td><td style="text-align: left">Yes (tridiagonal)</td></tr><tr><td style="text-align: left"><code>invert_B_to_A!</code></td><td style="text-align: left">Wave amplitude recovery</td><td style="text-align: left">Yes (tridiagonal)</td></tr><tr><td style="text-align: left"><code>invert_helmholtz!</code></td><td style="text-align: left">General Helmholtz</td><td style="text-align: left">Yes (tridiagonal)</td></tr><tr><td style="text-align: left"><code>compute_vertical_velocity!</code></td><td style="text-align: left">Omega equation</td><td style="text-align: left">Yes (tridiagonal)</td></tr><tr><td style="text-align: left"><code>compute_ybj_vertical_velocity!</code></td><td style="text-align: left">YBJ w formula</td><td style="text-align: left">Yes (vertical derivative)</td></tr><tr><td style="text-align: left"><code>dissipation_q_nv!</code></td><td style="text-align: left">Numerical dissipation</td><td style="text-align: left">Yes (vertical terms)</td></tr><tr><td style="text-align: left"><code>sumB!</code></td><td style="text-align: left">Sum B over depth</td><td style="text-align: left">Yes (vertical sum)</td></tr><tr><td style="text-align: left"><code>compute_sigma</code></td><td style="text-align: left">YBJ sigma term</td><td style="text-align: left">Yes (vertical operations)</td></tr><tr><td style="text-align: left"><code>compute_A!</code></td><td style="text-align: left">Compute A from B</td><td style="text-align: left">Yes (vertical operations)</td></tr><tr><td style="text-align: left"><code>omega_eqn_rhs!</code></td><td style="text-align: left">RHS of omega equation</td><td style="text-align: left">Yes (vertical derivatives)</td></tr></table><h3 id="Workspace-Arrays"><a class="docs-heading-anchor" href="#Workspace-Arrays">Workspace Arrays</a><a id="Workspace-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Workspace-Arrays" title="Permalink"></a></h3><p>To avoid repeated allocation, pre-allocate z-pencil workspace:</p><pre><code class="language-julia hljs"># Initialize once
workspace = QGYBJ.init_mpi_workspace(grid, mpi_config)

# Contents:
# workspace.q_z, workspace.psi_z, workspace.B_z,
# workspace.A_z, workspace.C_z, workspace.work_z

# Pass to functions
invert_q_to_psi!(state, grid; a=a_vec, workspace=workspace)</code></pre><h2 id="Jacobian/Advection-Computation"><a class="docs-heading-anchor" href="#Jacobian/Advection-Computation">Jacobian/Advection Computation</a><a id="Jacobian/Advection-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian/Advection-Computation" title="Permalink"></a></h2><h3 id="Divergence-Form-(convol_waqg)"><a class="docs-heading-anchor" href="#Divergence-Form-(convol_waqg)">Divergence Form (convol_waqg)</a><a id="Divergence-Form-(convol_waqg)-1"></a><a class="docs-heading-anchor-permalink" href="#Divergence-Form-(convol_waqg)" title="Permalink"></a></h3><p>For advection terms like <span>$J(\psi, q)$</span>, QGYBJ.jl uses the <strong>divergence form</strong>:</p><p class="math-container">\[J(\psi, q) = \frac{\partial(uq)}{\partial x} + \frac{\partial(vq)}{\partial y} = ik_x \widehat{uq} + ik_y \widehat{vq}\]</p><p>where <span>$u = -\partial\psi/\partial y$</span> and <span>$v = \partial\psi/\partial x$</span> are the geostrophic velocities.</p><h3 id="Algorithm-(convol_waqg)"><a class="docs-heading-anchor" href="#Algorithm-(convol_waqg)">Algorithm (convol_waqg)</a><a id="Algorithm-(convol_waqg)-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-(convol_waqg)" title="Permalink"></a></h3><ol><li><p>Precompute velocities in real space: <span>$u_r$</span>, <span>$v_r$</span></p></li><li><p>Transform field to real space:</p><pre><code class="language-julia hljs">fft_backward!(qr, qk, plans)</code></pre></li><li><p>Compute products in real space:</p><pre><code class="language-julia hljs">uterm = u_r .* qr
vterm = v_r .* qr</code></pre></li><li><p>Transform back and compute divergence:</p><pre><code class="language-julia hljs">fft_forward!(uterm_k, uterm, plans)
fft_forward!(vterm_k, vterm, plans)
J_k = im * kx .* uterm_k + im * ky .* vterm_k</code></pre></li><li><p>Apply dealiasing:</p><pre><code class="language-julia hljs">J_k[.!dealias_mask] .= 0</code></pre></li><li><p>Normalize (for unnormalized FFT):</p><pre><code class="language-julia hljs">J_k ./= (nx * ny)</code></pre></li></ol><h3 id="Conservation-Properties"><a class="docs-heading-anchor" href="#Conservation-Properties">Conservation Properties</a><a id="Conservation-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Conservation-Properties" title="Permalink"></a></h3><p>The pseudo-spectral advection conserves:</p><ul><li><strong>Circulation</strong>: <span>$\int J(\psi, q) \, dA = 0$</span></li><li><strong>Energy</strong> (to machine precision in inviscid limit)</li><li><strong>Enstrophy</strong> (to machine precision in inviscid limit)</li></ul><h2 id="Stability-Constraints"><a class="docs-heading-anchor" href="#Stability-Constraints">Stability Constraints</a><a id="Stability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Stability-Constraints" title="Permalink"></a></h2><h3 id="CFL-Condition"><a class="docs-heading-anchor" href="#CFL-Condition">CFL Condition</a><a id="CFL-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#CFL-Condition" title="Permalink"></a></h3><p>For advection terms:</p><p class="math-container">\[\Delta t &lt; \frac{\Delta x}{\max|u|} \approx \frac{L/N}{U}\]</p><h3 id="Diffusion-Stability"><a class="docs-heading-anchor" href="#Diffusion-Stability">Diffusion Stability</a><a id="Diffusion-Stability-1"></a><a class="docs-heading-anchor-permalink" href="#Diffusion-Stability" title="Permalink"></a></h3><p>With integrating factors, there is <strong>no diffusion stability limit</strong>.</p><p>Without integrating factors, explicit diffusion requires:</p><p class="math-container">\[\Delta t &lt; \frac{\Delta x^{2p}}{2\nu}\]</p><p>For hyperdiffusion (p=4), this is very restrictive.</p><h3 id="Recommended-Time-Steps"><a class="docs-heading-anchor" href="#Recommended-Time-Steps">Recommended Time Steps</a><a id="Recommended-Time-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Time-Steps" title="Permalink"></a></h3><table><tr><th style="text-align: left">Resolution</th><th style="text-align: left">Typical dt</th></tr><tr><td style="text-align: left">64^3</td><td style="text-align: left">0.001 - 0.01</td></tr><tr><td style="text-align: left">128^3</td><td style="text-align: left">0.0005 - 0.005</td></tr><tr><td style="text-align: left">256^3</td><td style="text-align: left">0.0002 - 0.002</td></tr><tr><td style="text-align: left">512^3</td><td style="text-align: left">0.0001 - 0.001</td></tr></table><h2 id="Memory-Layout"><a class="docs-heading-anchor" href="#Memory-Layout">Memory Layout</a><a id="Memory-Layout-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Layout" title="Permalink"></a></h2><h3 id="Array-Ordering"><a class="docs-heading-anchor" href="#Array-Ordering">Array Ordering</a><a id="Array-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Ordering" title="Permalink"></a></h3><p>Julia uses <strong>column-major</strong> ordering (Fortran-style):</p><pre><code class="language-julia hljs"># Fast index first for cache efficiency
for k = 1:nz
    for j = 1:ny
        for i = 1:nx
            field[i, j, k] = ...
        end
    end
end</code></pre><h3 id="Complex-Arrays"><a class="docs-heading-anchor" href="#Complex-Arrays">Complex Arrays</a><a id="Complex-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Arrays" title="Permalink"></a></h3><p>Spectral fields are stored as <code>Array{ComplexF64, 3}</code>:</p><pre><code class="language-julia hljs"># Spectral field dimensions
psi_k = zeros(ComplexF64, nx, ny, nz)</code></pre><h3 id="PencilArrays-(Parallel)"><a class="docs-heading-anchor" href="#PencilArrays-(Parallel)">PencilArrays (Parallel)</a><a id="PencilArrays-(Parallel)-1"></a><a class="docs-heading-anchor-permalink" href="#PencilArrays-(Parallel)" title="Permalink"></a></h3><p>In parallel mode, arrays are <code>PencilArray{T,3}</code>:</p><pre><code class="language-julia hljs"># Access underlying data
data = parent(arr)

# Local dimensions
nx_local, ny_local, nz_local = size(data)</code></pre><h2 id="Accuracy-Verification"><a class="docs-heading-anchor" href="#Accuracy-Verification">Accuracy Verification</a><a id="Accuracy-Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-Verification" title="Permalink"></a></h2><h3 id="Order-of-Accuracy"><a class="docs-heading-anchor" href="#Order-of-Accuracy">Order of Accuracy</a><a id="Order-of-Accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-Accuracy" title="Permalink"></a></h3><table><tr><th style="text-align: left">Component</th><th style="text-align: left">Spatial Order</th><th style="text-align: left">Temporal Order</th></tr><tr><td style="text-align: left">Horizontal derivatives</td><td style="text-align: left">Spectral</td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">Vertical derivatives</td><td style="text-align: left">2nd</td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">Elliptic solvers</td><td style="text-align: left">2nd (vertical)</td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">Time stepping (Leapfrog)</td><td style="text-align: left">-</td><td style="text-align: left">2nd</td></tr><tr><td style="text-align: left">Integrating factors</td><td style="text-align: left">-</td><td style="text-align: left">Exact</td></tr></table><h3 id="Conservation-Tests"><a class="docs-heading-anchor" href="#Conservation-Tests">Conservation Tests</a><a id="Conservation-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Conservation-Tests" title="Permalink"></a></h3><p>Run with inviscid settings to verify:</p><ul><li>Energy conservation (&lt; 10^-10 relative change)</li><li>Enstrophy conservation (&lt; 10^-10 relative change)</li></ul><pre><code class="language-julia hljs"># Check energy conservation
KE_initial = flow_kinetic_energy(state.u, state.v)
# ... run simulation ...
KE_final = flow_kinetic_energy(state.u, state.v)
println(&quot;Relative change: &quot;, abs(KE_final - KE_initial) / KE_initial)</code></pre><h2 id="Performance-Optimization"><a class="docs-heading-anchor" href="#Performance-Optimization">Performance Optimization</a><a id="Performance-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Optimization" title="Permalink"></a></h2><h3 id="Key-Optimizations"><a class="docs-heading-anchor" href="#Key-Optimizations">Key Optimizations</a><a id="Key-Optimizations-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Optimizations" title="Permalink"></a></h3><ol><li><strong>Pre-allocated work arrays</strong>: No allocations in time loop</li><li><strong>FFTW planning</strong>: Measured plans for optimal performance</li><li><strong>Loop fusion</strong>: <code>@.</code> macro for element-wise operations</li><li><strong>In-place operations</strong>: Minimize memory allocation</li><li><strong>Workspace reuse</strong>: Pre-allocated z-pencil arrays for transposes</li></ol><h3 id="Profiling"><a class="docs-heading-anchor" href="#Profiling">Profiling</a><a id="Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Profile

# Profile time stepping
@profile for _ in 1:100
    leapfrog_step!(state_np1, state_n, state_nm1, grid, params, plans;
                   a=a_vec, dealias_mask=mask, workspace=workspace)
end

Profile.print()</code></pre><p>Typical hotspots:</p><ul><li>FFT transforms (~40-50%)</li><li>Tridiagonal solves (~20-30%)</li><li>Transpose operations (~10-20% in parallel)</li><li>Array operations (~10-20%)</li></ul><h3 id="Parallel-Scaling"><a class="docs-heading-anchor" href="#Parallel-Scaling">Parallel Scaling</a><a id="Parallel-Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Scaling" title="Permalink"></a></h3><table><tr><th style="text-align: left">Processes</th><th style="text-align: left">Expected Speedup</th><th style="text-align: left">Limiting Factor</th></tr><tr><td style="text-align: left">1-16</td><td style="text-align: left">Near linear</td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">16-64</td><td style="text-align: left">Good</td><td style="text-align: left">Transpose overhead</td></tr><tr><td style="text-align: left">64-256</td><td style="text-align: left">Moderate</td><td style="text-align: left">Communication</td></tr><tr><td style="text-align: left">256+</td><td style="text-align: left">Diminishing</td><td style="text-align: left">Problem size dependent</td></tr></table><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Canuto, C., et al. (2006). <em>Spectral Methods: Fundamentals in Single Domains</em>. Springer.</li><li>Durran, D. R. (2010). <em>Numerical Methods for Fluid Dynamics</em>. Springer.</li><li>PencilArrays.jl documentation: https://jipolanco.github.io/PencilArrays.jl/</li><li>PencilFFTs.jl documentation: https://jipolanco.github.io/PencilFFTs.jl/</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../wave_mean/">« Wave-Mean Interaction</a><a class="docs-footer-nextpage" href="../../guide/configuration/">Configuration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 17 December 2025 20:26">Wednesday 17 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
