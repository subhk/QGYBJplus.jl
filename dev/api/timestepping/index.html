<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Time Stepping · QGYBJ.jl</title><meta name="title" content="Time Stepping · QGYBJ.jl"/><meta property="og:title" content="Time Stepping · QGYBJ.jl"/><meta property="twitter:title" content="Time Stepping · QGYBJ.jl"/><meta name="description" content="Documentation for QGYBJ.jl."/><meta property="og:description" content="Documentation for QGYBJ.jl."/><meta property="twitter:description" content="Documentation for QGYBJ.jl."/><meta property="og:url" content="https://subhk.github.io/QGYBJ.jl/stable/api/timestepping/"/><meta property="twitter:url" content="https://subhk.github.io/QGYBJ.jl/stable/api/timestepping/"/><link rel="canonical" href="https://subhk.github.io/QGYBJ.jl/stable/api/timestepping/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QGYBJ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../worked_example/">Worked Example</a></li></ul></li><li><span class="tocitem">Physics &amp; Theory</span><ul><li><a class="tocitem" href="../../physics/overview/">Model Overview</a></li><li><a class="tocitem" href="../../physics/qg_equations/">QG Equations</a></li><li><a class="tocitem" href="../../physics/ybj_plus/">YBJ+ Wave Model</a></li><li><a class="tocitem" href="../../physics/wave_mean/">Wave-Mean Interaction</a></li><li><a class="tocitem" href="../../physics/numerical_methods/">Numerical Methods</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../guide/configuration/">Configuration</a></li><li><a class="tocitem" href="../../guide/stratification/">Stratification</a></li><li><a class="tocitem" href="../../guide/initial_conditions/">Initial Conditions</a></li><li><a class="tocitem" href="../../guide/simulation/">Running Simulations</a></li><li><a class="tocitem" href="../../guide/io/">I/O and Output</a></li><li><a class="tocitem" href="../../guide/diagnostics/">Diagnostics</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../../advanced/parallel/">MPI Parallelization</a></li><li><a class="tocitem" href="../../advanced/particles/">Particle Advection</a></li><li><a class="tocitem" href="../../advanced/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../advanced/performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../types/">Core Types</a></li><li><a class="tocitem" href="../grid_state/">Grid &amp; State</a></li><li><a class="tocitem" href="../physics/">Physics Functions</a></li><li class="is-active"><a class="tocitem" href>Time Stepping</a><ul class="internal"><li><a class="tocitem" href="#Main-Time-Stepping-Scheme"><span>Main Time Stepping Scheme</span></a></li><li><a class="tocitem" href="#Forward-Euler-Projection-Step"><span>Forward Euler Projection Step</span></a></li><li><a class="tocitem" href="#Leapfrog-Step-with-Robert-Asselin-Filter"><span>Leapfrog Step with Robert-Asselin Filter</span></a></li><li><a class="tocitem" href="#Forward-Euler-Update"><span>Forward Euler Update</span></a></li><li><a class="tocitem" href="#Tendency-Computation"><span>Tendency Computation</span></a></li><li><a class="tocitem" href="#Integrating-Factors"><span>Integrating Factors</span></a></li><li><a class="tocitem" href="#Complete-Simulation-Loop"><span>Complete Simulation Loop</span></a></li><li><a class="tocitem" href="#CFL-Condition"><span>CFL Condition</span></a></li><li><a class="tocitem" href="#Robert-Asselin-Filter-Parameter"><span>Robert-Asselin Filter Parameter</span></a></li><li><a class="tocitem" href="#Time-Level-Management"><span>Time Level Management</span></a></li><li><a class="tocitem" href="#Physics-Switches"><span>Physics Switches</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#API-Summary"><span>API Summary</span></a></li></ul></li><li><a class="tocitem" href="../particles/">Particles</a></li><li><a class="tocitem" href="../">Full Index</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Time Stepping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Time Stepping</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/QGYBJ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/QGYBJ.jl/blob/main/docs/src/api/timestepping.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api-timestepping"><a class="docs-heading-anchor" href="#api-timestepping">Time Stepping</a><a id="api-timestepping-1"></a><a class="docs-heading-anchor-permalink" href="#api-timestepping" title="Permalink"></a></h1><p>This page documents the time integration functions.</p><h2 id="Main-Time-Stepping-Scheme"><a class="docs-heading-anchor" href="#Main-Time-Stepping-Scheme">Main Time Stepping Scheme</a><a id="Main-Time-Stepping-Scheme-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Time-Stepping-Scheme" title="Permalink"></a></h2><p>QGYBJ.jl uses a <strong>Leapfrog scheme with Robert-Asselin filter</strong> for time integration. This provides second-order accuracy while maintaining stability through computational mode damping.</p><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p>The time stepping consists of two functions:</p><ol><li><code>first_projection_step!</code> - Forward Euler initialization</li><li><code>leapfrog_step!</code> - Main leapfrog integration with Robert-Asselin filter</li></ol><h2 id="Forward-Euler-Projection-Step"><a class="docs-heading-anchor" href="#Forward-Euler-Projection-Step">Forward Euler Projection Step</a><a id="Forward-Euler-Projection-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Euler-Projection-Step" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QGYBJ.first_projection_step!"><a class="docstring-binding" href="#QGYBJ.first_projection_step!"><code>QGYBJ.first_projection_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">first_projection_step!(S, G, par, plans; a, dealias_mask=nothing, workspace=nothing)</code></pre><p>Forward Euler initialization step for the leapfrog time stepper.</p><p><strong>Purpose</strong></p><p>The leapfrog scheme requires values at two time levels (n and n-1). This function takes the initial state and advances it by one Forward Euler step, providing the needed second time level.</p><p><strong>Algorithm</strong></p><ol><li><p><strong>Compute tendencies at time n:</strong></p><ul><li>Advection of q and B by geostrophic flow</li><li>Wave refraction by vorticity</li><li>Vertical diffusion</li></ul></li><li><p><strong>Apply physics switches:</strong></p><ul><li><code>linear</code>: Zero nonlinear advection</li><li><code>inviscid</code>: Zero dissipation</li><li><code>passive_scalar</code>: Zero dispersion and refraction</li><li><code>fixed_flow</code>: Mean flow doesn&#39;t evolve</li></ul></li><li><p><strong>Forward Euler update:</strong> For each spectral mode:</p><pre><code class="nohighlight hljs">q^(n+1) = [q^n - dt × tendency_q + dt × diffusion] × exp(-λ_q × dt)
B^(n+1) = [B^n - dt × tendency_B] × exp(-λ_B × dt)</code></pre><p>where λ is the hyperdiffusion factor.</p></li><li><p><strong>Wave feedback (optional):</strong></p><pre><code class="nohighlight hljs">q* = q - qʷ</code></pre></li><li><p><strong>Diagnostic inversions:</strong></p><ul><li>q → ψ (elliptic inversion)</li><li>B → A, C (YBJ+ inversion)</li><li>ψ → u, v (velocity computation)</li></ul></li></ol><p><strong>Arguments</strong></p><ul><li><code>S::State</code>: State to advance (modified in place)</li><li><code>G::Grid</code>: Grid struct</li><li><code>par::QGParams</code>: Model parameters</li><li><code>plans</code>: FFT plans</li><li><code>a</code>: Elliptic coefficient array a_ell(z) = Bu/N²</li><li><code>dealias_mask</code>: Optional 2/3 dealiasing mask (nx × ny)</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li></ul><p><strong>Returns</strong></p><p>Modified state S at time n+1.</p><p><strong>Fortran Correspondence</strong></p><p>This matches the projection step in main_waqg.f90.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Initialize and run projection step
state = init_state(grid, params)
init_random_psi!(state, grid, params, plans)
a = a_ell_ut(params, grid)
L = dealias_mask(params, grid)
first_projection_step!(state, grid, params, plans; a=a, dealias_mask=L)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJ.jl/blob/7d69ffc93d443325e10f049adaffe4528edcf173/src/timestep.jl#L81-L145">source</a></section></details></article><p><strong>Purpose:</strong> Initialize the leapfrog scheme by providing values at times n and n-1.</p><p><strong>Algorithm:</strong></p><ol><li>Compute tendencies at time n (advection, refraction, diffusion)</li><li>Apply physics switches (linear, inviscid, etc.)</li><li>Forward Euler update with integrating factors</li><li>Wave feedback (optional)</li><li>Diagnostic inversions (q → ψ → u, v)</li></ol><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Serial mode
first_projection_step!(state, grid, params, plans; a=a_ell, dealias_mask=L)

# Parallel mode (2D decomposition)
first_projection_step!(state, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)</code></pre><h2 id="Leapfrog-Step-with-Robert-Asselin-Filter"><a class="docs-heading-anchor" href="#Leapfrog-Step-with-Robert-Asselin-Filter">Leapfrog Step with Robert-Asselin Filter</a><a id="Leapfrog-Step-with-Robert-Asselin-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Leapfrog-Step-with-Robert-Asselin-Filter" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QGYBJ.leapfrog_step!"><a class="docstring-binding" href="#QGYBJ.leapfrog_step!"><code>QGYBJ.leapfrog_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a, dealias_mask=nothing, workspace=nothing)</code></pre><p>Advance the solution by one leapfrog time step with Robert-Asselin filtering.</p><p><strong>Algorithm</strong></p><p><strong>1. Compute tendencies at time n:</strong></p><pre><code class="nohighlight hljs">F_q^n = J(ψ^n, q^n) - νz∂²q^(n-1)/∂z²
F_B^n = J(ψ^n, B^n) + dispersion + refraction</code></pre><p><strong>2. Leapfrog update with integrating factors:</strong> For each spectral mode (k):</p><pre><code class="nohighlight hljs">q^(n+1) = q^(n-1) × e^(-2λdt) - 2dt × F_q^n × e^(-λdt) + 2dt × diff^(n-1) × e^(-2λdt)
B^(n+1) = B^(n-1) × e^(-2λdt) - 2dt × F_B^n × e^(-λdt)</code></pre><p><strong>3. Robert-Asselin filter:</strong></p><pre><code class="nohighlight hljs">q̃^n = q^n + γ(q^(n-1) - 2q^n + q^(n+1))
B̃^n = B^n + γ(B^(n-1) - 2B^n + B^(n+1))</code></pre><p>The filtered values are stored in Snm1 for the next step.</p><p><strong>4. Wave feedback (if enabled):</strong></p><pre><code class="nohighlight hljs">q*^(n+1) = q^(n+1) - qʷ^(n+1)</code></pre><p><strong>5. Diagnostic inversions:</strong></p><ul><li>q^(n+1) → ψ^(n+1)</li><li>B^(n+1) → A^(n+1), C^(n+1)</li><li>ψ^(n+1) → u^(n+1), v^(n+1)</li></ul><p><strong>Arguments</strong></p><ul><li><code>Snp1::State</code>: State at time n+1 (output)</li><li><code>Sn::State</code>: State at time n (input, filter applied to Snm1)</li><li><code>Snm1::State</code>: State at time n-1 (input, receives filtered values)</li><li><code>G::Grid</code>: Grid struct</li><li><code>par::QGParams</code>: Model parameters</li><li><code>plans</code>: FFT plans</li><li><code>a</code>: Elliptic coefficient array</li><li><code>dealias_mask</code>: Optional dealiasing mask</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li></ul><p><strong>Returns</strong></p><p>Modified Snp1 with solution at time n+1.</p><p><strong>Time Level Management</strong></p><p>After this call:</p><ul><li>Snp1 contains fields at n+1</li><li>Snm1 contains <strong>filtered</strong> fields at n (for next step&#39;s n-1)</li><li>Sn is unchanged (use Snm1 as new Sn in next call)</li></ul><p>Typical loop structure:</p><pre><code class="language-julia hljs">for iter in 1:nsteps
    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans; a=a)
    # Rotate: Snm1 ← Sn, Sn ← Snp1
    Snm1, Sn, Snp1 = Sn, Snp1, Snm1
end</code></pre><p><strong>Fortran Correspondence</strong></p><p>This matches the main leapfrog loop in main_waqg.f90.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># After projection step, run leapfrog
for iter in 1:1000
    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a, dealias_mask=L)
    Snm1, Sn, Snp1 = Sn, Snp1, Snm1
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJ.jl/blob/7d69ffc93d443325e10f049adaffe4528edcf173/src/timestep.jl#L366-L443">source</a></section></details></article><p><strong>The Leapfrog scheme:</strong></p><p class="math-container">\[\phi^{n+1} = \phi^{n-1} + 2\Delta t \times F^n\]</p><p><strong>Robert-Asselin filter (damps computational mode):</strong></p><p class="math-container">\[\tilde{\phi}^n = \phi^n + \gamma(\phi^{n-1} - 2\phi^n + \phi^{n+1})\]</p><p><strong>With integrating factor for hyperdiffusion:</strong></p><p class="math-container">\[\phi^{n+1} = \phi^{n-1} \times e^{-2\lambda\Delta t} + 2\Delta t \times F^n \times e^{-\lambda\Delta t}\]</p><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Serial mode
leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L)

# Parallel mode (2D decomposition)
leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)

# Time level rotation after each step
Snm1, Sn, Snp1 = Sn, Snp1, Snm1</code></pre><h2 id="Forward-Euler-Update"><a class="docs-heading-anchor" href="#Forward-Euler-Update">Forward Euler Update</a><a id="Forward-Euler-Update-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Euler-Update" title="Permalink"></a></h2><p>Used for the first (projection) step:</p><p class="math-container">\[\phi^{n+1} = \left[\phi^n - \Delta t \times F\right] \times e^{-\lambda\Delta t}\]</p><p>The integrating factor <code>e^{-λΔt}</code> handles hyperdiffusion exactly.</p><h2 id="Tendency-Computation"><a class="docs-heading-anchor" href="#Tendency-Computation">Tendency Computation</a><a id="Tendency-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Tendency-Computation" title="Permalink"></a></h2><p>Each time step computes the following tendencies:</p><p><strong>QG Potential Vorticity:</strong></p><p class="math-container">\[F_q = -J(\psi, q) + \nu_z \frac{\partial^2 q}{\partial z^2}\]</p><p><strong>Wave Envelope (real/imaginary parts):</strong></p><p class="math-container">\[F_{BR} = -J(\psi, BR) - \frac{k_h^2}{2}A_I + \frac{1}{2}BI \times \zeta\]</p><p class="math-container">\[F_{BI} = -J(\psi, BI) + \frac{k_h^2}{2}A_R - \frac{1}{2}BR \times \zeta\]</p><h3 id="Nonlinear-Terms"><a class="docs-heading-anchor" href="#Nonlinear-Terms">Nonlinear Terms</a><a id="Nonlinear-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Terms" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJ.Nonlinear.convol_waqg!"><a class="docstring-binding" href="#QGYBJ.Nonlinear.convol_waqg!"><code>QGYBJ.Nonlinear.convol_waqg!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">convol_waqg!(nqk, nBRk, nBIk, u, v, qk, BRk, BIk, G, plans; Lmask=nothing)</code></pre><p>Compute advection terms in divergence form, matching Fortran <code>convol_waqg</code>.</p><p><strong>Mathematical Form</strong></p><p>Uses the divergence form of the Jacobian:</p><pre><code class="nohighlight hljs">J(ψ, q) = ∂(uq)/∂x + ∂(vq)/∂y</code></pre><p>where u, v are the geostrophic velocities (in real space).</p><p><strong>Output</strong></p><ul><li><code>nqk</code>:  Ĵ(ψ, q) - advection of QGPV</li><li><code>nBRk</code>: Ĵ(ψ, BR) - advection of wave real part</li><li><code>nBIk</code>: Ĵ(ψ, BI) - advection of wave imaginary part</li></ul><p><strong>Arguments</strong></p><ul><li><code>nqk, nBRk, nBIk</code>: Output arrays (spectral)</li><li><code>u, v</code>: Real-space velocity arrays (precomputed)</li><li><code>qk, BRk, BIk</code>: Input fields (spectral)</li><li><code>G::Grid</code>: Grid struct</li><li><code>plans</code>: FFT plans</li><li><code>Lmask</code>: Dealiasing mask (true = keep mode, false = zero)</li></ul><p><strong>Algorithm</strong></p><p>For each field χ ∈ {q, BR, BI}:</p><ol><li>Transform χ̂ → χ (inverse FFT)</li><li>Compute uχ and vχ (pointwise in real space)</li><li>Transform back: (ûχ), (v̂χ)</li><li>Compute divergence: ikₓ(ûχ) + ikᵧ(v̂χ)</li><li>Apply dealiasing mask</li></ol><p><strong>Fortran Correspondence</strong></p><p>This matches <code>convol_waqg</code> in derivatives.f90.</p><p><strong>Note</strong></p><p>The velocities u, v should be precomputed and passed in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJ.jl/blob/7d69ffc93d443325e10f049adaffe4528edcf173/src/nonlinear.jl#L197-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJ.Nonlinear.refraction_waqg!"><a class="docstring-binding" href="#QGYBJ.Nonlinear.refraction_waqg!"><code>QGYBJ.Nonlinear.refraction_waqg!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refraction_waqg!(rBRk, rBIk, BRk, BIk, psik, G, plans; Lmask=nothing)</code></pre><p>Compute wave refraction term: B × ζ where ζ = ∇²ψ is relative vorticity.</p><p><strong>Physical Interpretation</strong></p><p>Near-inertial waves are refracted by vorticity gradients:</p><ul><li>Anticyclones (ζ &lt; 0): Wave focusing, amplitude increase</li><li>Cyclones (ζ &gt; 0): Wave defocusing, amplitude decrease</li></ul><p>This is the &quot;wave capture&quot; mechanism that traps NIWs in anticyclonic eddies.</p><p><strong>Mathematical Form</strong></p><pre><code class="nohighlight hljs">refraction = B × ζ</code></pre><p>where ζ = ∇²ψ = -kₕ²ψ̂ in spectral space.</p><p><strong>Output</strong></p><ul><li><code>rBRk</code>: Real part of refraction term (spectral)</li><li><code>rBIk</code>: Imaginary part of refraction term (spectral)</li></ul><p><strong>Algorithm</strong></p><ol><li>Compute ζ̂ = -kₕ²ψ̂ (spectral)</li><li>Transform ζ̂, B̂R, B̂I to real space</li><li>Compute products: rBR = ζ × BR, rBI = ζ × BI</li><li>Transform back and apply dealiasing</li></ol><p><strong>Fortran Correspondence</strong></p><p>This matches <code>refraction_waqg</code> in derivatives.f90.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">refraction_waqg!(rBR, rBI, BR, BI, psi, grid, plans; Lmask=L)
# rBR, rBI now contain the refraction tendencies</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJ.jl/blob/7d69ffc93d443325e10f049adaffe4528edcf173/src/nonlinear.jl#L355-L390">source</a></section></details></article><p><strong>Advection:</strong> <code>convol_waqg!</code> computes J(ψ, q), J(ψ, BR), J(ψ, BI)</p><p><strong>Refraction:</strong> <code>refraction_waqg!</code> computes B × ζ where ζ = ∇²ψ</p><h3 id="Vertical-Diffusion"><a class="docs-heading-anchor" href="#Vertical-Diffusion">Vertical Diffusion</a><a id="Vertical-Diffusion-1"></a><a class="docs-heading-anchor-permalink" href="#Vertical-Diffusion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJ.Nonlinear.dissipation_q_nv!"><a class="docstring-binding" href="#QGYBJ.Nonlinear.dissipation_q_nv!"><code>QGYBJ.Nonlinear.dissipation_q_nv!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dissipation_q_nv!(dqk, qok, par, G)</code></pre><p>Compute vertical diffusion of q with Neumann boundary conditions.</p><p><strong>Mathematical Form</strong></p><pre><code class="nohighlight hljs">D = νz ∂²q/∂z²</code></pre><p>with ∂q/∂z = 0 at z = 0 and z = H.</p><p><strong>Discretization</strong></p><p>Interior points (1 &lt; k &lt; nz):     D[k] = νz (q[k+1] - 2q[k] + q[k-1]) / dz²</p><p>Boundary points (Neumann):     D[1]  = νz (q[2] - q[1]) / dz²     D[nz] = νz (q[nz-1] - q[nz]) / dz²</p><p><strong>Arguments</strong></p><ul><li><code>dqk</code>: Output array for diffusion term</li><li><code>qok</code>: Input q field at time n-1 (for leapfrog)</li><li><code>par</code>: QGParams (for nuz coefficient)</li><li><code>G::Grid</code>: Grid struct</li></ul><p><strong>Note</strong></p><p>This operates on spectral q but the vertical derivative is in physical space, so the operation is the same for each (kx, ky) mode.</p><p><strong>Fortran Correspondence</strong></p><p>This matches <code>dissipation_q_nv</code> in derivatives.f90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJ.jl/blob/7d69ffc93d443325e10f049adaffe4528edcf173/src/nonlinear.jl#L618-L648">source</a></section></details></article><p>Computes νz ∂²q/∂z² using the tridiagonal solver. Automatically handles 2D decomposition transposes.</p><h2 id="Integrating-Factors"><a class="docs-heading-anchor" href="#Integrating-Factors">Integrating Factors</a><a id="Integrating-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Integrating-Factors" title="Permalink"></a></h2><h3 id="Purpose"><a class="docs-heading-anchor" href="#Purpose">Purpose</a><a id="Purpose-1"></a><a class="docs-heading-anchor-permalink" href="#Purpose" title="Permalink"></a></h3><p>For stiff hyperdiffusion terms, we use an integrating factor approach:</p><p class="math-container">\[\tilde{\phi} = \phi \times e^{\nu k^{2p} t}\]</p><p>This allows exact treatment of the linear diffusion while using explicit time stepping.</p><h3 id="Function"><a class="docs-heading-anchor" href="#Function">Function</a><a id="Function-1"></a><a class="docs-heading-anchor-permalink" href="#Function" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJ.Nonlinear.int_factor"><a class="docstring-binding" href="#QGYBJ.Nonlinear.int_factor"><code>QGYBJ.Nonlinear.int_factor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">int_factor(kx, ky, par; waves=false)</code></pre><p>Compute hyperdiffusion integrating factor for given wavenumber.</p><p><strong>Mathematical Background</strong></p><p>The hyperdiffusion operator is:</p><pre><code class="nohighlight hljs">D = -ν₁(-∇²)^n₁ - ν₂(-∇²)^n₂</code></pre><p>In spectral space, this becomes multiplication by:</p><pre><code class="nohighlight hljs">λ = ν₁|k|^(2n₁) + ν₂|k|^(2n₂)</code></pre><p>The integrating factor for one time step is: exp(-λ×dt)</p><p>For efficiency, we return just λ×dt (the exponent).</p><p><strong>Arguments</strong></p><ul><li><code>kx, ky</code>: Horizontal wavenumber components</li><li><code>par</code>: QGParams (contains ν₁, ν₂, n₁, n₂)</li><li><code>waves::Bool</code>: If true, use wave hyperdiffusion (nuh1w, ilap1w, etc.)</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">λ×dt = dt × [ν₁(|kx|^(2n₁) + |ky|^(2n₁)) + ν₂(|kx|^(2n₂) + |ky|^(2n₂))]</code></pre><p><strong>Usage in Time Stepping</strong></p><pre><code class="language-julia hljs"># After computing tendency
factor = exp(-int_factor(kx, ky, par))
q_new = factor * q_tendency</code></pre><p><strong>Fortran Correspondence</strong></p><p>This matches the integrating factor computation in the main loop of main_waqg.f90.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get integrating factor for wavenumber (3, 4)
lambda_dt = int_factor(3.0, 4.0, params)
factor = exp(-lambda_dt)  # Multiply solution by this</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJ.jl/blob/7d69ffc93d443325e10f049adaffe4528edcf173/src/nonlinear.jl#L755-L797">source</a></section></details></article><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Compute factor for a spectral mode
If = int_factor(kx, ky, params; waves=false)   # For mean flow (q)
Ifw = int_factor(kx, ky, params; waves=true)   # For waves (B)

# Apply in time stepping
q_new = q_old * exp(-2*If) - 2*dt * tendency * exp(-If)   # Leapfrog
q_new = q_old * exp(-If) - dt * tendency                    # Euler</code></pre><h2 id="Complete-Simulation-Loop"><a class="docs-heading-anchor" href="#Complete-Simulation-Loop">Complete Simulation Loop</a><a id="Complete-Simulation-Loop-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Simulation-Loop" title="Permalink"></a></h2><h3 id="Setup-and-Run"><a class="docs-heading-anchor" href="#Setup-and-Run">Setup and Run</a><a id="Setup-and-Run-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-and-Run" title="Permalink"></a></h3><pre><code class="language-julia hljs">using QGYBJ

# Initialize
params = default_params(nx=64, ny=64, nz=32)
grid = init_grid(params)
plans = plan_transforms!(grid)
a_ell = a_ell_ut(params, grid)
L = dealias_mask(params, grid)

# Create three state arrays for leapfrog
Snm1 = init_state(grid)  # n-1
Sn = init_state(grid)    # n
Snp1 = init_state(grid)  # n+1

# Initialize with random fields
init_random_psi!(Sn, grid, params, plans; a=a_ell)

# Projection step (Forward Euler initialization)
first_projection_step!(Sn, grid, params, plans; a=a_ell, dealias_mask=L)

# Copy for n-1 state
copy_state!(Snm1, Sn)

# Main time loop
for iter in 1:nsteps
    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans; a=a_ell, dealias_mask=L)

    # Rotate time levels
    Snm1, Sn, Snp1 = Sn, Snp1, Snm1
end</code></pre><h3 id="Parallel-Mode-(2D-Decomposition)"><a class="docs-heading-anchor" href="#Parallel-Mode-(2D-Decomposition)">Parallel Mode (2D Decomposition)</a><a id="Parallel-Mode-(2D-Decomposition)-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Mode-(2D-Decomposition)" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MPI, PencilArrays, PencilFFTs, QGYBJ

MPI.Init()
mpi_config = QGYBJ.setup_mpi_environment()

# Initialize with MPI
params = default_params(nx=256, ny=256, nz=128)
grid = QGYBJ.init_mpi_grid(params, mpi_config)
plans = QGYBJ.plan_mpi_transforms(grid, mpi_config)
workspace = QGYBJ.init_mpi_workspace(grid, mpi_config)

a_ell = a_ell_ut(params, grid)
L = dealias_mask(params, grid)

# Create states
Snm1 = QGYBJ.init_mpi_state(grid, mpi_config)
Sn = QGYBJ.init_mpi_state(grid, mpi_config)
Snp1 = QGYBJ.init_mpi_state(grid, mpi_config)

# Initialize
init_random_psi!(Sn, grid, params, plans; a=a_ell)
first_projection_step!(Sn, grid, params, plans; a=a_ell, dealias_mask=L, workspace=workspace)
copy_state!(Snm1, Sn)

# Main loop with workspace for 2D decomposition
for iter in 1:nsteps
    leapfrog_step!(Snp1, Sn, Snm1, grid, params, plans;
                   a=a_ell, dealias_mask=L, workspace=workspace)
    Snm1, Sn, Snp1 = Sn, Snp1, Snm1
end

MPI.Finalize()</code></pre><h2 id="CFL-Condition"><a class="docs-heading-anchor" href="#CFL-Condition">CFL Condition</a><a id="CFL-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#CFL-Condition" title="Permalink"></a></h2><h3 id="Stability-Constraint"><a class="docs-heading-anchor" href="#Stability-Constraint">Stability Constraint</a><a id="Stability-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Stability-Constraint" title="Permalink"></a></h3><pre><code class="language-julia hljs">function compute_cfl(state, grid, dt)
    u_max = maximum(abs.(state.u))
    v_max = maximum(abs.(state.v))
    return dt * max(u_max/grid.dx, v_max/grid.dy)
end</code></pre><p>For stability, CFL &lt; 1 is required. Recommended: CFL ≈ 0.5.</p><h3 id="Adaptive-Time-Stepping"><a class="docs-heading-anchor" href="#Adaptive-Time-Stepping">Adaptive Time Stepping</a><a id="Adaptive-Time-Stepping-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Time-Stepping" title="Permalink"></a></h3><pre><code class="language-julia hljs">function adaptive_dt(state, grid; cfl_target=0.5, dt_max=0.01)
    u_max = maximum(abs.(state.u)) + 1e-10  # Avoid division by zero
    v_max = maximum(abs.(state.v)) + 1e-10

    dt = cfl_target * min(grid.dx/u_max, grid.dy/v_max)
    return min(dt, dt_max)
end</code></pre><h2 id="Robert-Asselin-Filter-Parameter"><a class="docs-heading-anchor" href="#Robert-Asselin-Filter-Parameter">Robert-Asselin Filter Parameter</a><a id="Robert-Asselin-Filter-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Robert-Asselin-Filter-Parameter" title="Permalink"></a></h2><p>The filter coefficient γ (<code>gamma</code> in <code>QGParams</code>) controls damping of the computational mode:</p><ul><li><strong>Too large</strong> (γ &gt; 0.01): Excessive damping, accuracy loss</li><li><strong>Too small</strong> (γ &lt; 0.0001): Computational mode growth</li><li><strong>Recommended</strong>: γ ≈ 0.001 (default)</li></ul><pre><code class="language-julia hljs">params = default_params(nx=64, ny=64, nz=32; gamma=0.001)</code></pre><h2 id="Time-Level-Management"><a class="docs-heading-anchor" href="#Time-Level-Management">Time Level Management</a><a id="Time-Level-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Level-Management" title="Permalink"></a></h2><p>The leapfrog scheme requires three time levels:</p><table><tr><th style="text-align: left">Variable</th><th style="text-align: left">Description</th><th style="text-align: left">Usage</th></tr><tr><td style="text-align: left"><code>Snm1</code></td><td style="text-align: left">State at n-1</td><td style="text-align: left">Input, receives filtered n values</td></tr><tr><td style="text-align: left"><code>Sn</code></td><td style="text-align: left">State at n</td><td style="text-align: left">Input (unchanged)</td></tr><tr><td style="text-align: left"><code>Snp1</code></td><td style="text-align: left">State at n+1</td><td style="text-align: left">Output</td></tr></table><p>After each step, rotate the pointers:</p><pre><code class="language-julia hljs">Snm1, Sn, Snp1 = Sn, Snp1, Snm1</code></pre><p>This avoids data copying by just swapping references.</p><h2 id="Physics-Switches"><a class="docs-heading-anchor" href="#Physics-Switches">Physics Switches</a><a id="Physics-Switches-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-Switches" title="Permalink"></a></h2><p>The time stepping respects these <code>QGParams</code> switches:</p><table><tr><th style="text-align: left">Switch</th><th style="text-align: left">Effect</th></tr><tr><td style="text-align: left"><code>linear</code></td><td style="text-align: left">Zero nonlinear advection J(ψ, q), J(ψ, B)</td></tr><tr><td style="text-align: left"><code>inviscid</code></td><td style="text-align: left">Zero vertical diffusion νz ∂²q/∂z²</td></tr><tr><td style="text-align: left"><code>passive_scalar</code></td><td style="text-align: left">Waves as passive tracers (no dispersion/refraction)</td></tr><tr><td style="text-align: left"><code>no_dispersion</code></td><td style="text-align: left">Zero wave dispersion (A = 0)</td></tr><tr><td style="text-align: left"><code>fixed_flow</code></td><td style="text-align: left">Mean flow doesn&#39;t evolve (q unchanged)</td></tr><tr><td style="text-align: left"><code>no_wave_feedback</code></td><td style="text-align: left">No qʷ feedback term</td></tr></table><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><h3 id="Timing-Breakdown"><a class="docs-heading-anchor" href="#Timing-Breakdown">Timing Breakdown</a><a id="Timing-Breakdown-1"></a><a class="docs-heading-anchor-permalink" href="#Timing-Breakdown" title="Permalink"></a></h3><p>Typical distribution: | Component | Fraction | |:–––––|:––––-| | FFTs | 40-50% | | Elliptic solves | 20-30% | | Array operations | 15-25% | | Transpose operations (2D) | 5-10% |</p><h3 id="2D-Decomposition-Notes"><a class="docs-heading-anchor" href="#2D-Decomposition-Notes">2D Decomposition Notes</a><a id="2D-Decomposition-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Decomposition-Notes" title="Permalink"></a></h3><p>When using 2D decomposition:</p><ul><li>Pass <code>workspace</code> argument to avoid repeated allocation</li><li>Vertical operations (inversions, diffusion) use automatic transposes</li><li>The workspace contains pre-allocated z-pencil arrays</li></ul><pre><code class="language-julia hljs"># Pre-allocate workspace (once)
workspace = QGYBJ.init_mpi_workspace(grid, mpi_config)

# Reuse for all steps
for step in 1:nsteps
    leapfrog_step!(Snp1, Sn, Snm1, G, par, plans;
                   a=a, dealias_mask=L, workspace=workspace)
    Snm1, Sn, Snp1 = Sn, Snp1, Snm1
end</code></pre><h2 id="API-Summary"><a class="docs-heading-anchor" href="#API-Summary">API Summary</a><a id="API-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#API-Summary" title="Permalink"></a></h2><p>All time stepping functions documented above:</p><ul><li><code>first_projection_step!</code> - Forward Euler initialization step</li><li><code>leapfrog_step!</code> - Main leapfrog integration with Robert-Asselin filter</li><li><code>convol_waqg!</code> - Nonlinear advection computation</li><li><code>refraction_waqg!</code> - Wave refraction term</li><li><code>dissipation_q_nv!</code> - Vertical diffusion</li><li><code>int_factor</code> - Integrating factor for hyperdiffusion</li><li><code>compute_qw!</code> - Wave feedback term (see <a href="../physics/">Physics API</a>)</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../physics/">« Physics Functions</a><a class="docs-footer-nextpage" href="../particles/">Particles »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 15 December 2025 18:48">Monday 15 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
