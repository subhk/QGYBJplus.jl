<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Physics Functions · QGYBJ+.jl</title><meta name="title" content="Physics Functions · QGYBJ+.jl"/><meta property="og:title" content="Physics Functions · QGYBJ+.jl"/><meta property="twitter:title" content="Physics Functions · QGYBJ+.jl"/><meta name="description" content="Documentation for QGYBJ+.jl."/><meta property="og:description" content="Documentation for QGYBJ+.jl."/><meta property="twitter:description" content="Documentation for QGYBJ+.jl."/><meta property="og:url" content="https://subhk.github.io/QGYBJplus.jl/stable/api/physics/"/><meta property="twitter:url" content="https://subhk.github.io/QGYBJplus.jl/stable/api/physics/"/><link rel="canonical" href="https://subhk.github.io/QGYBJplus.jl/stable/api/physics/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QGYBJ+.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../worked_example/">Worked Example</a></li></ul></li><li><span class="tocitem">Physics &amp; Theory</span><ul><li><a class="tocitem" href="../../physics/overview/">Model Overview</a></li><li><a class="tocitem" href="../../physics/qg_equations/">QG Equations</a></li><li><a class="tocitem" href="../../physics/ybj_plus/">YBJ+ Wave Model</a></li><li><a class="tocitem" href="../../physics/wave_mean/">Wave-Mean Interaction</a></li><li><a class="tocitem" href="../../physics/numerical_methods/">Numerical Methods</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../guide/configuration/">Configuration</a></li><li><a class="tocitem" href="../../guide/stratification/">Stratification</a></li><li><a class="tocitem" href="../../guide/initial_conditions/">Initial Conditions</a></li><li><a class="tocitem" href="../../guide/simulation/">Running Simulations</a></li><li><a class="tocitem" href="../../guide/io/">I/O and Output</a></li><li><a class="tocitem" href="../../guide/diagnostics/">Diagnostics</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../../advanced/parallel/">MPI Parallelization</a></li><li><a class="tocitem" href="../../advanced/particles/">Particle Advection</a></li><li><a class="tocitem" href="../../advanced/parallel_particles/">Parallel Particle Algorithm</a></li><li><a class="tocitem" href="../../advanced/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../advanced/performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../types/">Core Types</a></li><li><a class="tocitem" href="../grid_state/">Grid &amp; State</a></li><li class="is-active"><a class="tocitem" href>Physics Functions</a><ul class="internal"><li><a class="tocitem" href="#Elliptic-Inversions"><span>Elliptic Inversions</span></a></li><li><a class="tocitem" href="#Nonlinear-Terms"><span>Nonlinear Terms</span></a></li><li><a class="tocitem" href="#Velocity-Computation"><span>Velocity Computation</span></a></li><li><a class="tocitem" href="#Dissipation"><span>Dissipation</span></a></li><li><a class="tocitem" href="#Diagnostics-Functions"><span>Diagnostics Functions</span></a></li><li><a class="tocitem" href="#Transform-Functions"><span>Transform Functions</span></a></li><li><a class="tocitem" href="#YBJ-Normal-Mode-Functions"><span>YBJ Normal Mode Functions</span></a></li><li><a class="tocitem" href="#Function-Signatures-Summary"><span>Function Signatures Summary</span></a></li><li><a class="tocitem" href="#Performance-Notes"><span>Performance Notes</span></a></li><li><a class="tocitem" href="#2D-Decomposition-Notes"><span>2D Decomposition Notes</span></a></li></ul></li><li><a class="tocitem" href="../timestepping/">Time Stepping</a></li><li><a class="tocitem" href="../particles/">Particles</a></li><li><a class="tocitem" href="../">Full Index</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Physics Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Physics Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/QGYBJplus.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/QGYBJplus.jl/blob/main/docs/src/api/physics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api-physics"><a class="docs-heading-anchor" href="#api-physics">Physics Functions</a><a id="api-physics-1"></a><a class="docs-heading-anchor-permalink" href="#api-physics" title="Permalink"></a></h1><p>This page documents the physics functions in QGYBJ+.jl.</p><h2 id="Elliptic-Inversions"><a class="docs-heading-anchor" href="#Elliptic-Inversions">Elliptic Inversions</a><a id="Elliptic-Inversions-1"></a><a class="docs-heading-anchor-permalink" href="#Elliptic-Inversions" title="Permalink"></a></h2><h3 id="Streamfunction-Inversion"><a class="docs-heading-anchor" href="#Streamfunction-Inversion">Streamfunction Inversion</a><a id="Streamfunction-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Streamfunction-Inversion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Elliptic.invert_q_to_psi!"><a class="docstring-binding" href="#QGYBJplus.Elliptic.invert_q_to_psi!"><code>QGYBJplus.Elliptic.invert_q_to_psi!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invert_q_to_psi!(S, G; a, par=nothing, workspace=nothing)</code></pre><p>Invert spectral QGPV <code>q(kx,ky,z)</code> to obtain streamfunction <code>ψ(kx,ky,z)</code>.</p><p><strong>Mathematical Problem</strong></p><p>For each horizontal wavenumber (kₓ, kᵧ), solve the vertical ODE:</p><pre><code class="nohighlight hljs">a(z) ∂²ψ/∂z² - kₕ² ψ = q</code></pre><p>with Neumann boundary conditions ψ_z = 0 at top and bottom.</p><p><strong>Arguments</strong></p><ul><li><code>S::State</code>: State struct containing <code>q</code> (input) and <code>psi</code> (output)</li><li><code>G::Grid</code>: Grid struct with wavenumbers and vertical coordinates</li><li><code>a::AbstractVector</code>: Elliptic coefficient a_ell(z) = f²/N²(z), length nz</li><li><code>par</code>: Optional QGParams for density weighting (defaults to unity weights)</li><li><code>workspace</code>: Optional z-pencil workspace arrays for 2D decomposition</li></ul><p><strong>Implementation Details</strong></p><p>For 2D decomposition:</p><ol><li>Transpose q from xy-pencil to z-pencil (z becomes local)</li><li>Perform tridiagonal solve on z-pencil data</li><li>Transpose ψ from z-pencil back to xy-pencil</li></ol><p>The discrete system is tridiagonal with structure:</p><ul><li>Diagonal: d[k] = -(a[k] + a[k-1])/r_st[k] - kₕ² dz²</li><li>Upper diagonal: du[k] = a[k]/r_st[k]</li><li>Lower diagonal: dl[k] = a[k-1]/r_st[k]</li></ul><p>where r<em>ut, r</em>st are density weights (unity for Boussinesq).</p><p><strong>Fortran Correspondence</strong></p><p>This matches <code>psi_solver</code> in elliptic.f90.</p><p><strong>Mean Mode (kₕ=0) Handling</strong></p><p>For the horizontal mean mode (kₓ=kᵧ=0), the equation reduces to:     ∂/∂z(a(z) ∂ψ/∂z) = q</p><p>With Neumann boundary conditions (∂ψ/∂z=0 at both boundaries), this operator is <strong>singular</strong>: the homogeneous equation has the constant function as its null space. Consequently:</p><ol><li>A solution exists only if ∫q dz = 0 (compatibility condition)</li><li>The solution is determined only up to an arbitrary constant</li></ol><p>This implementation sets ψ=0 for kₕ=0 because:</p><ul><li>For periodic domains, the mean streamfunction doesn&#39;t affect velocities (u = -∂ψ/∂y, v = ∂ψ/∂x, both zero for constant ψ)</li><li>Standard spectral QG codes typically ignore the barotropic mean</li><li>Initial conditions and forcing are assumed to have zero horizontal mean</li></ul><p>If your application requires tracking vertically-varying barotropic modes, you would need to solve the singular ODE with an additional constraint (e.g., ∫ψ dz = 0) to uniquely determine the solution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a_vec = a_ell_ut(params, G)  # Compute a_ell = f²/N²
invert_q_to_psi!(state, grid; a=a_vec)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/elliptic.jl#L130-L190">source</a></section></details></article><p><strong>Solves:</strong> <span>$\nabla^2\psi + \frac{\partial}{\partial z}\left(\frac{f_0^2}{N^2}\frac{\partial\psi}{\partial z}\right) = q$</span></p><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Serial mode
invert_q_to_psi!(state, grid; a=a_ell)

# Parallel mode (with workspace for 2D decomposition)
invert_q_to_psi!(state, grid; a=a_ell, workspace=workspace)
# Updates state.psi from state.q</code></pre><h3 id="Wave-Amplitude-Inversion"><a class="docs-heading-anchor" href="#Wave-Amplitude-Inversion">Wave Amplitude Inversion</a><a id="Wave-Amplitude-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Wave-Amplitude-Inversion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Elliptic.invert_B_to_A!"><a class="docstring-binding" href="#QGYBJplus.Elliptic.invert_B_to_A!"><code>QGYBJplus.Elliptic.invert_B_to_A!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invert_B_to_A!(S, G, par, a; workspace=nothing)</code></pre><p>YBJ+ wave amplitude recovery: solve for A given B = L⁺A.</p><p><strong>Mathematical Problem</strong></p><p>For each horizontal wavenumber (kₓ, kᵧ), solve:</p><pre><code class="nohighlight hljs">a(z) ∂²A/∂z² - (kₕ²/4) A = B</code></pre><p>with Neumann boundary conditions A_z = 0 at top and bottom.</p><p><strong>Arguments</strong></p><ul><li><code>S::State</code>: State containing <code>B</code> (input), <code>A</code> and <code>C</code> (output)</li><li><code>G::Grid</code>: Grid struct</li><li><code>par</code>: QGParams (for f0, N2 parameters)</li><li><code>a::AbstractVector</code>: Elliptic coefficient a_ell(z) = f²/N²(z)</li><li><code>workspace</code>: Optional z-pencil workspace for 2D decomposition</li></ul><p><strong>Output Fields</strong></p><ul><li><code>S.A</code>: Recovered wave amplitude A</li><li><code>S.C</code>: Vertical derivative C = ∂A/∂z (for wave velocity computation)</li></ul><p><strong>Mean Mode (kₕ=0) Handling</strong></p><p>For the horizontal mean mode (kₓ=kᵧ=0), the equation reduces to:     a(z) ∂²A/∂z² = B</p><p>With Neumann boundary conditions (∂A/∂z=0 at both boundaries), this operator is <strong>singular</strong> - the constant function is in its null space. To select a unique solution, we:</p><ol><li>Fix a gauge (A[1]=0) to obtain a particular solution.</li><li>Remove the vertical mean of A (adds a constant null-space mode).</li></ol><p>This yields a well-defined, mean-zero A for kₕ=0 while preserving the original equation.</p><p><strong>Fortran Correspondence</strong></p><p>This matches <code>A_solver_ybj_plus</code> in elliptic.f90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/elliptic.jl#L788-L826">source</a></section></details></article><p><strong>Solves:</strong> <span>$\frac{\partial}{\partial z}\left(\frac{f_0^2}{N^2}\frac{\partial A}{\partial z}\right) - \frac{k_h^2}{4}A = B$</span></p><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Serial mode
invert_B_to_A!(state, grid, params, a_ell)

# Parallel mode (with workspace for 2D decomposition)
invert_B_to_A!(state, grid, params, a_ell; workspace=workspace)
# Updates state.A from state.B</code></pre><h3 id="Helmholtz-Solver"><a class="docs-heading-anchor" href="#Helmholtz-Solver">Helmholtz Solver</a><a id="Helmholtz-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Helmholtz-Solver" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Elliptic.invert_helmholtz!"><a class="docstring-binding" href="#QGYBJplus.Elliptic.invert_helmholtz!"><code>QGYBJplus.Elliptic.invert_helmholtz!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invert_helmholtz!(dstk, rhs, G, par; a, b=zeros, scale_kh2=1.0, bot_bc=nothing, top_bc=nothing, workspace=nothing)</code></pre><p>General vertical Helmholtz inversion for each horizontal wavenumber.</p><p><strong>Mathematical Problem</strong></p><p>Solve the ODE:</p><pre><code class="nohighlight hljs">a(z) ∂²φ/∂z² + b(z) ∂φ/∂z - scale_kh2 × kₕ² φ = rhs</code></pre><p>with Neumann boundary conditions (∂φ/∂z specified at boundaries).</p><p><strong>Discretization (matches Fortran helmholtzdouble)</strong></p><p>Uses a centered stencil where same a[k], b[k] apply to all diagonals at point k:</p><ul><li>Bottom (k=1):  d = -a[1] - 0.5b[1]Δz - αkₕ²Δz², du = a[1] + 0.5b[1]Δz</li><li>Interior:      d = -2a[k] - αkₕ²Δz², du = a[k] + 0.5b[k]Δz, dl = a[k] - 0.5b[k]Δz</li><li>Top (k=nz):    d = -a[nz] + 0.5b[nz]Δz - αkₕ²Δz², dl = a[nz] - 0.5b[nz]Δz</li></ul><p>Boundary flux terms are added to RHS:</p><ul><li>Bottom: rhs[1] += (a[1] - 0.5b[1]Δz) × Δz × bot_bc</li><li>Top:    rhs[nz] -= (a[nz] + 0.5b[nz]Δz) × Δz × top_bc</li></ul><p><strong>Arguments</strong></p><ul><li><code>dstk</code>: Output array (nz, nx, ny) for solution φ</li><li><code>rhs</code>: Right-hand side array (nz, nx, ny)</li><li><code>G::Grid</code>: Grid struct</li><li><code>par</code>: QGParams (currently unused, kept for API consistency)</li><li><code>a::AbstractVector</code>: Second derivative coefficient a(z), length nz</li><li><code>b::AbstractVector</code>: First derivative coefficient b(z), length nz (default zeros)</li><li><code>scale_kh2::Real</code>: Multiplier α for kₕ² term (default 1.0)</li><li><code>bot_bc</code>, <code>top_bc</code>: Optional boundary flux arrays (nx, ny) for non-zero Neumann BCs</li><li><code>workspace</code>: Optional z-pencil workspace for 2D decomposition</li></ul><p><strong>Fortran Correspondence</strong></p><p>This matches <code>helmholtzdouble</code> in elliptic.f90 exactly.</p><p><strong>Note</strong></p><p>For 2D decomposition, boundary conditions are not yet supported and will trigger a warning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/elliptic.jl#L449-L488">source</a></section></details></article><h2 id="Nonlinear-Terms"><a class="docs-heading-anchor" href="#Nonlinear-Terms">Nonlinear Terms</a><a id="Nonlinear-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Terms" title="Permalink"></a></h2><h3 id="Jacobian"><a class="docs-heading-anchor" href="#Jacobian">Jacobian</a><a id="Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Nonlinear.jacobian_spectral!"><a class="docstring-binding" href="#QGYBJplus.Nonlinear.jacobian_spectral!"><code>QGYBJplus.Nonlinear.jacobian_spectral!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobian_spectral!(dstk, phik, chik, G, plans; Lmask=nothing)</code></pre><p>Compute the Jacobian J(φ, χ) = ∂φ/∂x ∂χ/∂y - ∂φ/∂y ∂χ/∂x using pseudo-spectral method.</p><div class="admonition is-info" id="Usage-Note-6633dad8c4efaddb"><header class="admonition-header">Usage Note<a class="admonition-anchor" href="#Usage-Note-6633dad8c4efaddb" title="Permalink"></a></header><div class="admonition-body"><p>This function is exported for user convenience but is <strong>not used</strong> in the main time-stepping code. The main code uses <code>convol_waqg!</code> instead, which computes advection terms using the divergence form with precomputed velocities.</p></div></div><p><strong>Mathematical Definition</strong></p><p>The Jacobian (also called Poisson bracket) is:</p><pre><code class="nohighlight hljs">J(φ, χ) = ∂φ/∂x ∂χ/∂y - ∂φ/∂y ∂χ/∂x</code></pre><p>In vector form: J(φ, χ) = ẑ · (∇φ × ∇χ)</p><p><strong>Physical Interpretation</strong></p><ul><li>J(ψ, q): Advection of PV by geostrophic flow</li><li>J(ψ, B): Advection of wave envelope by mean flow</li><li>The Jacobian conserves both integrals ∫φ and ∫χ</li></ul><p><strong>Algorithm</strong></p><ol><li>Compute spectral derivatives: φ̂ₓ = ikₓφ̂, φ̂ᵧ = ikᵧφ̂</li><li>Transform derivatives to physical space</li><li>Compute product: J = φₓχᵧ - φᵧχₓ (pointwise)</li><li>Transform result back to spectral space</li></ol><p><strong>Arguments</strong></p><ul><li><code>dstk</code>: Output array for Ĵ(φ, χ) in spectral space</li><li><code>phik</code>: φ̂ in spectral space (must be real field, i.e., Hermitian symmetric)</li><li><code>chik</code>: χ̂ in spectral space (must be real field, i.e., Hermitian symmetric)</li><li><code>G::Grid</code>: Grid with wavenumber arrays</li><li><code>plans</code>: FFT plans from plan_transforms!</li><li><code>Lmask</code>: Optional 2/3 dealiasing mask (true = keep mode, false = zero)</li></ul><p><strong>Important</strong></p><p>This function assumes φ and χ are <strong>real-valued fields</strong> in physical space. For real fields, IFFT of spectral derivatives (im<em>k</em>φ̂) yields real results (up to roundoff), so the physical derivatives are extracted via <code>real()</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Compute J(ψ, q) for real fields ψ and q
jacobian_spectral!(Jpsi_q, psi_k, q_k, grid, plans)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/nonlinear.jl#L72-L118">source</a></section></details></article><p><strong>Computes:</strong> <span>$J(a, b) = \frac{\partial a}{\partial x}\frac{\partial b}{\partial y} - \frac{\partial a}{\partial y}\frac{\partial b}{\partial x}$</span></p><h3 id="Wave-Advection-and-Refraction"><a class="docs-heading-anchor" href="#Wave-Advection-and-Refraction">Wave Advection and Refraction</a><a id="Wave-Advection-and-Refraction-1"></a><a class="docs-heading-anchor-permalink" href="#Wave-Advection-and-Refraction" title="Permalink"></a></h3><p>The wave nonlinear terms are documented in the <a href="../timestepping/">Time Stepping API</a>:</p><ul><li><code>convol_waqg_B!</code> / <code>refraction_waqg_B!</code> / <code>compute_qw_complex!</code> - Complex B (YBJ+) operators</li><li><code>convol_waqg!</code> / <code>refraction_waqg!</code> / <code>compute_qw!</code> - BR/BI-decomposed operators</li></ul><h2 id="Velocity-Computation"><a class="docs-heading-anchor" href="#Velocity-Computation">Velocity Computation</a><a id="Velocity-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Velocity-Computation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QGYBJplus.Operators.compute_velocities!"><a class="docstring-binding" href="#QGYBJplus.Operators.compute_velocities!"><code>QGYBJplus.Operators.compute_velocities!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_velocities!(S, G; plans=nothing, params=nothing, compute_w=true, use_ybj_w=false, N2_profile=nothing, workspace=nothing, dealias_mask=nothing)</code></pre><p>Compute geostrophic velocities from the spectral streamfunction ψ̂.</p><p><strong>Physical Equations</strong></p><p>Horizontal velocities from geostrophic balance:</p><pre><code class="nohighlight hljs">u = -∂ψ/∂y  →  û(k) = -i kᵧ ψ̂(k)
v =  ∂ψ/∂x  →  v̂(k) =  i kₓ ψ̂(k)</code></pre><p>Vertical velocity from QG omega equation:</p><pre><code class="nohighlight hljs">∇²w + (N²/f²) ∂²w/∂z² = 2 J(ψ_z, ∇²ψ)</code></pre><p>or YBJ formulation:</p><pre><code class="nohighlight hljs">w = -(f²/N²) [(∂A/∂x)_z - i(∂A/∂y)_z] + c.c.</code></pre><p><strong>Algorithm</strong></p><ol><li>Compute û = -i kᵧ ψ̂ and v̂ = i kₓ ψ̂ in spectral space</li><li>Transform to physical space via inverse FFT</li><li>Optionally solve omega equation or use YBJ formula for w</li></ol><p><strong>Arguments</strong></p><ul><li><code>S::State</code>: State with ψ (input) and u, v, w (output)</li><li><code>G::Grid</code>: Grid with wavenumbers kx, ky</li><li><code>plans</code>: FFT plans (auto-generated if nothing)</li><li><code>params</code>: Model parameters (for f₀, N²)</li><li><code>compute_w::Bool</code>: If true, compute vertical velocity</li><li><code>use_ybj_w::Bool</code>: If true, use YBJ formula instead of omega equation</li><li><code>N2_profile::Vector</code>: Optional N²(z) profile for vertical velocity computation</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li><li><code>dealias_mask</code>: Optional 2D dealiasing mask for omega equation RHS (quadratic term). Should be the same mask used for other nonlinear terms (typically 2/3 rule).</li></ul><p><strong>Returns</strong></p><p>Modified State with updated u, v, w fields.</p><p><strong>Note</strong></p><p>This computes ONLY QG velocities. For Lagrangian advection including wave effects, use <code>compute_total_velocities!</code> instead.</p><p><strong>Fortran Correspondence</strong></p><p>Matches <code>compute_velo</code> in derivatives.f90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/operators.jl#L127-L174">source</a></section></details></article><p><strong>Computes:</strong></p><ul><li><span>$u = -\partial\psi/\partial y$</span></li><li><span>$v = \partial\psi/\partial x$</span></li></ul><h3 id="Vertical-Velocity"><a class="docs-heading-anchor" href="#Vertical-Velocity">Vertical Velocity</a><a id="Vertical-Velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Vertical-Velocity" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Operators.compute_vertical_velocity!"><a class="docstring-binding" href="#QGYBJplus.Operators.compute_vertical_velocity!"><code>QGYBJplus.Operators.compute_vertical_velocity!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_vertical_velocity!(S, G, plans, params; N2_profile=nothing, workspace=nothing, dealias_mask=nothing)</code></pre><p>Solve the QG omega equation for ageostrophic vertical velocity.</p><p><strong>Physical Background</strong></p><p>In quasi-geostrophic dynamics, the leading-order horizontal flow is non-divergent (∇·u_g = 0). Vertical motion arises from ageostrophic corrections that maintain thermal wind balance as the flow evolves.</p><p>The omega equation relates w to the horizontal flow:</p><pre><code class="nohighlight hljs">∇²w + (N²/f²) ∂²w/∂z² = 2 J(ψ_z, ∇²ψ)</code></pre><p>where:</p><ul><li>Left side: 3D Laplacian (horizontal + stratification-weighted vertical)</li><li>Right side: Jacobian forcing from vertical shear and vorticity</li></ul><p><strong>Physical Interpretation</strong></p><p>The RHS forcing J(ψ_z, ∇²ψ) represents:</p><ul><li>Thermal wind tilting: vertical shear ψ_z interacting with vorticity ∇²ψ</li><li>Frontogenesis/frontolysis: differential advection of temperature gradients</li></ul><p>Strong w occurs at:</p><ul><li>Fronts (sharp density gradients)</li><li>Edges of eddies (strong vorticity gradients)</li></ul><p><strong>Numerical Method</strong></p><ol><li>Compute RHS in spectral space via omega<em>eqn</em>rhs!</li><li>For each horizontal wavenumber (kₓ, kᵧ):<ul><li>Set up tridiagonal system in z</li><li>Solve using LAPACK gtsv! (O(nz) per wavenumber)</li></ul></li><li>Transform w to physical space</li></ol><p><strong>Boundary Conditions</strong></p><p>w = 0 at z = 0 and z = Lz (rigid lid and bottom).</p><p><strong>Arguments</strong></p><ul><li><code>S::State</code>: State with ψ (input) and w (output)</li><li><code>G::Grid</code>: Grid structure</li><li><code>plans</code>: FFT plans</li><li><code>params</code>: Model parameters (f₀)</li><li><code>N2_profile::Vector</code>: Optional N²(z) profile (default: constant N² = 1)</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li><li><code>dealias_mask</code>: 2D dealiasing mask for omega equation RHS. If <code>nothing</code> (default), a standard 2/3-rule mask is computed automatically to avoid aliasing in the quadratic Jacobian term.</li></ul><p><strong>Fortran Correspondence</strong></p><p>Matches omega equation solver in the Fortran implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/operators.jl#L259-L310">source</a></section></details></article><h3 id="Total-Velocities"><a class="docs-heading-anchor" href="#Total-Velocities">Total Velocities</a><a id="Total-Velocities-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Velocities" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Operators.compute_total_velocities!"><a class="docstring-binding" href="#QGYBJplus.Operators.compute_total_velocities!"><code>QGYBJplus.Operators.compute_total_velocities!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_total_velocities!(S, G; plans=nothing, params=nothing, compute_w=true, use_ybj_w=false, N2_profile=nothing, workspace=nothing, dealias_mask=nothing)</code></pre><p>Compute the TOTAL velocity field for Lagrangian particle advection.</p><p><strong>Physical Background</strong></p><p>In QG-YBJ+ dynamics, a particle is advected by:</p><ol><li><strong>Geostrophic flow</strong>: u<em>QG = -∂ψ/∂y, v</em>QG = ∂ψ/∂x</li><li><strong>Wave-induced drift</strong>: Stokes drift from near-inertial waves</li></ol><p>The total velocity is:</p><pre><code class="nohighlight hljs">u_total = u_QG + u_wave
v_total = v_QG + v_wave
w_total = w (from omega equation or YBJ)</code></pre><p><strong>Wave-Induced Horizontal Velocities</strong></p><p>The Stokes drift from the wave envelope:</p><pre><code class="nohighlight hljs">u_wave = Re[(∂A*/∂x)A + A*(∂A/∂x)] = 2 Re[A* ∂A/∂x]
v_wave = Re[(∂A*/∂y)A + A*(∂A/∂y)] = 2 Re[A* ∂A/∂y]</code></pre><p>These wave corrections can be significant in regions of strong wave gradients.</p><p><strong>Usage</strong></p><p>For Lagrangian particle advection, always use this function rather than <code>compute_velocities!</code> to include wave effects.</p><p><strong>Arguments</strong></p><ul><li><code>S::State</code>: State with ψ, A (input) and u, v, w (output)</li><li><code>G::Grid</code>: Grid structure</li><li><code>plans</code>: FFT plans</li><li><code>params</code>: Model parameters</li><li><code>compute_w::Bool</code>: If true, compute vertical velocity</li><li><code>use_ybj_w::Bool</code>: If true, use YBJ formula for w</li><li><code>N2_profile::Vector</code>: Optional N²(z) profile for vertical velocity computation</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li><li><code>dealias_mask</code>: Optional 2D dealiasing mask for omega equation RHS</li></ul><p><strong>Returns</strong></p><p>Modified State with total velocity fields u, v, w.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/operators.jl#L952-L995">source</a></section></details></article><h2 id="Dissipation"><a class="docs-heading-anchor" href="#Dissipation">Dissipation</a><a id="Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation" title="Permalink"></a></h2><h3 id="Vertical-Diffusion"><a class="docs-heading-anchor" href="#Vertical-Diffusion">Vertical Diffusion</a><a id="Vertical-Diffusion-1"></a><a class="docs-heading-anchor-permalink" href="#Vertical-Diffusion" title="Permalink"></a></h3><p>Dissipation functions are documented in the <a href="../timestepping/">Time Stepping API</a>:</p><ul><li><code>dissipation_q_nv!</code> - Applies vertical diffusion <span>$\nu_z \partial^2 q / \partial z^2$</span></li><li><code>int_factor</code> - Integrating factor for stiff hyperdiffusion terms</li></ul><h2 id="Diagnostics-Functions"><a class="docs-heading-anchor" href="#Diagnostics-Functions">Diagnostics Functions</a><a id="Diagnostics-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics-Functions" title="Permalink"></a></h2><h3 id="Energy"><a class="docs-heading-anchor" href="#Energy">Energy</a><a id="Energy-1"></a><a class="docs-heading-anchor-permalink" href="#Energy" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.wave_energy"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.wave_energy"><code>QGYBJplus.Diagnostics.wave_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wave_energy(B, A) -&gt; (E_B, E_A)</code></pre><p>Compute domain-integrated wave energy from both B and A fields (simple version).</p><p><strong>Physical Background</strong></p><p>Two measures of wave energy in the model:</p><ol><li><p><strong>Envelope energy</strong> E_B = Σ |B|²</p><ul><li>Based on the evolved wave envelope</li><li>Directly available from prognostic variable</li></ul></li><li><p><strong>Amplitude energy</strong> E_A = Σ |A|²</p><ul><li>Based on the recovered wave amplitude</li><li>More physically meaningful for wave energy flux</li></ul></li></ol><p><strong>Use Cases</strong></p><ul><li>Monitor total wave energy conservation/dissipation</li><li>Compare E<em>B and E</em>A to verify B→A recovery</li><li>Track energy exchange with mean flow</li></ul><p><strong>Arguments</strong></p><ul><li><code>B::Array{Complex,3}</code>: Wave envelope (spectral or physical)</li><li><code>A::Array{Complex,3}</code>: Wave amplitude (spectral or physical)</li></ul><p><strong>Returns</strong></p><p>Tuple (E<em>B, E</em>A) of domain-summed squared magnitudes.</p><p><strong>Note</strong></p><ul><li>These are domain SUMS, not means. For energy density, divide by grid volume.</li><li>In MPI mode, this returns LOCAL energy. Use mpi<em>reduce</em>sum for global total.</li><li>For physically accurate wave energies with dealiasing and density weighting, use <code>wave_energy_spectral</code> instead.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L718-L751">source</a></section></details></article><p>Flow energy can be computed from velocity fields using standard summation.</p><h3 id="Spectral-Energy-Functions"><a class="docs-heading-anchor" href="#Spectral-Energy-Functions">Spectral Energy Functions</a><a id="Spectral-Energy-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Energy-Functions" title="Permalink"></a></h3><p>The following spectral energy functions compute energy with proper dealiasing and density weighting:</p><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.flow_kinetic_energy_spectral"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.flow_kinetic_energy_spectral"><code>QGYBJplus.Diagnostics.flow_kinetic_energy_spectral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flow_kinetic_energy_spectral(uk, vk, G, par; Lmask=nothing) -&gt; KE</code></pre><p>Compute kinetic energy in spectral space with dealiasing and density weighting.</p><p><strong>Physical Background (matches Fortran diag<em>zentrum/energy</em>linear)</strong></p><p>The kinetic energy is computed as:</p><pre><code class="nohighlight hljs">KE(z) = Σₖ L(kₓ,kᵧ) × (|uₖ|² + |vₖ|²) - 0.5 × (|u₀₀|² + |v₀₀|²)</code></pre><p>The dealiasing correction subtracts half the kh=0 mode because:</p><ul><li>With 2/3 dealiasing: Σₖ (1/2)|u|² = Σₖ L|u|² - 0.5|u(0,0)|²</li></ul><p>The total KE integrates over z with density weighting:</p><pre><code class="nohighlight hljs">KE_total = (1/nz) Σᵢ ρₛ(zᵢ) × KE(zᵢ)</code></pre><p><strong>Algorithm</strong></p><ol><li>Loop over all spectral modes (kₓ, kᵧ, z) with dealiasing mask L</li><li>Accumulate |u|² + |v|² at each level</li><li>Apply dealiasing correction: subtract half the kh=0 mode</li><li>Weight by density ρₛ(z) and integrate (divide by nz)</li></ol><p><strong>Arguments</strong></p><ul><li><code>uk, vk</code>: Spectral velocity fields (complex)</li><li><code>G::Grid</code>: Grid structure</li><li><code>par</code>: QGParams (for density profiles)</li><li><code>Lmask</code>: Optional dealiasing mask (default: all modes included)</li></ul><p><strong>Returns</strong></p><p>Total kinetic energy, normalized by nz, with density weighting.</p><p><strong>Fortran Correspondence</strong></p><p>Matches the kinetic energy computation in <code>diag_zentrum</code> (diagnostics.f90:127-161) and <code>energy_linear</code> (diagnostics.f90:3024-3107).</p><p><strong>Note</strong></p><p>In MPI mode, returns LOCAL energy. Use mpi<em>reduce</em>sum for global total.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L367-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.flow_potential_energy_spectral"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.flow_potential_energy_spectral"><code>QGYBJplus.Diagnostics.flow_potential_energy_spectral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flow_potential_energy_spectral(bk, G, par; Lmask=nothing) -&gt; PE</code></pre><p>Compute potential energy in spectral space with dealiasing and density weighting.</p><p><strong>Physical Background</strong></p><p>The potential energy from buoyancy variance:</p><pre><code class="nohighlight hljs">PE(z) = Σₖ L(kₓ,kᵧ) × (a_ell × ρ₁/ρ₂) × |bₖ|² - 0.5 × correction</code></pre><p>where a_ell = f²/N² is the elliptic coefficient.</p><p>For QG: b = ψ_z, so PE represents available potential energy from isopycnal tilting.</p><p><strong>Arguments</strong></p><ul><li><code>bk</code>: Spectral buoyancy field (complex)</li><li><code>G::Grid</code>: Grid structure</li><li><code>par</code>: QGParams (for f0, N2 and density profiles)</li><li><code>Lmask</code>: Optional dealiasing mask</li></ul><p><strong>Returns</strong></p><p>Total potential energy, normalized by nz, with density weighting.</p><p><strong>Fortran Correspondence</strong></p><p>Matches the potential energy computation in <code>diag_zentrum</code> (ps term).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L459-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.wave_energy_spectral"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.wave_energy_spectral"><code>QGYBJplus.Diagnostics.wave_energy_spectral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wave_energy_spectral(BR, BI, AR, AI, CR, CI, G, par; Lmask=nothing) -&gt; (WKE, WPE, WCE)</code></pre><p>Compute physically accurate wave energies in spectral space with dealiasing.</p><p><strong>Physical Background (matches Fortran wave_energy)</strong></p><p>Three components of wave energy:</p><ol><li><p><strong>Wave Kinetic Energy (WKE)</strong>: WKE = Σₖ (|BRₖ|² + |BIₖ|²) - 0.5×(kh=0 mode)</p><p>This is the envelope-based kinetic energy, analogous to KE ~ ∫(u² + v²)dV.</p></li><li><p><strong>Wave Potential Energy (WPE)</strong>: WPE = Σₖ (0.5/(ρ₂×a_ell)) × kh² × (|CRₖ|² + |CIₖ|²)</p><p>where C = ∂A/∂z and a_ell = f²/N². This represents the potential energy from vertical wave structure.</p></li><li><p><strong>Wave Correction Energy (WCE)</strong>: WCE = Σₖ (1/8) × (1/a_ell²) × kh⁴ × (|ARₖ|² + |AIₖ|²)</p><p>Higher-order correction term from the YBJ+ formulation.</p></li></ol><p><strong>Algorithm</strong></p><ol><li>Loop over all spectral modes with dealiasing mask L</li><li>Accumulate |B|², kh²|C|²/(ρ₂×a<em>ell), kh⁴|A|²/(8×a</em>ell²)</li><li>Apply dealiasing correction: subtract half the kh=0 mode from WKE</li><li>Integrate over z (sum local, divide by nz)</li></ol><p><strong>Arguments</strong></p><ul><li><code>BR, BI</code>: Real and imaginary parts of wave envelope B (spectral)</li><li><code>AR, AI</code>: Real and imaginary parts of wave amplitude A (spectral)</li><li><code>CR, CI</code>: Real and imaginary parts of C = ∂A/∂z (spectral)</li><li><code>G::Grid</code>: Grid structure</li><li><code>par</code>: QGParams (for f0, N2)</li><li><code>Lmask</code>: Optional dealiasing mask</li></ul><p><strong>Returns</strong></p><p>Tuple (WKE, WPE, WCE) of wave energy components, normalized by nz.</p><p><strong>Fortran Correspondence</strong></p><p>Matches <code>wave_energy</code> subroutine in diagnostics.f90 (lines 647-743).</p><p><strong>Note</strong></p><p>In MPI mode, returns LOCAL energy. Use mpi<em>reduce</em>sum for global totals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L762-L807">source</a></section></details></article><h3 id="Global-Energy-Functions-(MPI-aware)"><a class="docs-heading-anchor" href="#Global-Energy-Functions-(MPI-aware)">Global Energy Functions (MPI-aware)</a><a id="Global-Energy-Functions-(MPI-aware)-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Energy-Functions-(MPI-aware)" title="Permalink"></a></h3><p>For parallel simulations, use these MPI-aware versions that reduce across all processes:</p><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.flow_kinetic_energy_spectral_global"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.flow_kinetic_energy_spectral_global"><code>QGYBJplus.Diagnostics.flow_kinetic_energy_spectral_global</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flow_kinetic_energy_spectral_global(uk, vk, G, par; Lmask=nothing, mpi_config=nothing) -&gt; KE</code></pre><p>Compute GLOBAL kinetic energy in spectral space across all MPI processes.</p><p><strong>Arguments</strong></p><ul><li><code>uk, vk</code>: Spectral velocity fields (local portion in MPI mode)</li><li><code>G::Grid</code>: Grid structure</li><li><code>par</code>: QGParams</li><li><code>Lmask</code>: Optional dealiasing mask</li><li><code>mpi_config</code>: MPI configuration (nothing for serial mode)</li></ul><p><strong>Returns</strong></p><p>Global kinetic energy with dealiasing and density weighting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L972-L986">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.flow_potential_energy_spectral_global"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.flow_potential_energy_spectral_global"><code>QGYBJplus.Diagnostics.flow_potential_energy_spectral_global</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flow_potential_energy_spectral_global(bk, G, par; Lmask=nothing, mpi_config=nothing) -&gt; PE</code></pre><p>Compute GLOBAL potential energy in spectral space across all MPI processes.</p><p><strong>Arguments</strong></p><ul><li><code>bk</code>: Spectral buoyancy field (local portion in MPI mode)</li><li><code>G::Grid</code>: Grid structure</li><li><code>par</code>: QGParams</li><li><code>Lmask</code>: Optional dealiasing mask</li><li><code>mpi_config</code>: MPI configuration (nothing for serial mode)</li></ul><p><strong>Returns</strong></p><p>Global potential energy with dealiasing and density weighting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L997-L1011">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.wave_energy_spectral_global"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.wave_energy_spectral_global"><code>QGYBJplus.Diagnostics.wave_energy_spectral_global</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wave_energy_spectral_global(BR, BI, AR, AI, CR, CI, G, par; Lmask=nothing, mpi_config=nothing) -&gt; (WKE, WPE, WCE)</code></pre><p>Compute GLOBAL wave energies in spectral space across all MPI processes.</p><p><strong>Arguments</strong></p><ul><li><code>BR, BI, AR, AI, CR, CI</code>: Spectral wave fields (local portions in MPI mode)</li><li><code>G::Grid</code>: Grid structure</li><li><code>par</code>: QGParams</li><li><code>Lmask</code>: Optional dealiasing mask</li><li><code>mpi_config</code>: MPI configuration (nothing for serial mode)</li></ul><p><strong>Returns</strong></p><p>Tuple (WKE, WPE, WCE) of global wave energy components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L1022-L1036">source</a></section></details></article><h3 id="Energy-Diagnostics-Manager"><a class="docs-heading-anchor" href="#Energy-Diagnostics-Manager">Energy Diagnostics Manager</a><a id="Energy-Diagnostics-Manager-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-Diagnostics-Manager" title="Permalink"></a></h3><p>The <code>EnergyDiagnosticsManager</code> provides automatic saving of energy time series to separate NetCDF files:</p><article><details class="docstring" open="true"><summary id="QGYBJplus.EnergyDiagnostics.EnergyDiagnosticsManager"><a class="docstring-binding" href="#QGYBJplus.EnergyDiagnostics.EnergyDiagnosticsManager"><code>QGYBJplus.EnergyDiagnostics.EnergyDiagnosticsManager</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnergyDiagnosticsManager</code></pre><p>Manages separate energy diagnostic output files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/energy_diagnostics.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.EnergyDiagnostics.record_energies!"><a class="docstring-binding" href="#QGYBJplus.EnergyDiagnostics.record_energies!"><code>QGYBJplus.EnergyDiagnostics.record_energies!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">record_energies!(manager, time, wave_KE, wave_PE, wave_CE, mean_flow_KE, mean_flow_PE)</code></pre><p>Record energy values to the internal time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/energy_diagnostics.jl#L114-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.EnergyDiagnostics.write_all_energy_files!"><a class="docstring-binding" href="#QGYBJplus.EnergyDiagnostics.write_all_energy_files!"><code>QGYBJplus.EnergyDiagnostics.write_all_energy_files!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_all_energy_files!(manager::EnergyDiagnosticsManager)</code></pre><p>Write all energy time series to their respective files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/energy_diagnostics.jl#L180-L184">source</a></section></details></article><p><strong>Output Files:</strong></p><ul><li><code>diagnostic/wave_KE.nc</code> - Wave kinetic energy</li><li><code>diagnostic/wave_PE.nc</code> - Wave potential energy</li><li><code>diagnostic/wave_CE.nc</code> - Wave correction energy (YBJ+)</li><li><code>diagnostic/mean_flow_KE.nc</code> - Mean flow kinetic energy</li><li><code>diagnostic/mean_flow_PE.nc</code> - Mean flow potential energy</li><li><code>diagnostic/total_energy.nc</code> - Summary with all energies</li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia hljs"># Automatic (created during setup_simulation)
sim = setup_simulation(config)
run_simulation!(sim)  # Energies saved automatically

# Manual
manager = EnergyDiagnosticsManager(&quot;output_dir&quot;; output_interval=1.0)
record_energies!(manager, time, wke, wpe, wce, mke, mpe)
write_all_energy_files!(manager)</code></pre><h3 id="Omega-Equation"><a class="docs-heading-anchor" href="#Omega-Equation">Omega Equation</a><a id="Omega-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Omega-Equation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Diagnostics.omega_eqn_rhs!"><a class="docstring-binding" href="#QGYBJplus.Diagnostics.omega_eqn_rhs!"><code>QGYBJplus.Diagnostics.omega_eqn_rhs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">omega_eqn_rhs!(rhs, psi, G, plans; Lmask=nothing, workspace=nothing)</code></pre><p>Compute the RHS forcing for the QG omega equation.</p><p><strong>Physical Background</strong></p><p>The QG omega equation relates vertical velocity w to the horizontal flow:</p><pre><code class="nohighlight hljs">∇²w + (N²/f²) ∂²w/∂z² = 2 J(ψ_z, ∇²ψ)</code></pre><p>This function computes the RHS: 2 J(ψ_z, ∇²ψ), which represents the forcing for ageostrophic vertical motion.</p><p><strong>Physical Interpretation</strong></p><p>The Jacobian J(ψ_z, ∇²ψ) represents:</p><ul><li>ψ_z: Vertical shear of streamfunction (related to thermal wind/buoyancy)</li><li>∇²ψ: Relative vorticity ζ</li><li>J: Cross-gradient interaction</li></ul><p>Strong RHS forcing occurs where:</p><ul><li>Fronts (large ψ_z) interact with vorticity gradients</li><li>Eddies tilt isopycnals through differential advection</li></ul><p><strong>Numerical Method</strong></p><ol><li><p><strong>Vertical derivative</strong>: ψ_z via forward finite difference</p><pre><code class="nohighlight hljs">ψ_z[k] = (ψ[k+1] - ψ[k]) / dz,  ψ_z[nz] = 0 (Neumann)</code></pre></li><li><p><strong>Spectral derivatives</strong>:</p><ul><li>∂ψ<em>z/∂x = i kₓ ψ</em>z</li><li>∂ψ<em>z/∂y = i kᵧ ψ</em>z</li><li>∂(∇²ψ)/∂x = -i kₓ kh² ψ_avg</li><li>∂(∇²ψ)/∂y = -i kᵧ kh² ψ_avg</li></ul><p>where ψ_avg = (ψ[k+1] + ψ[k])/2 for staggered-grid consistency</p></li><li><p><strong>Jacobian in physical space</strong>:</p><pre><code class="nohighlight hljs">J(ψ_z, ∇²ψ) = (∂ψ_z/∂x)(∂∇²ψ/∂y) - (∂ψ_z/∂y)(∂∇²ψ/∂x)</code></pre></li><li><p><strong>Transform back</strong>: FFT to get spectral RHS</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>rhs::Array{Complex,3}</code>: Output RHS array (modified in-place)</li><li><code>psi::Array{Complex,3}</code>: Spectral streamfunction</li><li><code>G::Grid</code>: Grid structure</li><li><code>plans</code>: FFT plans</li><li><code>Lmask</code>: Optional dealiasing mask</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li></ul><p><strong>Returns</strong></p><p>Modified rhs array with the omega equation forcing.</p><p><strong>Fortran Correspondence</strong></p><p>Matches <code>omega_eqn_rhs</code> computation in the Fortran implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/diagnostics.jl#L76-L132">source</a></section></details></article><h2 id="Transform-Functions"><a class="docs-heading-anchor" href="#Transform-Functions">Transform Functions</a><a id="Transform-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Transform-Functions" title="Permalink"></a></h2><h3 id="Forward-Transforms"><a class="docs-heading-anchor" href="#Forward-Transforms">Forward Transforms</a><a id="Forward-Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Transforms" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Transforms.fft_forward!"><a class="docstring-binding" href="#QGYBJplus.Transforms.fft_forward!"><code>QGYBJplus.Transforms.fft_forward!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fft_forward!(dst, src, P::Plans)</code></pre><p>Compute horizontal forward FFT (complex-to-complex) for each z-plane.</p><p><strong>Algorithm</strong></p><p>Serial FFTW backend: Loops over z-slices and applies 2D FFT to each (x,y) plane.</p><p><strong>Arguments</strong></p><ul><li><code>dst</code>: Destination array (spectral space)</li><li><code>src</code>: Source array (physical space)</li><li><code>P::Plans</code>: FFT plans</li></ul><p><strong>Returns</strong></p><p>Modified dst array.</p><p><strong>Note</strong></p><p>For parallel execution with PencilArrays, the MPI support provides a separate <code>fft_forward!(dst::PencilArray, src::PencilArray, plans::MPIPlans)</code> method that handles distributed transforms automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/transforms.jl#L144-L164">source</a></section></details></article><p>Real space → Spectral space</p><h3 id="Backward-Transforms"><a class="docs-heading-anchor" href="#Backward-Transforms">Backward Transforms</a><a id="Backward-Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Transforms" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.Transforms.fft_backward!"><a class="docstring-binding" href="#QGYBJplus.Transforms.fft_backward!"><code>QGYBJplus.Transforms.fft_backward!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fft_backward!(dst, src, P::Plans)</code></pre><p>Compute horizontal inverse FFT (complex-to-complex) for each z-plane.</p><p><strong>Algorithm</strong></p><p>Serial FFTW backend: Loops over z-slices and applies 2D inverse FFT to each (x,y) plane. FFTW.ifft is NORMALIZED (divides by N automatically).</p><p><strong>Arguments</strong></p><ul><li><code>dst</code>: Destination array (physical space, normalized)</li><li><code>src</code>: Source array (spectral space)</li><li><code>P::Plans</code>: FFT plans</li></ul><p><strong>Returns</strong></p><p>Modified dst array.</p><p><strong>Note</strong></p><p>For parallel execution with PencilArrays, the MPI support provides a separate <code>fft_backward!(dst::PencilArray, src::PencilArray, plans::MPIPlans)</code> method that uses <code>ldiv!</code> for normalized inverse transforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/transforms.jl#L173-L194">source</a></section></details></article><p>Spectral space → Real space</p><h3 id="Dealiasing"><a class="docs-heading-anchor" href="#Dealiasing">Dealiasing</a><a id="Dealiasing-1"></a><a class="docs-heading-anchor-permalink" href="#Dealiasing" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QGYBJplus.dealias_mask"><a class="docstring-binding" href="#QGYBJplus.dealias_mask"><code>QGYBJplus.dealias_mask</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dealias_mask(G) -&gt; Matrix{Bool}</code></pre><p>Compute the 2/3-rule dealiasing mask for spectral space.</p><p><strong>Physical Background</strong></p><p>In pseudo-spectral methods, nonlinear terms are computed by:</p><ol><li>Transform fields to physical space (inverse FFT)</li><li>Compute products in physical space</li><li>Transform back to spectral space (forward FFT)</li></ol><p>The problem: A product of two fields with max wavenumber k<em>max produces wavenumbers up to 2×k</em>max. With finite resolution, these high-k components &quot;fold back&quot; (alias) onto resolved wavenumbers, causing errors.</p><p><strong>The 2/3 Rule</strong></p><p>To prevent aliasing from quadratic nonlinearities (e.g., u·∇q):</p><ul><li>Keep only wavenumbers |k| ≤ (2/3) × k_Nyquist</li><li>Truncated modes: set to zero before computing nonlinear products</li><li>Result: product wavenumbers stay within (2/3)×2 = (4/3) &lt; k_Nyquist</li></ul><p>This rule is exact for quadratic nonlinearities in 1D. For 2D with radial cutoff, it provides effective dealiasing.</p><p><strong>Algorithm</strong></p><p>Uses radial (isotropic) cutoff:</p><ul><li>k_max = min(nx, ny) / 3</li><li>Keep mode (i,j) if sqrt(kx² + ky²) ≤ k_max</li><li>More isotropic than rectangular truncation</li></ul><p><strong>Arguments</strong></p><ul><li><code>G::Grid</code>: Grid with dimensions nx, ny</li></ul><p><strong>Returns</strong></p><p>Matrix{Bool} of size (nx, ny):</p><ul><li>true = keep this wavenumber</li><li>false = truncate (set to zero)</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">mask = dealias_mask(G)
q_hat .*= mask  # Zero out aliased modes</code></pre><p><strong>Fortran Correspondence</strong></p><p>Matches <code>LL(i,j)</code> mask in the Fortran implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/physics.jl#L527-L573">source</a></section></details></article><p>Creates a radial dealiasing mask using the 2/3 rule: modes with <span>$k_h^2 &gt; k_{max}^2$</span> where <span>$k_{max} = \min(n_x, n_y) / 3$</span> are zeroed.</p><h3 id="Hyperdiffusion-Parameters"><a class="docs-heading-anchor" href="#Hyperdiffusion-Parameters">Hyperdiffusion Parameters</a><a id="Hyperdiffusion-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Hyperdiffusion-Parameters" title="Permalink"></a></h3><p>Helper functions for computing scale-selective hyperdiffusion coefficients:</p><article><details class="docstring" open="true"><summary id="QGYBJplus.compute_hyperdiff_coeff"><a class="docstring-binding" href="#QGYBJplus.compute_hyperdiff_coeff"><code>QGYBJplus.compute_hyperdiff_coeff</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_hyperdiff_coeff(; dx, dy, dt, order=4, efold_steps=10, kmax_fraction=1.0)</code></pre><p>Compute hyperdiffusion coefficient for given grid spacing and desired damping rate.</p><p><strong>Mathematical Background</strong></p><p>The n-th order hyperdiffusion operator is:     -ν<em>n ∇^n q = -ν</em>n (kₓ² + kᵧ²)^(n/2) q̂  in spectral space</p><p>The damping rate at wavenumber k is: λ = ν_n × k^n</p><p>For the grid scale (k<em>max = π/Δx), we want the amplitude to decay by factor e^(-1) after `efold</em>steps` time steps, giving:     ν<em>n = 1 / (efold</em>steps × dt × k_max^n)</p><p><strong>Arguments</strong></p><ul><li><code>dx, dy</code>: Grid spacing in x and y [m]</li><li><code>dt</code>: Time step [s]</li><li><code>order</code>: Order of hyperdiffusion (4 = biharmonic, 6 = hyper-6, etc.)</li><li><code>efold_steps</code>: Number of time steps for e-folding at grid scale (default: 10)</li><li><code>kmax_fraction</code>: Fraction of Nyquist wavenumber to target (default: 1.0)</li></ul><p><strong>Returns</strong></p><p>Hyperdiffusion coefficient ν_n with units [m^n / s]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For 4th order (biharmonic) hyperdiffusion on a 1km grid with dt=10s
ν₄ = compute_hyperdiff_coeff(dx=1e3, dy=1e3, dt=10.0, order=4, efold_steps=5)

# Use in default_params
par = default_params(nx=128, ny=128, nz=64, Lx=128e3, Ly=128e3, Lz=3000.0,
                     dt=10.0, nt=1000,
                     νₕ₁=ν₄, νₕ₂=0.0, ilap1=2, ilap2=2)  # Pure 4th order</code></pre><p><strong>Notes</strong></p><ul><li>Smaller <code>efold_steps</code> → stronger damping (more dissipative)</li><li>Larger <code>efold_steps</code> → weaker damping (less dissipative)</li><li>For stability, typically use efold_steps ∈ [5, 20]</li><li>The 4th order (biharmonic) is most common: order=4, ilap1=2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/physics.jl#L671-L713">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.compute_hyperdiff_params"><a class="docstring-binding" href="#QGYBJplus.compute_hyperdiff_params"><code>QGYBJplus.compute_hyperdiff_params</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_hyperdiff_params(; nx, ny, Lx, Ly, dt, order=4, efold_steps=10)</code></pre><p>Convenience function to compute hyperdiffusion coefficient from grid parameters.</p><p><strong>Arguments</strong></p><ul><li><code>nx, ny</code>: Grid points in x and y</li><li><code>Lx, Ly</code>: Domain size in x and y [m]</li><li><code>dt</code>: Time step [s]</li><li><code>order</code>: Order of hyperdiffusion (4 = biharmonic, default)</li><li><code>efold_steps</code>: E-folding time in steps (default: 10)</li></ul><p><strong>Returns</strong></p><p>Named tuple (ν₄=..., ilap=...) for use with default_params</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Compute 4th order hyperdiffusion for Asselin example
hd = compute_hyperdiff_params(nx=128, ny=128, Lx=70e3, Ly=70e3, dt=10.0, efold_steps=5)

par = default_params(nx=128, ny=128, nz=64, Lx=70e3, Ly=70e3, Lz=3000.0,
                     dt=10.0, nt=1000,
                     νₕ₁=hd.ν, νₕ₂=0.0, ilap1=hd.ilap, ilap2=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/physics.jl#L727-L751">source</a></section></details></article><p><strong>4th Order Hyperdiffusion (Biharmonic):</strong></p><p>The model supports 4th order horizontal hyperdiffusion (∇⁴ operator) for scale-selective damping of grid-scale noise while preserving large scales:</p><pre><code class="language-julia hljs"># Compute coefficient for 10-step e-folding at grid scale
hd = compute_hyperdiff_params(
    nx=128, ny=128, Lx=70e3, Ly=70e3, dt=10.0,
    order=4, efold_steps=10
)

# Use in parameters
par = default_params(
    nx=128, ny=128, nz=64,
    Lx=70e3, Ly=70e3, Lz=3000.0,
    νₕ₁=hd.ν, ilap1=hd.ilap,  # 4th order hyperdiffusion
    νₕ₂=0.0                    # Disable 2nd hyperviscosity slot
)</code></pre><p><strong>Damping Rate:</strong></p><p>The damping rate at wavenumber <span>$k$</span> is:</p><ul><li>2nd order (∇²): <span>$\lambda = \nu_2 k^2$</span></li><li>4th order (∇⁴): <span>$\lambda = \nu_4 k^4$</span></li><li>8th order (∇⁸): <span>$\lambda = \nu_8 k^8$</span></li></ul><p>Higher orders provide more scale-selective damping, concentrating dissipation at the smallest scales.</p><h2 id="YBJ-Normal-Mode-Functions"><a class="docs-heading-anchor" href="#YBJ-Normal-Mode-Functions">YBJ Normal Mode Functions</a><a id="YBJ-Normal-Mode-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#YBJ-Normal-Mode-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QGYBJplus.YBJNormal.sumB!"><a class="docstring-binding" href="#QGYBJplus.YBJNormal.sumB!"><code>QGYBJplus.YBJNormal.sumB!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sumB!(B, G; Lmask=nothing, workspace=nothing)</code></pre><p>Remove the vertical mean from the wave envelope B at each horizontal wavenumber.</p><p><strong>Physical Background</strong></p><p>In the normal YBJ formulation, the wave envelope B is related to amplitude A by:</p><pre><code class="nohighlight hljs">B = N² ∂²A/∂z²</code></pre><p>Since ∂²A/∂z² must integrate to zero (boundary conditions), B should have zero vertical mean. This function enforces that constraint.</p><p><strong>Algorithm</strong></p><p>For each horizontal wavenumber (kₓ, kᵧ) within the dealiasing mask:</p><ol><li>Compute vertical mean: B̄(kₓ,kᵧ) = (1/nz) Σₖ B(kₓ,kᵧ,k)</li><li>Subtract mean: B(kₓ,kᵧ,k) ← B(kₓ,kᵧ,k) - B̄</li></ol><p>For wavenumbers outside the mask or kh² = 0, set B = 0.</p><p><strong>Arguments</strong></p><ul><li><code>B::Array{Complex,3}</code>: Wave envelope (modified in-place)</li><li><code>G::Grid</code>: Grid structure with wavenumbers</li><li><code>Lmask</code>: Optional dealiasing mask (default: all modes kept)</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li></ul><p><strong>Returns</strong></p><p>Modified B array with zero vertical mean at each (kₓ, kᵧ).</p><p><strong>Fortran Correspondence</strong></p><p>Matches <code>sumB</code> in derivatives.f90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/ybj_normal.jl#L75-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.YBJNormal.compute_sigma"><a class="docstring-binding" href="#QGYBJplus.YBJNormal.compute_sigma"><code>QGYBJplus.YBJNormal.compute_sigma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_sigma(par, G, nBRk, nBIk, rBRk, rBIk; Lmask=nothing, workspace=nothing, N2_profile=nothing) -&gt; sigma</code></pre><p>Compute the sigma constraint for normal YBJ A recovery.</p><p><strong>Physical Background</strong></p><p>When recovering A from B via vertical integration, we need to determine the vertical mean of A. The sigma parameter provides this constraint from the nonlinear forcing terms.</p><p><strong>Mathematical Formula</strong></p><p>For each horizontal wavenumber (kₓ, kᵧ):</p><pre><code class="nohighlight hljs">σ(kₓ,kᵧ) = Σₖ [(rBRk + 2·nBIk)/kh² + i(rBIk - 2·nBRk)/kh²]</code></pre><p>where:</p><ul><li>nBRk, nBIk: Real and imaginary parts of nonlinear advection term</li><li>rBRk, rBIk: Real and imaginary parts of refraction term</li><li>kh² = kₓ² + kᵧ²</li></ul><p><strong>Arguments</strong></p><ul><li><code>par::QGParams</code>: Model parameters</li><li><code>G::Grid</code>: Grid with wavenumbers</li><li><code>nBRk, nBIk</code>: Real/imaginary parts of advection forcing</li><li><code>rBRk, rBIk</code>: Real/imaginary parts of refraction forcing</li><li><code>Lmask</code>: Optional dealiasing mask</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li><li><code>N2_profile</code>: Optional N²(z) profile for consistent stratification physics. If not provided, uses N2_ut(par, G) based on par.stratification.</li></ul><p><strong>Returns</strong></p><p>2D complex array sigma(nx<em>local, ny</em>local) with the constraint values.</p><p><strong>Fortran Correspondence</strong></p><p>Matches <code>compute_sigma</code> in derivatives.f90.</p><p><strong>Note</strong></p><p>In MPI mode with 2D decomposition, this requires z to be fully local. Transpose operations are handled internally if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/ybj_normal.jl#L200-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QGYBJplus.YBJNormal.compute_A!"><a class="docstring-binding" href="#QGYBJplus.YBJNormal.compute_A!"><code>QGYBJplus.YBJNormal.compute_A!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_A!(A, C, BRk, BIk, sigma, par, G; Lmask=nothing, workspace=nothing, N2_profile=nothing)</code></pre><p>Recover wave amplitude A from envelope B using normal YBJ vertical integration.</p><p><strong>Physical Background</strong></p><p>In normal YBJ, B and A are related by:</p><pre><code class="nohighlight hljs">B = N² ∂²A/∂z²</code></pre><p>To recover A from B, we integrate twice:</p><ol><li>First integral: ∂A/∂z = ∫ B/N² dz + c₁</li><li>Second integral: A = ∫∫ B/N² dz² + c₁z + c₂</li></ol><p>The constants are determined by:</p><ul><li>Boundary condition: ∂A/∂z = 0 at top (Neumann)</li><li>Mean constraint: ∫A dz = σ (from sigma)</li></ul><p><strong>Algorithm</strong></p><p>For each horizontal wavenumber (kₓ, kᵧ):</p><p><strong>Stage 1: Cumulative Integration</strong></p><pre><code class="language-julia hljs">Ã[1] = 0
Ã[k] = Ã[k-1] + (Σⱼ₌₁ᵏ⁻¹ B[j]) × N²[k-1] × dz²</code></pre><p><strong>Stage 2: Apply Sigma Constraint</strong></p><pre><code class="language-julia hljs">sumA = Σₖ Ã[k]
adj = (σ - sumA) / nz
A[k] = Ã[k] + adj   # Enforce ∫A = σ</code></pre><p><strong>Stage 3: Compute Vertical Derivative</strong></p><pre><code class="language-julia hljs">C[k] = (A[k+1] - A[k]) / dz   # Forward difference
C[nz] = 0                      # Neumann BC at top</code></pre><p><strong>Arguments</strong></p><ul><li><code>A::Array{Complex,3}</code>: Output wave amplitude (modified in-place)</li><li><code>C::Array{Complex,3}</code>: Output vertical derivative A_z (modified in-place)</li><li><code>BRk, BIk</code>: Real/imaginary parts of wave envelope B</li><li><code>sigma::Array{Complex,2}</code>: Sigma constraint from compute_sigma</li><li><code>par::QGParams</code>: Model parameters</li><li><code>G::Grid</code>: Grid structure</li><li><code>Lmask</code>: Optional dealiasing mask</li><li><code>workspace</code>: Optional pre-allocated workspace for 2D decomposition</li><li><code>N2_profile</code>: Optional N²(z) profile for variable stratification. If not provided, uses <code>N2_ut(par, G)</code>.</li></ul><p><strong>Returns</strong></p><p>Tuple (A, C) with recovered amplitude and its vertical derivative.</p><p><strong>Fortran Correspondence</strong></p><p>Matches <code>compute_A</code> in derivatives.f90.</p><p><strong>Note</strong></p><p>This is the NORMAL YBJ recovery method. For YBJ+, use <code>invert_B_to_A!</code> instead, which solves the full L⁺A = B elliptic problem via tridiagonal solve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/subhk/QGYBJplus.jl/blob/d6ab81c92dcd61be7f53958a5fb5bbfa4240a75f/src/ybj_normal.jl#L357-L418">source</a></section></details></article><h2 id="Function-Signatures-Summary"><a class="docs-heading-anchor" href="#Function-Signatures-Summary">Function Signatures Summary</a><a id="Function-Signatures-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Signatures-Summary" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Input</th><th style="text-align: left">Output</th><th style="text-align: left">In-place</th></tr><tr><td style="text-align: left"><code>invert_q_to_psi!</code></td><td style="text-align: left">q</td><td style="text-align: left">psi</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left"><code>invert_B_to_A!</code></td><td style="text-align: left">B</td><td style="text-align: left">A, C</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left"><code>jacobian_spectral!</code></td><td style="text-align: left">a, b</td><td style="text-align: left">J(a,b)</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left"><code>compute_velocities!</code></td><td style="text-align: left">psi</td><td style="text-align: left">u, v</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left"><code>flow_kinetic_energy</code></td><td style="text-align: left">u, v</td><td style="text-align: left">scalar</td><td style="text-align: left">No</td></tr><tr><td style="text-align: left"><code>wave_energy</code></td><td style="text-align: left">B, A</td><td style="text-align: left">scalar</td><td style="text-align: left">No</td></tr></table><h2 id="Performance-Notes"><a class="docs-heading-anchor" href="#Performance-Notes">Performance Notes</a><a id="Performance-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Notes" title="Permalink"></a></h2><ul><li>All physics functions are <strong>in-place</strong> to avoid allocations</li><li>FFT plans are <strong>pre-computed</strong> for efficiency</li><li>Tridiagonal systems use <strong>Thomas algorithm</strong> (O(n))</li><li>Functions are <strong>type-stable</strong> for optimal JIT compilation</li></ul><h2 id="2D-Decomposition-Notes"><a class="docs-heading-anchor" href="#2D-Decomposition-Notes">2D Decomposition Notes</a><a id="2D-Decomposition-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Decomposition-Notes" title="Permalink"></a></h2><p>Functions requiring vertical operations automatically detect 2D decomposition and use the appropriate method:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Serial</th><th style="text-align: left">Parallel (2D)</th></tr><tr><td style="text-align: left"><code>invert_q_to_psi!</code></td><td style="text-align: left">Direct solve</td><td style="text-align: left">Transpose → solve → transpose</td></tr><tr><td style="text-align: left"><code>invert_B_to_A!</code></td><td style="text-align: left">Direct solve</td><td style="text-align: left">Transpose → solve → transpose</td></tr><tr><td style="text-align: left"><code>compute_vertical_velocity!</code></td><td style="text-align: left">Direct solve</td><td style="text-align: left">Transpose → solve → transpose</td></tr><tr><td style="text-align: left"><code>dissipation_q_nv!</code></td><td style="text-align: left">Direct</td><td style="text-align: left">Transpose if needed</td></tr></table><p><strong>Pattern:</strong></p><pre><code class="language-julia hljs">need_transpose = G.decomp !== nothing &amp;&amp; hasfield(typeof(G.decomp), :pencil_z)
if need_transpose
    _function_2d!(...)   # Uses transpose operations
else
    _function_direct!(...)  # Direct vertical access
end</code></pre><p><strong>Workspace requirement:</strong> Pass <code>workspace</code> argument for parallel mode to avoid repeated allocation of z-pencil arrays.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../grid_state/">« Grid &amp; State</a><a class="docs-footer-nextpage" href="../timestepping/">Time Stepping »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 26 December 2025 20:27">Friday 26 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
